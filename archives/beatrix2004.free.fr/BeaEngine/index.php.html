<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr">
<head>
	<title> Welcome to the BeaEngine Sweet Home - x86 x86-64 disassembler library - (IA-32 & Intel64) </title>
	<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
	<link rel="shortcut icon" href="images/icone.ico" />
	<link rel="stylesheet" href="includes/style.css" type="text/css" media="screen" />
</head>

<body>

<div id="titre">
	<div class="barre_bleue"></div>
	<div class="barre_bleue2"></div>
	<div id="fretsdn"><a href="http://binary-reverser.org"></a></div>
	<div class="menu"><ul>
    <li><a href='index1.php.html'>&#62; see in English version</a></li>
    </ul></div>
</div>

<div id="menu">
	<div class="barre_bleue3"></div>
	<div class="barre_grise"></div>
		<ul>
	<li><a href="index.php.html">Accueil</a></li>
	<li><a href="download.php.html">Téléchargements</a></li>
	<li> <a href="screenshots.php.html">Screenshots</a></li>
	<li> <a href="links.php.html">Documentations</a></li>
	<li><a href="support.php.html">Support</a></li>
	</ul>
	<p><strong>BeaEngine documentation</strong></p>
	<ul>
	<li> <a href="fonction.php.html">fonction Disasm</a></li>
	<li><a href="structure.php.html">structure _Disasm</a></li>
	<li><a href="constants.php.html">Constantes</a></li>
	<li><a href="exemples.php.html">Exemples</a></li>
	<li><a href="licence.php.html">Licence</a></li>
	</ul>
 
</div>

<div id="contenu">
	<div class="barre_bleue">Welcome to the BeaEngine Sweet Home - x86 x86-64 disassembler library - (IA-32 & Intel64) </div>
<h1>Accueil</h1>
<p>
Cet espace est dédié à la notion de désassemblage de code assembleur sur processeurs intel et amd. Ce projet se compose d'une librairie de désassemblage de base (BeaEngine.lib) pour plateformes windows sur architectures IA-32 ou Intel64, d'outils utilisant cette lib (LookInside, plugin pour Immunity Debugger, plugin pour OllyDbg), d'un "Length Disassembler Engine" (LDE64) et d'une documentation sur l'encodage des instructions x86 et x86-64.</p>

<p><strong>BeaEngine.lib</strong> est une librairie codée en C (grâce à l'IDE <a href="http://www.codeblocks.org/">Code::Blocks</a> et au compilateur <a href="http://www.smorgasbordet.com/pellesc/">Pelles C</a> ) conçue pour décoder les instructions des architectures intel 32 bits et/ou 64 bits. Elle comporte à l'heure actuelle une seule fonction appelée <strong>Disasm</strong> qui permet de désassembler n'importe quelle ligne de code qui respecte le jeu d'instructions Intel. Ceci inclus le jeu d'instructions standard, les technologies FPU, MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, VMX. Pour les adeptes de l'analyse de codes malicieux et plus généralement de codes obfusqués, BeaEngine décode également les instructions non documentées proposées comme des "alias" sur <strong>sandpile</strong>. Dans tous les cas de figure, elle renvoie une structure complexe qui décrit de façon très précise l'instruction analysée.</p>
<p>Elle est prévue pour être utilisée en <strong>C</strong> (utilisable avec Visual Studio, Pelles C, LCC ou MingW), en <strong>assembleur</strong> (utilisable avec masm32, nasm, fasm, GoAsm) en <strong>Python</strong> et en <strong>Delphi</strong>. Elle peut être utilisée indifféremment en ring3 et en ring0 puisqu'elle n'utilise pas l'API windows. Elle a été pensée et conçue pour réaliser de nombreuses tâches. Elle permet dans un premier temps d'obtenir le mnémonic et les opérandes suivant la syntaxe spécifiée : syntaxe intel pour Nasm, masm32 et masm64, GoAsm32 et GoAsm64, fasm et syntaxe AT&T. Elle permet également des analyses fines de data-flow ou de control-flow, pour construire des slices ou pour élaborer des patterns d'obfuscation.Le pack proposé ici est composé de la librairie, de son code source sous licence LGPL3, de nombreux exemples plus ou moins complexes incluant les headers pour les langages C, Python, Delphi, masm32, nasm, fasm ,GoAsm.</p>
<p>BeaEngine a été codé à partir des tables d'opcodes proposées dans la documentation intel et a été complété par les tables proposées par Christian Ludloff sur son site <a href="http://www.sandpile.org">www.sandpile.org</a> </p>

<h1><strong>Exemple 1 : décodage simple x86</strong></h1>
<p>Pour cet exemple, nous voulons décoder , sur une architecture 32 bits, la séquence de bytes suivante :</p>
<div class="example2">
<p>0x89, 0x94, 0x88, 0x00, 0x20, 0x40, 0x00</p>
</div>

<p>Si vous demandez une syntaxe de sortie <strong>MASM32</strong> , BeaEngine vous renverra ceci :</p>

<div class="example">
<p>mov dword ptr ds:[eax + ecx*4 + 402000h], edx</p>
</div>

<p>Si vous demandez une syntaxe de sortie <strong>AT&T</strong> , BeaEngine vous renverra ceci :</p>

<div class="example">
<p>movd %edx, %ds:402000h(%eax,%ecx,4)</p>
</div>

<p>Si vous demandez une syntaxe de sortie <strong>NASM</strong> , BeaEngine vous renverra ceci :</p>

<div class="example">
<p>mov dword [ds:eax + ecx*4 + 0x402000], edx</p>
</div>

<p><strong>Exemple 1 : analyse complète</strong>
<p>Pour ceux qui veulent analyser l'instruction précédente de façon précise, BeaEngine propose les champs suivants :</p>
<ul>

<li>MyDisasm.Instruction.Category == GENERAL_PURPOSE_INSTRUCTION + DATA_TRANSFER</li>
<li>MyDisasm.Instruction.Opcode == 0x89</li>
<li>MyDisasm.Instruction.Mnemonic == "mov "</li>
<li>MyDisasm.Argument1.ArgMnemonic == "eax + ecx*4 + 402000h"</li>
<li>MyDisasm.Argument1.ArgType == MEMORY_TYPE</li>
<li>MyDisasm.Argument1.ArgSize == 32</li>
<li>MyDisasm.Argument1.AccessMode == WRITE</li>
<li>MyDisasm.Argument1.Memory.BaseRegister == REG0</li>
<li>MyDisasm.Argument1.Memory.IndexRegister == REG1</li>
<li>MyDisasm.Argument1.Memory.Scale == 4</li>
<li>MyDisasm.Argument1.Memory.Displacement == 0x402000</li>
<li>MyDisasm.Argument1.SegmentReg == DSReg</li>
<li>MyDisasm.Argument2.ArgMnemonic == "edx"</li>
<li>MyDisasm.Argument2.ArgType == REGISTER_TYPE + GENERAL_REG + REG2</li>
<li>MyDisasm.Argument2.ArgSize == 32</li>
<li>MyDisasm.Argument2.AccessMode == READ</li>
</ul>

<h1><strong>Exemple 2 : décodage simple x86-64</strong></h1>
<p>Cette fois ci, nous voulons décoder , sur une architecture 64 bits, la séquence de bytes suivante :</p>
<div class="example2">
<p>0x41, 0x80, 0x7E, 0x01, 0x22</p>
</div>

<p>Si vous demandez une syntaxe de sortie <strong>MASM64</strong> , BeaEngine vous renverra ceci :</p>

<div class="example">
<p>cmp byte ptr ds:[r14+01h], 22h</p>
</div>

<p>Si vous demandez une syntaxe de sortie <strong>AT&T</strong> , BeaEngine vous renverra ceci :</p>

<div class="example">
<p>cmpb $22h, %ds:01h(%r14,)</p>
</div>

<p>Si vous demandez une syntaxe de sortie <strong>NASM</strong> , BeaEngine vous renverra ceci :</p>

<div class="example">
<p>cmp byte [ds:r14+0x01], 0x22</</p>
</div>

<p><strong>Exemple 2 : analyse complète</strong>
<p>Pour ceux qui veulent analyser l'instruction précédente de façon précise, BeaEngine propose les champs suivants :</p>
<ul>

<li>MyDisasm.Instruction.Category == GENERAL_PURPOSE_INSTRUCTION + COMPARISON_INSTRUCTION</li>
<li>MyDisasm.Instruction.Opcode == 0x80</li>
<li>MyDisasm.Instruction.Mnemonic == "cmp "</li>
<li>MyDisasm.Instruction.Immediat == 0x22</li>
<li>MyDisasm.Prefix.Number == 1</li>
<li>MyDisasm.Prefix.REX.state == InUsePrefix</li>
<li>MyDisasm.Prefix.REX.B_ == 1</li>
<li>MyDisasm.Argument1.ArgMnemonic == "r14+01h"</li>
<li>MyDisasm.Argument1.ArgType == MEMORY_TYPE</li>
<li>MyDisasm.Argument1.ArgSize == 8</li>
<li>MyDisasm.Argument1.AccessMode == WRITE</li>
<li>MyDisasm.Argument1.Memory.BaseRegister == REG14</li>
<li>MyDisasm.Argument1.Memory.Displacement == 0x01</li>
<li>MyDisasm.Argument1.SegmentReg == DSReg</li>
<li>MyDisasm.Argument2.ArgMnemonic == "22h"</li>
<li>MyDisasm.Argument2.ArgType == CONSTANT_TYPE + ABSOLUTE_</li>
<li>MyDisasm.Argument2.ArgSize == 8</li>
<li>MyDisasm.Argument2.AccessMode == READ</li>
</ul>

<p><strong>Performances</strong></p>
<p>Pour un poids d'environ 250 ko (sous forme de dll), la fonction <strong>Disasm</strong> de BeaEngine propose un rendement assez confortable. Sur un intel core 2 duo, elle permet de désassembler un fichier de <strong>50 Mo</strong> (contenant l'équivalent de 22 millions d'instructions) en environ <strong>13 secondes</strong>. A titre de comparaison, la fonction Disasm du moteur de OllyDebugger 1.10 qui renvoie également une structure très complète permet de désassembler le même fichier de 50 Mo en environ 40 secondes.</p>

<p><strong>Contributeurs</strong>
<p class="champ">Un grand merci à tous les contributeurs qui ont fait progressé BeaEngine par leurs conseils, leurs correctifs et leurs remarques:</p>
<ul>
<li><strong>William Pomian</strong> : merci pour les très nombreux tests et les nombreux retours qu'il a fait sur cette lib.</li>
<li><strong>Ange Albertini</strong> : merci pour ses retours sur les instructions FPU et plus généralement sur les fameux "alias" utilisés dans les codes malicieux.</li>
<li><strong>Pyrae</strong> : merci pour ses retours et correctifs sur les instructions SSE.</li>
<li><strong>Vincent Roy</strong> : merci pour ses tests de BeaEngine en WinDev.</li>
<li><strong>eedy</strong> : merci pour ses précieux conseils en programmation qui ont fait la base de ce moteur</li>
<li><strong>Neitsa</strong> : A l'origine, BeaEngine était codée en asm. Je remercie Neitsa pour ses macros asm astucieuses utilisées alors.</li>
<li><strong>Kharneth</strong> : merci pour les informations sur les hint_nop.</li>

<!-- ========================================================================================= -->

<h1>Historique et news</h1>
    <table summary="historique et news">
        <tr>
            <td class="date">4 novembre 2009</td>
            <td><strong>BeaEngine 3.1.0 </strong>
                <ul>
                    <li>Correctif : L'override du prefix SS par DS dans le cas où BaseRegister = rBP n'était pas fait.(merci à Sessiondiy)</li>
                    <li>Ajouts : Les instructions AAM et AAD n'ont pas de mnemonics officiels dans le cas où le paramètre est différent de 0x0A. BeaEngine ajoute AAM Ib et AAD Ib.(merci à GUAN)</li>
                    <li>Ajout : BeaEngine gère désormais la présence des préfixes de branche (merci à Tim)</li>
                    <li>Ajout : Pour les développeurs Delphi, ajout de la librairie, du header et d'un exemple</li>
                </ul>
            </td>
        </tr>
        <tr>
            <td class="date">16 octobre 2009</td>
            <td>BeaEngine 3.0.6 (correction d'une mauvaise interprétation des registres cs et ds) Merci à sessiondiy.</td>
        </tr>
        <tr>
            <td class="date">3 octobre 2009</td>
            <td>BeaEngine 3.0.5 (l'instruction non documentée bswap reg16 a été ajoutée)Merci à 29a metal.</td>
        </tr>

        <tr>
            <td class="date">2 août 2009</td>
            <td>BeaEngine 3.0.4 (ajout d'une instruction FPU oubliée) Merci à Rafal Cyran pour m'avoir signalé l'instruction fucomip qui avait été oubliée.</td>
        </tr>

        <tr>
            <td class="date">28 juin 2009</td>
            <td>Header Delphi Merci à Zoxc pour mettre à disposition un header pour les codeurs Delphi.</td>
        </tr>
        <tr>
            <td class="date">1er mars 2009</td>
            <td>BeaEngine 3.0.2 (correction d'un bug sur instruction push imm16) merci à bax.</td>
        </tr>

        <tr>
            <td class="date">23 février 2009</td>
            <td>BeaEngine 3.0.1 (correction d'un bug sur architecture x64) merci à KumaT.</td>
        </tr>
        <tr>
            <td class="date">13 février 2009</td>
            <td>BeaEngine 3.0 (versions x64 et x86 pour le reversing) - codée en C.</td>
        </tr>
        <tr>
            <td class="date">28 juin 2007</td>
            <td>BeaEngine 2.3 (mise à jour).</td>
        </tr>
        <tr>
            <td class="date">1er juin 2007</td>
            <td>BeaEngine 2.2 (mise à jour), doc sur l'encodage des instructions.</td>
        </tr>
        <tr>
            <td class="date">8 mai 2007</td>
            <td>BeaEngine 2.1 - mise à jour (correction de bugs mineurs).</td>
        </tr>
        <tr>
            <td class="date">10 avril 2007</td>
            <td>BeaEngine 2.0 - Routine de désassemblage 32 bits et 64 bits ! (codée en asm pour masm32).</td>
        </tr>
        <tr>
            <td class="date">10 novembre 2006</td>
            <td>BeaEngine 1.0 - Routine de désassemblage 32 bits codée asm pour masm32.</td>
        </tr>
    </table>
<!-- ========================================================================================= -->

<p class="w3c">
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p>

<p class="w3c">
 <a href="http://jigsaw.w3.org/css-validator/">
  <img style="border:0;width:88px;height:31px"
       src="http://jigsaw.w3.org/css-validator/images/vcss" 
       alt="Valid CSS!" />
 </a>
</p>
</div>
</body>
</html>