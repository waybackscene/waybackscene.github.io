<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr">
<head>
<title>Multi-threading - CrkGenMe.exe</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="style.css" type="text/css" media="screen" />

</head>

<body>
<div id="fenetre">
<div class="titre"></div>

<div class="menu">
<ul>
<li><a href='index.html'>Analyse</a></li>
<li><a href='antidebugs.html'>Anti-debugs</a></li>
<li><a href='watchdog.html' >WatchDog</a></li>
<li><a href='keygen.html' >1/2 Keygen</a></li>
<li><a href='greetz.html'>Greetz</a></li>
</ul>

</div>

<div class="contenu">
<p class="droite">Date de publication : vendredi 30 juin 2006</p>
<p class="droite">Auteur : BeatriX</p>
<div class="ligne"></div>

<h1>1.Introduction</h1>
<p> <a href="CrkGenMe.exe">CrkGenMe.exe</a> est un binaire codé en C++ par skirby. Le programme demande un nom et un serial. En cas de saisie correcte, nous avons droit à ceci : </p>
<h6>  <img src="images/youdidit.gif" alt="" /></h6>

<p> Je vais m'efforcer de détailler mon approche pour keygenner ce binaire et conjointement, j'ajouterai des infos en matière de coding. La partie patching ne sera pas du tout traitée.</p>
<p> Dans les grandes lignes, CrkGenMe utilise un système que certains appèlent un <strong>"WatchDog"</strong>, c'est-à-dire qu'il lance plusieurs threads qui se surveillent et qui oeuvrent ensemble à la vérification du serial. Si l'un d'eux est défaillant, le programme s'arrête ou se bloque. Si on tente de les modifier, de les arrêter ou de les debugguer, le programme s'arrête également. La difficulté d'analyse réside donc dans la compréhension du rôle de chaque thread sans oublier que le système tente tant bien que mal de nous en empêcher.</p>
<p> Comme si ceci ne suffisait pas, l'auteur a ajouté du junkcode dans les threads afin de dérouter d'avantage le reverseur.</p>

<h1>2. A la pêche aux infos !</h1>
<p> Commençons par pister le moindre indice qui pourrait nous faire gagner du temps. Lançons un <strong>Snooper</strong> de PE sur la cible (et pourquoi pas snoopy 1.1 tiens) et voyons ce que nous pouvons récupérer d'utile :</p>
<pre>
45A1D4 "main.cpp"
45A56A "threads.cpp"
45A72C "ApiHook.cpp"
45A9D8 "md5.cpp"
45AB76 "crc32.cpp"
45AC72 "JunkCode.cpp"
</pre>
<p> Donc, là, au moins, vous ne pouvez pas dire que vous n'êtes pas au courant : il y a des <strong>threads</strong>, du hash <strong>md5</strong>, du <strong>crc32</strong>, du <strong>hooking d'apis</strong> et du <strong>junkcode</strong>... un esprit averti en vaut 2 !</p>
<p> Entrons maintenant dans le vif du sujet en nous enfonçant un peu plus profondément dans les entrailles de la bête.</p>
<h1>3. Aperçu général du keygenme</h1>
<h6>  <img src="images/schema.png" alt="" /></h6>
<h2>La phase de réveil</h2>
<p>Au démarrage du crackme, nous pouvons voir une simple <strong>DialogBox</strong> se mettre en place. La DialogProc va alors recevoir un message d'initialisation WM_INITDIALOG et va effectuer les tâches suivantes :</p>
<ul>
<li>1. Techniques anti-debug : Le crackme va tenter de détecter en scannant les processus en cours les principaux outils utilisés en RE : IDA - OllyDebugger - WinDbg - SoftIce. Il tente également d'utiliser la fonction classique <strong>IsDebuggerPresent</strong>.</li>
<li>2. Techniques anti-tracing : Le crackme tente également de détecter le tracing en utilisant les fonctions <strong>GetTickCount, GetSystemTime, msvcrt.time</strong>.</li>
<li>3. Lancement des Threads : Enfin, le crackme va lancer (à l'aide de CreateThread) 7 threads. </li>
</ul>
<h2>La phase de vérification</h2>
<p>Durant la saisie des noms et serial, 6 des 7 threads s'évertuent à calculer certaines valeurs en vue de vérifier le serial. 3 de ces threads génèrent 3 nombres N1, N2 et N3 à partir du nom et les 3 autres calculent 3 autres nombres S1, S2 et S3 à partir des valeurs a1,a2,a3 du serial composite "a1-a2-a3-S4".</p>
<p> Si l'utilisateur appuie sur "Validate", un WM_COMMAND  est envoyé à la DialogProc qui aura pour effet d'envoyer un WM_USER+13 au 7ème thread par l'intermédiaire de <strong>PostThreadMessage</strong>.</p>
<p> Ce 7ème thread, à la reception du WM_USER+13 va effectuer de simples comparaisons et va afficher un succès si N1=S1, N2=S2, N3=S3 et S4=0x4BE708B1.</p>
<p>Je précise ici que le thread de test s'auto-contrôle afin d'éviter toute tentative de BreakPoints. En fait, le thread patche son propre code afin d'écraser toute modification. La routine exécutée après reception du message WM_INITDIALOG fait de même.</p>

<h1>4. Recherche des failles</h1>
<p> Je vais dès à présent expliquer la méthode que j'ai employé pour comprendre et casser ce binaire.</p>

<h2>Phase 1 : démarrage du binaire</h2>
<p> Je commence donc par lancer le binaire en tentant de logguer les appels aux fonctions de l'API. J'obtiens ceci :</p>
<pre>
=========> __set_app_type
=========> SetUnhandledExceptionFilter : 00401000
=========> __getmainargs
=========> __p__fmode
=========> __p__environ
=========> FindAtomA
=========> malloc
=========> AddAtom
=========> GetAtomNameA
=========> atexit
=========> GetCommandLineA : "C:\CrkGenMe.exe"
=========> GetStartupInfoA
=========> GetModuleHandleA : Main
=========> DialogBoxParamA : DialogProc en 4026F0
</pre>
<p> On voit clairement ici un démarrage d'un programme C++ mais rien ne se passe avant la DialogBox. </p>

<h2>Phase 2 : Initialisation de la DialogBox.</h2>
<p> La première phase réellement importante débute donc dans la routine exécutée si WM_INIT est reçu par la DialogProc. Les ennuis commencent en 401E28. Les antidebugs les plus dangereux sont ceux que l'on peut voir en 4020F2 :</p>
<h6>  <img src="images/trick1.gif" alt="" /></h6>
<p> En 4057C0, le programme crée un SnapShot des processus et recherche le module dont le nom est passé en paramètre. Il suffit de placer un <strong>retn</strong> à cette adresse  et d'enregistrer la modification pour rendre ce trick inoffensif. A partir de là, on peut lancer le crackme sans aucun souci sous OllyDebugger. </p>

<h2>Phase 3 : Validation du serial</h2>
<p> On remarque que si on actionne le bouton Validate, un message WM_USER+13 est envoyé au thread commençant en 4013CE.</p>

<h2>Phase 4 : Analyse du thread 4013CE</h2>
<p>On repère facilement le thread qui reçoit le message WM_USER+13 envoyé par la DialogProc. Bizarrement, quand on pose un BP sur la routine qui doit être exécutée à la reception du message...rien ne se passe, comme si le thread n'avait pas reçu ce message. Le BreakPoint posé est donc détecté ou écrasé !</p>
<p>Je regarde à deux fois le début de ce thread et je constate qu'il se patche lui-même par un <strong>WriteProcessMemory</strong>. Qu'à cela ne tienne, on fait un <strong>retn 14h</strong> directement à l'entrée du code de cette fonction et le problème est  réglé, le thread ne patche plus rien...et d'ailleurs, plus personne ne patche quoique ce soit. D'ailleurs, après analyse du binaire, on constate qu'un <strong>Timer</strong> se charge aussi de patcher ce thread toutes les 5 secondes. Appeler une fonction de l'API uniquement dans un but d'anti-debug n'est pas une bonne idée. Il faut que cette fonction ait d'autres usages indispensables afin d'éviter un patch brutal et facile comme celui-ci ou il faut tester le retour de la fonction ou tester carrément la fonction elle-même.</p>

<h2>Phase 5 : Attaque du thread</h2>
<p> Nous arrivons ici au noeud du problème. Il s'agit selon moi du point où tout bascule en ce qui concerne l'analyse de ce crackme. Avant, nous sommes dans l'obscurité...après, tout devient clair en quelques minutes. j'ai donc voulu tracer ce thread et voir où il me menait. J'ai donc tracé à l'aveugle sans trop savoir où je pouvait bien tomber.J'ai surtout essayé de tracer le plus longtemps possible en modifiant les flags si un saut tentait de me faire sortir de la routine du thread et ...quelle ne fut pas ma surprise ! le seul saut qui semble modifier quelque chose est celui situé en 401D40 : </p>
<pre>
401D39 cmp dword ptr [ebp-2C], 1010101
401D40 jnz 401DAB
</pre>
<p>Si nous empêchons ce saut, nous tombons sur une MessageBox qui nous affiche le message de succès.</p>
<p>Nous y sommes donc ! le dword stocké en [ebp-2C] doit être égal à 0x1010101. A partir de là, tout va très vite : on remonte dans le code du thread à la recherche d'opérations sur [ebp-2C] et en isolant les quelques lignes utiles, on obtient : </p>
<pre>
40147D mov dword ptr [ebp-2C], 0
4015B3 or dword ptr [ebp-2C], 1000000h
401794 or dword ptr [ebp-2C], 10000h
40193D or dword ptr [ebp-2C], 100h
401CE7 or dword ptr [ebp-2C], 1
</pre>
<p>Ces lignes sont exécutées uniquement si certaines chaines sont égales. On remarque donc que de nombreux calculs présents dans la routine du thread ne servent à rien, et là, on se rappelle de <strong>JunkCode.cpp</strong>. L'auteur a donc essayé de brouiller les pistes. Voici un exemple de ce genre d'astuce :</p>
<h6>  <img src="images/junk.gif" alt="" /></h6>
<p> Nous voyons donc des appels à des fonctions mathématiques comme <strong>pow, cos, sin, atan, sqrt, log</strong>. Quoiqu'il arrive, des appels aussi nombreux à des fonctions aussi tordues auraient du nous mettre la puce à l'oreille...pas évident voire impossible de reverser des équations non linéaires avec autant de fonctions !</p>
<p> Pour l'occasion, Skirby a eu la gentillesse de me fournir le code source de ce genre de junk dont voici un extrait :</p>
<pre>
#define JUNKCODE6 { \
  float jk1 = 0, jk2 = 20; \
  jk1 = (sin(jk2) + 5) * pow(jk1, 3); \
  jk2 = (cos(jk1) + 10) * pow(jk2, 5) * 10; \
  jk1 * 12345 == jk2 * 67890; \
  \
}
</pre>
<h2>Phase 6 : Le coup de grâce.</h2>
<p>Je vais alors jeter un coup d'oeil du côté des 6 threads restants et je constate que les fameuses chaines sont générées par ces derniers. Il s'agit en l'occurence de N1, N2, N3, S1, S2 et S3. Nous n'avons plus qu'à comprendre comment sont générés ces fameux nombres et à coder un keygen mais à ce stade, nous avons compris l'esprit du défi.</p>

<h2>Phase 7 : Le parcours de santé.</h2>
<p> Pour finir, il ne nous reste donc plus qu'à comprendre les calculs effectués pour générer les 6 nombres ci-dessus. Dans un souci d'économie ( en matière d'attaques de binaires, il faut toujours viser le plus efficace ), nous n'allons pas étudier la génération des nombres N1, N2 et N3. En effet, dès que nous saisissons un NOM, le crackme lui-même génère ces fameux nombres...il fait donc la moitié du travail à notre place. Si nous lui volons ces 3 nombres, qui sont donc égaux à S1, S2, S3 il ne nous reste plus qu'à comprendre comment sont calculés ces 3 derniers à partir du SERIAL.</p>
<p class="griser"> Copyright (C)- FRET (2006)</p>


<p class="w3c">
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p>

<p class="w3c">
 <a href="http://jigsaw.w3.org/css-validator/">
  <img style="border:0;width:88px;height:31px"
       src="http://jigsaw.w3.org/css-validator/images/vcss" 
       alt="Valid CSS!" />
 </a>
</p>

</div>
<ul id="aquarium">
<li id="plante"><a href="../index.html"></a></li>
<li id="poisson"><a href="antidebugs.html"></a></li>
</ul>

</div>
</body>
</html>