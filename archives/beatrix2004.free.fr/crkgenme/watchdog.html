<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr">
<head>
<title>Multi-threading - CrkGenMe.exe</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="style.css" type="text/css" media="screen" />

</head>

<body>
<div id="fenetre">
<div class="titre"></div>

<div class="menu">
<ul>
<li><a href='index.html'>Analyse</a></li>
<li><a href='antidebugs.html'>Anti-debugs</a></li>
<li><a href='watchdog.html' >WatchDog</a></li>
<li><a href='keygen.html' >1/2 Keygen</a></li>
<li><a href='greetz.html'>Greetz</a></li>
</ul>

</div>

<div class="contenu">
<p class="droite">Date de publication : vendredi 30 juin 2006</p>
<p class="droite">Auteur : BeatriX</p>
<div class="ligne"></div>

<h1>6. WatchDog</h1>
<p> Voici un schéma simplifié qui illustre le principe du <strong>WatchDog</strong> utilisé ici :</p>
<h6>  <img src="images/watchdog.png" alt="" /></h6>
<p> Tout à l'heure, j'ai dit qu'il y avait 7 threads créés au démarrage. En réalité, il y en a 9 ! Les 2 que j'ai passé sous silence sont ce qu'on appelle les "WatchDog". Ce sont des threads qui ne font rien d'autre que de surveiller l'état des troupes. Ici, j'ai illustré le principe à l'aide d'un seul WatchDog. Ces threads sont donc là pour vérifier que tous les threads de calcul sont actifs et qu'ils n'ont pas été arrêtés par un utilisateur mal intentionné. Pour synchroniser tout ça, l'auteur a utilisé des Timers. Pour finir, les watchdogs vérifient également que les Timers sont opérationnels.</p>
<p>Si nous entrons un peu plus dans le détail, voici comment cela se passe. Pour communiquer avec les timers et les threads de calcul, le WatchDog utilise deux techniques : les Events et des "tokens" matérialisés sous forme de booléens.</p>
<p>Le Timer active un Event (ici, Event1) et le watchdog attend l'activation de cet Event durant un delai de 8 secondes à l'aide de <strong>WaitForSingleObject</strong>. Au delà de ce temps, le watchdog considère que le Timer est mort et ferme l'application.</p>
<p>Chaque thread de calcul passe un booléen (que j'ai appelé tokens) à true à chaque lancement de sa routine. Le watchdog, quant à lui, passe ces booléens à false, attend un bref instant, et teste ces mêmes booléens. Si l'un d'eux est False, ceci signifie que le thread en question est arrêté et le watchdog ferme l'application.</p>
<h2>Portée de ce genre de watchdog ? </h2>
<p>Ici , le watchdog permet de vérifier que les threads et les timers fonctionnent bien tous de concert. Si l'un des threads ou des timers ne démarre pas, l'application s'arrête. Maintenant, si nous posons des BP sur les threads de calcul, que se passe-t-il ?</p>
<p>En fait, le Debuggueur gèle l'application et tous les threads avec. On peut donc tracer tranquillement sans être inquiété des WatchDogs. Le seul souci probable est si on relance l'application (F9). Il peut se produire à peu près n'importe quoi. Le watchdog peut récupérer un WAIT_TIMEOUT ou détecter un token false ou alors il ne se passe rien et le programme continue sa route.</p>
<p class="griser"> Copyright (C)- FRET (2006)</p>


<p class="w3c">
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p>

<p class="w3c">
 <a href="http://jigsaw.w3.org/css-validator/">
  <img style="border:0;width:88px;height:31px"
       src="http://jigsaw.w3.org/css-validator/images/vcss" 
       alt="Valid CSS!" />
 </a>
</p>

</div>
<ul id="aquarium">
<li id="plante"><a href="../index.html"></a></li>
<li id="poisson"><a href="keygen.html"></a></li>
</ul>

</div>
</body>
</html>