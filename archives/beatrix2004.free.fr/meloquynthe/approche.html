<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr">
<head>
<title>Meloquynthe - solution par BeatriX</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="style.css" type="text/css" media="screen" />
<link rel="stylesheet" type="text/css" media="print" href="style_print.css"  />

</head>

<body>
<div id="fenetre">
<div class="titre"></div>

<div class="menu">
<ul>
<li><a href='index.html'>Introduction</a></li>
<li><a href='approche.html'>Approche</a></li>
<li><a href='waveout.html'>waveOut</a></li>
<li><a href='analyse.html' >Analyse</a></li>
<li><a href='greetz.html'>Greetz</a></li>
</ul>

</div>

<div class="contenu">
<p class="droite">Date de publication : 8 mai 2007 15h15</p>
<p class="droite">Auteur : BeatriX</p>
<div class="ligne"></div>
<h1>2. Approche</h1>
<p>  De prime abord, comment attaquer l'analyse d'un tel binaire ? Quelle a été ma démarche pour comprendre ce qu'il se trame derrière ce joli gfx et cette mélodieuse musique ?</p>

<h2> 2.1. Unpacker la cible</h2>
<p> Avant de désassembler ou de débogguer, j'essaie toujours de voir si le binaire est compressé, crypté, bref, s'il dispose d'un système de protection générique contre l'analyse. On va tout d'abord scanner le binaire à la recherche de signatures de packers connus. Pour cela, je vous propose d'utiliser <strong>PEID 0.94</strong>. Voici ce qu'on obtient :</p>
<h6><img src="Images/PEID.gif" alt="" /></h6>
 
<p> UPX (the Ultimate Packer for eXecutables) est un compresseur qui utilise la technologie NRV (Not Really Vanished). Je n'entre pas dans le détail et je considère pour la suite que vous avez unpacké la cible que vous pouvez toujours récupérer <a href="melounpacked.exe">ICI</a>.</p>
<h2> 2.2. Supprimer l'obfuscation de code</h2>
<p> Une autre protection a été ajoutée à ce binaire. Si on trace quelques lignes de code avec un débuggueur, on constate que l'affichage se comporte de façon bien étrange : en effet, entre chaque instruction à exécuter, il y a un saut inconditionnel (jmp). Ceci à pour effet de morceler complètement le programme et le tracing devient nettement plus pénible. Le désassemblage ne peut également pas se faire correctement <strong>a priori </strong> et l'analyse est donc fortement perturbée. Regardez par vous même ce que ça donne :</p>
<h6><img src="Images/Appolinaire.gif" alt="" /></h6>
<p> A cela s'ajoute un autre problème . Il semble que l'auteur du meloquynthe a également attaqué les sauts conditionnels de la forme "je". En effet, chaque saut de ce type est suivi de son homologue négatif "jne" alors que la logique classique voudrait que suive la routine à exécuter si le "je" n'est pas vérifié. Ces "jne" sont donc en trop et sont là clairement pour nous ennuyer un peu plus.</p>
<p> Il serait souhaitable de coder un outil pour remettre de l'ordre dans le code. On peut imaginer un script IDA ou OllyDbg qui fera le ménage à notre place en filtrant les instructions durant l'exécution et qui loguera le résultat. Voici par exemple un petit script très rudimentaire pour le plugin <strong>ODbgScript 1.46 de Epsylon3</strong> :</p>
<pre>
// AntiYol.txt - script par BeatriX
// ------------ Déclare un dword
var x	
<strong class="jaune">Scan:</strong>
// ------------ Récupère 4 bytes situés à eip
MOV x, [eip] 
// ------------ Récupère le premier byte, si c'est un JUMP, on ne loggue pas
AND x, FF  
cmp x, E9  
JNE LOGGUER
// ------------ F8 (tracing)
STO   
jmp Scan
<strong class="jaune">LOGGUER:</strong>
// ------------ Récupère le mnémonic situé en eip et le logguer
OPCODE eip	
log $RESULT_1,""  
STO	
JMP Scan
</pre>
<p> Ce script permet de logguer (dans la fenêtre des logs) les instructions qui ne sont pas des JUMP. Ce n'est pas totalement satisfaisant mais ça permet, si c'est utilisé sur de bonnes adresses d'éviter de transpirer trop longtemps...</p>
<p> On peut également réaliser un outil un peu plus sophistiqué de type désassembleur autonome.J'ai donc codé pour l'occasion mon <strong>DeObfuscator</strong> spécial meloquynthe qui va donc se charger de désassembler le code en omettant d'afficher les jumps tout en suivant ces sauts pour suivre le déroulement du programme. Il va également se débarrasser des "jne" en trop. Il va même un peu plus loin puisqu'il va traiter tous les couples Jcc/Jncc ou Jncc/Jcc et va systématiquement supprimer le second saut. Ce petit programme utilise mon moteur de désassemblage <strong>BeaEngine 2.1</strong> et est disponible <a href="deobfuscator.rar">ICI</a>. Voyez plutôt ce que ça donne sur l'Entry Point :</p>
<h6><img src="Images/DeObfuscator.gif" alt="" /></h6>
<p> Les symbols n'étant pas reconnus, il faut les retrouver à l'aide de OllyDebugger par exemple. Cependant, grâce à cet outil, on voit clairement le code sans aucune difficulté.</p>
<p> On peut aussi ne pas s'encombrer de ce genre de subtilités et faire confiance à sa touche préférée surpuissante :</p>
<h6><img src="Images/F7.gif" alt="" /></h6>
<p> C'est fou ce que cette touche fait des miracles sous OllyDebugger...après quelques minutes de tracing, on s'habitue à ce genre d'obfuscation et finalement, à l'aide d'un papier et d'un bon crayon, on parvient à analyser tranquillement ce binaire.</p>
<h2>2.2. Analyser les fonctions importées.</h2>
<p>Après avoir fait un peu de ménage, on commence à zieuter les fonctions windows utilisées par le binaire. Il arrive dans des cas sympathiques que toutes les fonctions utilisées soient stockées dans le <strong> hint/name array</strong>. Avec OllyDebugger ou un éditeur de PE, on peut obtenir de précieuses informations.Par exemple, utilisons <strong>CFF Explorer de Ntoskrnl</strong> : </p>
<h6><img src="Images/CFF.gif" alt="" /></h6>
<p> On peut ainsi classer les fonctions en différentes catégories. On remarque aussi certaines fonctions spécifiques qui mériteront d'être observées en milieu naturel. Voici les pistes à suivre :</p>
                                

<p>********************************** THREADS</p>
<pre>
kernel32.CreateEventA 
<strong class="jaune">kernel32.CreateThread </strong> <--------- Il faut étudier ceci
kernel32.DeleteCriticalSection
kernel32.EnterCriticalSection
kernel32.InitializeCriticalSection
kernel32.ExitThread
kernel32.LeaveCriticalSection
kernel32.SetEvent
<strong>kernel32.WaitForSingleObject </strong> <--------- Il faut surveiller ceci
</pre>

<p>********************************** GESTION DE FENETRE</p>
<pre>
user32.CreateWindowExA
<strong class="jaune">user32.RegisterClassExA</strong> <-------------- A étudier également
</pre>

<p>********************************** GESTION DE LA MUSIQUE</p>
<pre>
winmm.waveOutClose
winmm.waveOutGetPosition
winmm.waveOutOpen
winmm.waveOutPrepareHeader
winmm.waveOutReset
winmm.waveOutUnprepareHeader
winmm.waveOutWrite
</pre>
<p> Il devient impératif de se documenter sur l'usage de ces fonctions. On ne fait que très rarement du reversing pur à partir du code. Il faut absolument s'aider de docs déjà existantes. J'utilise donc le MSDN, les articles de ICZELION pour y voir plus clair sur l'usage des threads et des fonctions WaveOut.</p>
<h2>2.3. Le multi-threading</h2>
<p> Utilisons pour commencer <b>Process Explorer</b> de Mark Russinovitch, un outil de Microsoft Sysinternals. Voici ce que l'on obtient :</p>
<h6><img src="Images/processexplorer.gif" alt="" /></h6>
<p> On voit donc 8 threads en fonctionnement. On remarque que 2 threads MixerCallbackThread et waveThread sont utilisés par le driver wdmaud.drv responsable de la gestion du son. Pour les autres, nous obtenons les offsets <strong>0x5BFE14, 0X5BFF04, 0X5BFE39, 0x7A3DEC, 0x81C0CA et 0x8C4130</strong>. Nous allons être obligés d'analyser chaque thread en statique pour comprendre l'esprit du crackme.</p>

<h2>2.3. Analyser les contrôles</h2>
<p> Nous sommes ici en présence d'une fenêtre dite "skinnée", c'est-à-dire que son apparence réelle est modifiée. Nous n'y voyons pas l'agencement réel de ses contrôles. Il est toujours bon de connaître un maximum d'éléments pour pouvoir éviter une analyse trop longue par méconnaissance des éléments constitutifs du binaire. On utilisant un outil comme <strong> Win X de Holyview</strong>, il est aisé de dénombrer les contrôles voire même de les faire apparaître clairement en modifiant <strong>dwStyle et dwExStyle</strong> comme le montre le screenshot suivant :</p>
<h6><img src="Images/controles.gif" alt="" /></h6>
<p> Nous voyons donc clairement 14 contrôles que l'on peut classer en 4 catégories :</p>
<ul>
<li> Catégorie 1 : (mauve) Les boutons clignotants</li>
<li> Catégorie 2 : Le contrôle rouge qui affiche du texte dans le petit écran.</li>
<li> Catégorie 3 : (vert) Les scintillements dans la tentacule.</li>
<li> Catégorie 4 : 5 boutons (grisés) qui réagissent aux clics de la souris.</li>
</ul>
<p>On peut aussi essayer de récupérer les IDs des boutons. Pour cela, il suffit de poser un BP sur <strong>CreateWindowExA</strong> et de récupérer la valeur du paramètres <strong>hMenu</strong> : 
<h6><img src="Images/createwindow.gif" alt="" /></h6>
<p> De cette manière, on obtient les IDs des 5 boutons : <strong>1FB, 1FC, 1FD, 1FE, 1FF.</strong></p>
<h6><img src="Images/ID.gif" alt="" /></h6>


<p> A partir de là, on passe à l'analyse du code. A cause du multi-threading, nous sommes obligé de faire une étude statique...</p>
<p class="griser"> Copyright (C)- FRET (2006)</p>


<div class="page_suivante">
<a href="waveout.html"><img class ="noborder" src = "Images/hand.gif" alt="Page suivante" title="Page suivante" /></a>
</div>

<p class="w3c">
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p>

<p class="w3c">
 <a href="http://jigsaw.w3.org/css-validator/">
  <img style="border:0;width:88px;height:31px"
       src="http://jigsaw.w3.org/css-validator/images/vcss" 
       alt="Valid CSS!" />
 </a>
</p>

</div>
</div>
</body>
</html>