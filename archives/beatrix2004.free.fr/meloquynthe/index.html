<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="fr">
<head>
<title>Meloquynthe - solution par BeatriX</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" href="style.css" type="text/css" media="screen" />
<link rel="stylesheet" type="text/css" media="print" href="style_print.css"  />

</head>

<body>
<div id="fenetre">
<div class="titre"></div>

<div class="menu">
<ul>
<li><a href='index.html'>Introduction</a></li>
<li><a href='approche.html'>Approche</a></li>
<li><a href='waveout.html'>waveOut</a></li>
<li><a href='analyse.html' >Analyse</a></li>
<li><a href='greetz.html'>Greetz</a></li>
</ul>

</div>

<div class="contenu">
<p class="droite">Date de publication : 8 mai 2007 15h15</p>
<p class="droite">Auteur : BeatriX</p>
<div class="ligne"></div>

<h1>1.Introduction</h1>
<p> Nous allons aujourd'hui nous intéresser au binaire <a href="meloquynthe.exe">Meloquynthe.exe</a>. Il s'agit d'un petit défi réalisé par ++Meat (de chez NAS) et YoleJedi (de chez LABO) et proposé sur les forums de ForumCrack et de la FRET. Cette article n'était pas censé sortir un jour mais à la demande de Guetta, j'ai repris le travail que j'avais laissé en suspend. J'ai finalement repris le goût pour l'analyse de ce défi et ceci m'a permis de tester un outil de "désobfuscation" maison qui utilise ma lib de désassemblage BeaEngine 2.1. Je vais donc vous proposer ici une analyse à peu près complète de ce keygenme mais je  vais surtout mettre en lumière la partie "protection" de ce programme. </p>


<div class="important">

<p> Voici, dans le désordre, les différents points forts de ce défi :</p>
<ul>
<li> Utilisation du multi-threading : ce keygenme ne compte pas moins de 8 threads durant l'exécution !</li>
<li> Utilisation des WaveOut : La musique est gérée par ce jeu de fonctions windows pour lire le format WAV.</li>
<li> Obfuscation du code : un moteur a été utilisé pour rendre la lecture du code plus difficile.</li>
</ul>
</div>
<h2> 1.1 Première approche</h2>
<p> Ce keygenme peut être considéré comme un petit digicode composé d'un clavier de 5 touches. Au démarrage du binaire, Une combinaison secrète de ces 5 touches ( avec possibilités de répétitions) est générée de façon aléatoire. Il s'agit donc, comme pour entrer dans un hall d'immeuble, de composer le code secret dans le bon ordre.</p>
<p class="bouton"> Néanmoins, il ne s'agit pas ici d'un digicode classique. Si la séquence entrée par l'utilisateur est erronée, la combinaison secrète est changée immédiatement (toujours de façon aléatoire).</p>
<p> A ceci s'ajoute une petite contrainte : chacune des 5 touches du digicode ne peut être activée qu'à des instants bien précis au risque de générer une nouvelle combinaison secrète. Les instants sont identifiables à la bande sonore qui se joue en tâche de fond. Si vous tendez l'oreille, vous pouvez entendre 5 paroles distincts : <strong>Meat - Yo - F7 - Tendinite et Crackme</strong> qui sont produites les unes derrière les autres dans un ordre complètement aléatoire. </p>
<p>Chaque touche du digicode réagit exclusivement à l'une parole citées ci-dessus. Le petit schéma ci-dessous résume la correspondance touche - parole :</p>
<h6>  <img src="Images/Bitmap.gif" alt="" /></h6>


<p class="bouton"> Pour finir et pour pimenter le tout, si la combinaison secrète n'est pas en cours de validation par l'utilisateur, elle peut changer au fil du temps de façon imprévisible.</p>
<div class="important">
<p> Le keygen qui sera codé doit donc être capable de: </p>
<ul>
<li> récupérer la combinaison secrète</li>
<li> détecter tout changement de combinaison en cas de saisie erronée.</li>
<li> détecter tout changement de combinaison aléatoire dans le temps</li>
</ul>
</div>

<h2> 1.2. Un peu plus en profondeur...</h2>
<p> Maintenant que nous avons le comportement général du keygenme, nous pouvons organiser l'analyse en essayant de détailler chacun des points évoqués. Nous allons en particulier répondre aux questions suivantes :</p>

<p><strong> 1. Comment meloquynthe gère-t-il la saisie des touches ? </strong></p>
<p> Il ne s'agit ni plus ni moins que d'une simple WinProc qui reçoit les messages WM_COMMAND.</p>



<p><strong> 2. Comment meloquynthe gère-t-il le contrôle de la validité de la combinaison saisie ? </strong></p>
<p> Là encore, c'est la WinProc qui s'en charge. L'algorithme de vérification (assez optimisé) ne sera pas abordé. Je ne présenterai que son fonctionnement dans les grandes lignes.</p>


<p><strong> 3. Comment meloquynthe gère-t-il la génération de la combinaison secrète aléatoire ?</strong></p>
<p> Nous verrons que meloquynthe crée un thread spécial pour cette tâche et que l'algorithme de génération n'est pas si trivial que ça.</p>

<p><strong> 4. Comment meloquynthe gère-t-il la bande sonore et la correspondance touche - paroles ? </strong></p>
<p> Il s'adresse à la carte son à l'aide des fonctions WaveOut. Nous verrons qu'il utilise un thread pour choisir les morceaux à jouer et que la vérification de la correspondance touche-paroles se fait dans la WinProc.</p>

<p><strong> 5. Quel algorithme adopter pour le keygen ? </strong></p>
<p> Nous verrons que le keygen peut récupérer les informations nécessaires par un simple ReadProcessMemory sur 4 bytes.</p>

<p class="griser"> Copyright (C)- FRET (2007)</p>

<div class="page_suivante">
<a href="approche.html"><img class ="noborder" src = "Images/hand.gif" alt="Page suivante" title="Page suivante" /></a>
</div>

<p class="w3c">
    <a href="http://validator.w3.org/check?uri=referer"><img
        src="http://www.w3.org/Icons/valid-xhtml10"
        alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a>
</p>

<p class="w3c">
 <a href="http://jigsaw.w3.org/css-validator/">
  <img style="border:0;width:88px;height:31px"
       src="http://jigsaw.w3.org/css-validator/images/vcss" 
       alt="Valid CSS!" />
 </a>
</p>

</div>
</div>
</body>
</html>