<html>
<!- Notepad is  the best fucking html editor !!!  !->
<!- wtf ? !->

<head><title>The Millenium Cracking Tutorial (c) ACiD BuRN / ID'99</title></head>

<BODY bgcolor="#C0C0C0" text="#000000" link="#008000" vlink="#800080" alink="#FF0000">
<IMG SRC="mill.jpg">
<br>
<hr>
<u>Au programme:</u><br>
<blockquote>
<a href="millenium.html#intro">Introduction</a><br>
  <a href="millenium.html#essay">Les Bases minimales requises (sauts conditionnels, nop, call 
  ...)</a><br>
  <a href="millenium.html#wdasm">Introduction &agrave; W32Dasm8x</a><br>
  <a href="millenium.html#patch">Patcher les protections avec Registrations (serial, name / 
  serials)</a><br>
  <a href="millenium.html#sice">Introduction &agrave; Soft-ice (configuration et commandes de 
  base)</a><br>
  <a href="millenium.html#serial">Trouver des serials valides pour vos noms avec Soft-ice</a><br>
  <a href="millenium.html#keygen">Comment keygener pas mal de programmes (utilisation des BPR...)</a><br>
<a href="millenium.html#ownkey">Transformer un Programme en son propre keygen</a><br>
<a href="millenium.html#time">Time Limits (limitation de 30 jours et autres merdes !!)</a><br>
  <a href="millenium.html#nag">Nag et autres Splash screen (diverse m&eacute;thodes...)</a><br>
  <a href="millenium.html#keyfile">Keyfile</a><br>
  <a href="millenium.html#cdcheck">CD Check (les BPX, et techniques diverses..)</a><br>
  <a href="millenium.html#vb">Visual Basic (keygener, serialiser, patcher, tout sur le VB !!)</a><br>
  <a href="millenium.html#java">JAVA Reverse Engineering</a><br>
  <a href="millenium.html#unpacking">Manual Unpacking (comment unpacker, les tools, m&eacute;thodes...)</a><br>
  <a href="millenium.html#checksum">Checksum (comment les contourner)</a><br>
  <a href="millenium.html#antisice">Anti Soft-ice</a><br>
<a href="millenium.html#divers">Divers</a><br>
<a href="millenium.html#greetings">Greetings</a><br>
  <a href="millenium.html#end">Conclusion</a><br>

</Blockquote><br><br>
<hr>
<br>
<!- ***************************************************************************** -!> 
<font size="+2"><a name="intro"></a><b><u>Introduction :</u></B></font><br>
<br>
<pre>Ben, voil&agrave; je me suis dit il y a quelques jours, pourquoi ne pas &eacute;crire 
un cours englobant tous les types de protections les plus courantes
et comment les mettre en &eacute;chec!!
Cette fois-ci, c'est donc bien un cours global de cracking et en 
fran&ccedil;ais en plus !!
Vous l'avez s&ucirc;rement remarqu&eacute;, la taille de ce cours est assez
grande !! Plusieurs dizaines de Ko! Je vous conseille donc de lire &ccedil;&agrave;
au calme et avec attention !!
Je pr&eacute;viens de suite !! pour les personnes ayant l'habitude de faire
des remarques mal plac&eacute;es ! Ce n'est pas la peine de critiquer ce 
cours !! Mais si vous avez plut&ocirc;t des suggestions, je suis dispos&eacute;
&agrave; &eacute;couter...
Ce cours a &eacute;t&eacute; &eacute;crit alors que j'&eacute;tais tr&egrave;s malade, il se peut qu'il y ait
quelques "&acirc;neries", je serais content si vous pouviez m'en faire part!
Merci et sur ce, bonne lecture.

							[ ACiD BuRN ]

</pre>
<br>
<hr>
<br>
<!- ***************************************************************************** -!> 
<font size="+2"><a name="essay"><b><u>ESSAY :</u></B></a></font><br>
<br>
<pre>


*************************************************************************
**  Les Bases minimales requises (sauts conditionnels, nop, call ...)  **
*************************************************************************


Pour pouvoir cracker, vous devez avoir des bases en assembleur!!
Je vais ici vous &eacute;num&eacute;rer les choses &agrave; savoir au d&eacute;part,
diff&eacute;rentes instructions, ce qu'elles veulent dire ..
Si vous &ecirc;tes d&eacute;j&agrave; habitu&eacute; au cracking, vous pouvez passer &agrave; la suite
sans probl&egrave;me je pense, &agrave; part si vous avez de grosses lacunes!


L'assembleur est le langage qui se rapproche le plus de celui du PC,
ou plut&ocirc;t que le Microprocesseur puisse comprendre:
"le langage machine."
L'asm est donc le langage de programmation de plus bas niveau qui
existe.
Ce langage retrouve sa place dans tous les programmes car il ne
faut pas oublier que n'importe quel programme, &eacute;crit dans 
n'importe quel langage est finalement traduit en langage machine
pour &ecirc;tre ex&eacute;cut&eacute;...
Si on d&eacute;sassemble n'importe quel programme, on retrouve un listing
en ASM, d'o&ugrave; l'utilit&eacute; de conna&icirc;tre l'assembleur.
Passons &agrave; l'&eacute;tude des instructions (Tr&egrave;s basique) afin d'&eacute;claircir
les probl&egrave;mes.


* CALL: l'instruction CALL permet d'appeler une sous-routine.

       ex: Call 00405741   <-- ceci appelle la routine qui se trouve en 
                               00405741.

* CMP: compare. Cette instruction soustrait l'op&eacute;rande source à l'op&eacute;rande
       de destination.

       ex: CMP EAX, EDX  <--- soustrait EAX &agrave; EDX = EDX - EAX

       Les CMP sont g&eacute;n&eacute;ralement accompagn&eacute;s de sauts conditionnels, nous les 
       verrons tr&egrave;s bient&ocirc;t...

* JMP: (JUMP) elle effectue un saut inconditionnel &agrave; une autre partie
       du programme

       ex: JMP 0040458   <--- saute &agrave; 0040458

* NOP: (no operation): cette instruction n'est pas comme les autres.
       Elle ne fait tout simplement RIEN!!
       Vous verrez par la suite son int&eacute;r&ecirc;t !
       
* RET: (return): instruction qui permet de revenir au programme appelant
       quand une sous-routine est termin&eacute;e! (tr&egrave;s utile certaines fois)

* ADD: elle r&eacute;alise une addition entre les 2 op&eacute;randes et place le 
       r&eacute;sultat dans l'op&eacute;rande destination.

       ex: ADD EAX, FFh    -->  EAX = EAX + FFh

* SUB: c'est pour effectuer une soustraction entre 2 op&eacute;randes...

       ex: SUB EAX, EDX    -->  EAX = EAX - EDX

       Il y a aussi les DIV, MUL (je vous fait pas de dessin, je pense que
       devinez ce que &ccedil;a fait !!

* Les saut conditionnels:

       Vous rencontrez beaucoup de tests, comparaison, pendant le cracking.
       Ainsi pour traiter les r&eacute;sultats de ceux-ci, il existe une multitude
       de sauts conditionnels, je vais vous en citer quelques-uns:

       JNE (jump if not equal) = jump if not equal to zero (JNZ sous Soft-ice)
       JE  (jump if equal)     = jump if equal to zero (JZ sous Soft-ice)
       JG  (jump if greater)   = jump si c'est sup&eacute;rieur
       JGE (jump if greater or equal) = jump si c'est sup&eacute;rieur ou &eacute;gal
       JL  (jump if less)      = jump si c'est inf&eacute;rieur
       JLE (jump if less or equal) = jump si c'est inf&eacute;rieur ou &eacute;gal 
       JA  (jump if Above)
       JNA (jump if not above)
       ......
       je vous conseille de lire une documentation sur l'asm si vous voulez
       plus d'infos sur les types de saut ! Il en existe encore...

* MOV: l'instruction mov sert &agrave; placer une valeur dans un registre.

       ex: MOV EAX, 56h  --->  met 56h (86 en d&eacute;cimal) dans le 
                               registre EAX.


* XOR: c'est un ou exclusif! Tr&egrave;s utilis&eacute; dans les routines de cryptage
       ou de g&eacute;n&eacute;ration de serials!
       Voici la table de fonctionnement du XOR:

       0	XOR	0	=	0
       0	XOR	1	=	1
       1	XOR	0	=	1
       1	XOR	1	=	0	
         
       Le xor est utilis&eacute; pour remettre un registre &agrave; 0.
       En effet quand on xor 2 m&ecirc;mes valeurs, le r&eacute;sultat est toujours 0.

       ex: XOR EAX, EAX   ---> EAX = 0


* PUSH: l'instruction push permet de placer une donn&eacute;e sur la pile.
        Elle peut venir d'un registre ou d'un emplacement m&eacute;moire!

        ex: PUSH EAX    ---> pousse la valeur de EAX sur la pile

* POP:  l'instruction pop permet de r&eacute;cup&eacute;rer une donnée posée sur la
        la pile.
        Elle peut &ecirc;tre plac&eacute;e dans un registre ou dans un emplacement
        m&eacute;moire!

        ex: POP EAX    ---> r&eacute;cup&egrave;re la valeur de EAX sur la pile



	Voil&agrave;, &ccedil;a sera tout pour les bases en ASM!! 
	Ces quelques descriptions ont, je l'esp&egrave;re, mis au clair
	les qq probl&egrave;mes pouvant &ecirc;tre rencontr&eacute;s du &agrave; l'incompr&eacute;hension
	de certaines instructions!!
	Mais il serait pr&eacute;f&eacute;rable pour vous d'avoir un livre d'asm
	pr&egrave;s de vous, cela vous permettrais de chercher la description
	des instructions qui vous posent probl&egrave;me !
	(exemple de livre: ASSEMBLEUR PRATIQUE, &eacute;ditions Marabout)


</pre>
<font size="+2"><a name="wdasm"><b><u>Introduction &agrave; W32Dasm8x:</u></B></a></font><br>
<br>
<pre>

Tout d'abord, je vais vous expliquer ce qu'est W32Dasm, &agrave; quoi il sert
et quelles sont ses principales options!

W32Dasm est un d&eacute;sassembleur! Il permet de d&eacute;sassembler n'importe quel
fichier de type EXE, DLL, OCX ... pour obtenir son &eacute;quivalent
en asm!
A quoi bon ? hehe ce genre de programme vous permettra de cracker
qq jeux, de s'enregistrer dans vos programmes et encore des tas d'autres
choses !!!

Utilisation:

Apr&egrave;s avoir d&eacute;zipp&eacute; W32Dasm dans un r&eacute;pertoire, il vous faudra configurer
la fonte car celle qui est par d&eacute;faut n'est pas lisible, lol :)
Car quand vous allez l'utiliser pour la premi&egrave;re fois, vous verrez des signes
tout &agrave; fait bizarres et qui ne veulent rien dire !!
Normal ! La fonte par d&eacute;faut est : widings ou qq chose comme &ccedil;a.
Changez la en : Times new roman par exemple, et vous pourrez enfin comprendre
ce que W32Dasm vous montrera apr&egrave;s avoir d&eacute;sassembl&eacute; !

Changement de fonte: lancez W32Dasm, dans le menu d&eacute;sassembler choisissez Font.
et ensuite select Font! et l&agrave; vous pouvez faire votre choix!!!

Les diff&eacute;rents menus:

Dans Disassembler:  Open file to disassemble
C'est avec ce menu que vous choisissez le fichier &agrave; d&eacute;sassembler!
Ouvrez le fichier Calc.exe pr&eacute;sent dans le r&eacute;pertoire de Windows pour essayer
par exemple!

Apr&egrave;s avoir d&eacute;sassembl&eacute;, vous pouvez sauvegarder ce fichier pour pouvoir
le réouvrir ult&eacute;rieurement !! (d&eacute;sassembler de gros fichiers peut &ecirc;tre parfois
TRES long !! d'o&ugrave; l'int&eacute;r&ecirc;t de sauver le fichier !)
Pour cela, allez dans le menu "Save disassembly Text files.." de Disassembler.

Juste &agrave; c&ocirc;t&eacute; de ce menu vous pouvez voir "Project"!
Ceci sert &agrave; ouvrir les fichiers sauvegard&eacute;s pr&eacute;c&eacute;demment !

Je ne vais pas m'attarder sur la description de W32Dasm, car il est fourni
avec une aide super !!! d&eacute;crivant avec pr&eacute;cision les diff&eacute;rentes commandes!

Pour finir cette br&egrave;ve description des menus, je vais vous d&eacute;crire le menu
Refs!
Alors celui-l&agrave; !! c'est le menu le plus utilis&eacute; dans W32Dasm !!
Apr&egrave;s avoir click&eacute; dessus, vous devez apercevoir 3 sous-menus,
je ne vous parlerai pour l'instant que de:
String Data References!

Kesako &ccedil;&agrave; ? C'est en fait une liste de tout les messages rencontr&eacute;s dans le
programme disassembler!
Il vous servira notamment pour les jeux avec des messages du genre:
"Please insert your CD" ou encore les autres names / serials:
"the serial you entered is not Valid!" ....
L'utilisation sera d&eacute;taill&eacute;e dans la suite de ce cours !

Quelques astuces en vrac:

Pour copier-coller dans W32Dasm, il suffit de clicker sur le d&eacute;but de la ligne
&agrave; copier (un point rouge doit appara&icirc;tre) et ensuite appuyez sur la touche
Shift. Maintenant allez sur la derni&egrave;re ligne &agrave; copier, et vous verrez que
toutes les lignes entre les 2 points que vous avez s&eacute;lectionn&eacute;s contiennent
des points rouges !!
Cela signifie que vous pouvez maintenant copier-coller le texte qui est 
s&eacute;lectionn&eacute;!
Ctrl+C = copie le texte
Ctrl+V = colle le texte

L'int&eacute;r&ecirc;t de ceci est que vous pouvez d&eacute;couper des bouts de codes et 
les introduire dans vos tuts, ou Keygens :))

</pre>
<font size="+2"><a name="patch"><b><u>Patcher les protections avec Registrations</u></B></a></font><br><br>
<pre>

Nous allons voir ici l'utilisation de W32Dasm pour patcher les protections
par serials !!

Th&eacute;orie:

Dans de nombreux sharewares, vous rencontrez des protections par name / serials
et les programmes souvent pas tr&egrave;s malin vous mettent un msg disant que le 
serial entre n'est pas bon !! qd vous avez rentr&eacute; une connerie!
Appelons X le programme prot&eacute;g&eacute; par name serial.
Lancez X, et allez l&agrave; o&ugrave; vous pouvez entrer un nom et un code d'enregistrement.
Entrez votre nom et un serial &agrave; la con style: 112233 et clickez sur le bouton
permettant de v&eacute;rifier le serial style "OK" et vous verrez le message &agrave; la con
vous disant: "le serial que vous avez entr&eacute; n'est pas valide"
Hehehehe, d&eacute;j&agrave; si vous voyez &ccedil;&agrave; vous pouvez vous dire que c'est bien parti !
Alors ouvrez W32Dasm et s&eacute;lectionnez le fichier ex&eacute;cutable du programme &agrave; cracker
comme je vous ai montr&eacute; dans la partie d'avant !!
Maintenant allez jeter un oeuil dans les String Data References et vous n'avez
plus qu'&agrave; chercher le message d'erreur rencontr&eacute; lors du mauvais serial !!
Sans tarder vous le trouvez dans la liste des messages !!
Double-cliquez dessus et vous atterrissez &agrave; l'endroit dans le programme o&ugrave;
s'effectue le test.

Vous tomberez Tr&egrave;s souvent sur qq chose comme &ccedil;&agrave;:


:01001777 FF151C110001         Call 0100111C
:0100177D 85C0                 test eax, eax
:0100177F 7512                 jne 01001793
:01001781 8D856CFFFFFF         lea eax, dword ptr [ebp+FFFFFF6C]

* Possible StringData Ref from Code Obj ->"le serial que vous avez entr&eacute;.."


Ici on voit tr&egrave;s bien le message d'erreur du programme !!
Si on regarde juste au dessus, on voit un Test, et un JNE!
Regardez dans la liste des fonctions asm que je vous ai donn&eacute; au d&eacute;but
si vous avez oubli&eacute; la fonction de jne...
Que fait donc ce code ?
Si le code n'est pas &eacute;gal au bon code : TEXT EAX, EAX n'est pas &eacute;gal
&agrave; 0 et donc le jne (jump if not equal) saute vers le message d'erreur!
Donc comment cracker &ccedil;a ?
Facile, nous devons avoir EAX = 0 pour que le serial soit pris comme valide
donc la fa&ccedil;on la plus propre est de forcer EAX &agrave; 0!
L'instruction qui met &agrave; 0 un registre est XOR.
XOR EAX, EAX = 0  (si vous ne comprenez pas pourquoi, allez voir au d&eacute;but du
cours dans les bases en ASM).
Le code modifi&eacute; ressemble &agrave; ceci :


:01001777 FF151C110001         Call 0100111C
:0100177D 33C0                 xor eax, eax
:0100177F 7512                 jne 01001793
:01001781 8D856CFFFFFF         lea eax, dword ptr [ebp+FFFFFF6C]

* Possible StringData Ref from Code Obj ->"le serial que vous avez entr&eacute;.."


La ligne:

:0100177D 85C0                 test eax, eax

est devenue:

:0100177D 33C0                 xor eax, eax

Voil&agrave; !! EAX = 0 pour toujours donc le programme ne sautera plus jamais
avec le jne et le programme vous mettra le message comme quoi vous 
avez entr&eacute; un bon serial !!
"Merci de Votre support, vous &ecirc;tes maintenant enregistr&eacute; BLABLABLA "

:-) Coool tout &ccedil;a !! Mais vous vous demandez s&ucirc;rement comment j'ai su que
le 85C0 deviendrait 33C0 et comment on peut changer &ccedil;a dans le programme ?
hehe, &ccedil;a vient !!
Pour savoir &agrave; quoi ressemble le code en hexa d'une instruction vous pouvez
utiliser l'option de l'&eacute;diteur hexa Hacker view, mais bon j'aime pas cet
&eacute;diteur!! je connais ces valeurs par coeur. Donc essayez de vous en rappeler.
Pour effectuer ces modifications dans le programme, il faut utiliser un
&eacute;diteur hexad&eacute;cimal. J'utilise HexWorkshop car c'est &agrave; mon avis le meilleur!
Donc lancez l'&eacute;diteur hexa, et ouvrez votre fichier &agrave; patcher avec...
Faites une recherche des octets &agrave; patcher et remplacez par les nouvelles 
valeurs. Exemple dans ce cas: recherchez: 85C075128D856CFF
Vous devez trouver un seul endroit correspondant &agrave; ces octets sinon
faites une recherche avec plus d'octets!!
Une fois que vous avez trouvé, remplacez par: 33C075128D856CFF
sauvegardez le fichier et c'est pr&ecirc;t!!

NOTE: si vous avez ouvert le fichier et qu'il est toujours ouvert par
W32Dasm, vous ne pourez l'enregistrer car le fichier sera d&eacute;j&agrave; en lecture
donc vous serez en lecture seule!!
Petite astuce pour ne pas &ecirc;tre emmerd&eacute; :
Avant de d&eacute;sassembler votre ex&eacute;cutable, faites-en une copie et renommez
l'extension en .AB par exemple! D&eacute;sassemblez le fichier avec l'extension .ab
et une fois que vous savez o&ugrave; il faut patcher, vous ouvrez la copie
du fichier qui a toujours l'extension .exe avec HexWorkshop!
Vous pourrez modifier l'exe et sauvegarder, tout en vous servant de W32Dasm!

Donc voil&agrave;, vous avez sauvegard&eacute; le fichier ! Relancez l'ex&eacute;cutable modifi&eacute;
et vous entrez un nom / serial bidon, et clickez sur le bouton pour v&eacute;rifier
le serial! Miracle le message : "Merci de votre support" ou autres conneries 
du genre appara&icirc;t !! Vous venez de cracker votre premier name / serial.
Mais attention, il se peut que quand vous relanciez le programme, il ne 
soit plus enregistré :((  pourquoi ??
Ben tout simplement car il y a un autre contr&ocirc;le du serial dans la base
de registre ou m&ecirc;me dans un fichier .ini!!
L'encul&eacute; :) heheh il est souvent tr&egrave;s simple &agrave; patcher cela !
Dans les String Data References, si vous voyez une r&eacute;f&eacute;rence du genre:
"Licenced to:"  <-- il doit avoir des tests plus haut, ou des appels par
des call ou sauts conditionnels !!
Vous avez juste &agrave; modifier le programme pour qu'il saute en version
enregistr&eacute;e &agrave; tout les coups !! en rempla&ccedil;ant un JE en JMP
(en hexa: 74 --> EB)...

Pour en revenir &agrave; l'exemple de tout &agrave; l'heure on a modifi&eacute; le TEST
en XOR, mais on aurait tr&egrave;s bien pu nopper le saut conditionnel!!!
Explications:

:01001777 FF151C110001         Call 0100111C
:0100177D 85C0                 test eax, eax
:0100177F 7512                 jne 01001793
:01001781 8D856CFFFFFF         lea eax, dword ptr [ebp+FFFFFF6C]

* Possible StringData Ref from Code Obj ->"le serial que vous avez entr&eacute;.."


Le jne saute au mauvais message si le num&eacute;ro de s&eacute;rie n'est pas bon !!
Donc pourquoi ne pas l'emp&ecirc;cher de sauter tout simplement ??
Comment ? ben si vous avez jet&eacute; un oeuil au d&eacute;but du cours vous avez
s&ucirc;rement remarqu&eacute; l'instruction: NOP (no operation)!!!
Cette instruction ne fait rien du tout !! Chouette on va s'en servir
pour tuer le saut !!

Notre code devient donc:

 FF151C110001         Call 0100111C
 85C0                 test eax, eax
 90                   nop
 90	                  nop
 8D856CFFFFFF         lea eax, dword ptr [ebp+FFFFFF6C]


Et voil&agrave; !! plus de probl&egrave;mes non plus :)
Le code hexa pour nop = 90 !! ne pas oublier &ccedil;a !! Vous vous en servirez
toute votre vie (de cracker).

Modification dans l'ex&eacute;cutable comme tout &agrave; l'heure:
on cherche: 85C075128D856CFF et on remplace par: 85C090908D856CFF 
Sauvegardez et Enjoy!!!

Pratique:

Petit exemple illustrant ce que je viens de vous apprendre:


		Crack de WinRAR 2.05


On va patcher ce prog pour qu'il accepte n'importe quel num&eacute;ro de
s&eacute;rie. Nous allons voir comment faire quand un prog accepte le serial
mais d&egrave;s qu'on le relance, il nous dit version non enregistr&eacute;e !!
Et pour finir r&eacute;activer une fonction du prog accessible seulement en
version enregistr&eacute;e !!!

donc pour ce crack on a besoin de :

			- WinRAR 2.05
			- W32Dasm 8.9
			- &eacute;diteur hexa comme HexWorkshop




1) Analyse du prog !

On lance WinRAR et on voit dans la barre des t&acirc;ches : (evaluation Copy),
dans option, general, 2 functions d&eacute;sactiv&eacute;es (Log errors to file et put
authenticity verification). Et dans option : Registration.
On rentre notre nom et num&eacute;ro de s&eacute;rie, il nous dit: Registration failed.


2) Lets kick this fucking tool !

Donc on fait une copie de sauvegarde de WinRAR95.exe puis on le d&eacute;sassemble
avec W32Dasm, on va dans String Data References et on trouve :

 ....
 String Resource ID=00106: "Registration failed"
 String Resource ID=00107: "Thank you for support"
 ....

Dons on double click sur Registration Failed et on retourne dans W32Dasm,
on remonte un peu on voit &ccedil;&agrave;:


:00413c5f 7532                    jne 00413c93

* Possible StringData Ref from Code Obj ->"Normal"
                                  
:00413c61 6A30                    push 000000030

* Possible StringData Ref from Code Obj ->"Warning"   <-- Le message d'erreur!

:00413c63 6a1a                    push 0000001a
:00413c65 e8fe640000              call 0041a168
:00413c6a 59                      pop ecx

....
....


* Possible StringData Ref from Code Obj ->"Registration failed"
                                  
....
....

et l&agrave; on voit tout de suite le saut conditionnel : jne 00413c93
jne veut dire jump if not equal, donc le prog saute au message d'erreur quand le code
est mauvais !
On le remplace par je 00413c93 et hop ! Il ira sur le mauvais message quand on rentrera
un bon code !! Il peut tjs attendre !!!
Donc on remplace le 7532 par 7432 (note: j'aurais tr&egrave;s bien pu nopper mais
c'est pour vous montrer que les sauts sont renversables),
on sauvegarde et on relance le tout !!
On entre son nom, son code bidon, et il nous dit : Thank you for .... :)
Mais si on relance, le prog n'est plus enregistr&eacute; :(
On r&eacute;fl&eacute;chit et on voit dans la barre des titres:  (evaluation copy).
Tout &agrave; l'heure quand on a rentr&eacute; un code, ce message &eacute;tait parti.
Donc on cherche : '(evaluation copy'), dans les String Data References.
(bien prendre celle avec parenth&egrave;ses)

On trouve:

String Resource ID=00252: "(evaluation copy)"

on double click et on remonte un peu et on voit :


:00418d1e 833d5c57420000  cmp dword ptr [0042575c], 00000000 
                                                               
                                                               
:00418d25 752f            jne 0041d56       <=== Jump to BAD CRACKER !!! 


Encore un chtit saut conditionnel, on le remplace en je avec un 74 &agrave;
la place du 75 on sauvegarde, on relance et on est enregistr&eacute; ! :)
Mais, n'oublions pas de tester le proggy !! et on voit les 2 fonctions
d&eacute;sactiv&eacute;es cit&eacute;es plus haut. :(

Dans Menu\Options\general on coche une des deux cases, il nous dit :

"Available in registered version only" <=== va te faire petit !!! :)

On note le message et on le cherche dans W32Dasm, comme d'hab !
On trouve:


String Resource ID=00051: "Available in registered version only"

On double click et on voit :


:004138a9 833d5c57420000          cmp dword ptr [0042575C],00000000  
:004138B0 7534                    jne 004138e6     <===== jump to BAD CRACKER
                                                         
* Possible StringData Ref from Code Obj -> "Normal"     

:004138B2 6a30                    push 00000030         
                                                        
* Possible StringData Ref from Code Obj -> "Warning"   

:00413c63 6a1a                    push 0000001a        
:00413c65 e8fe640000              call 0041a168        
:00413c6a 59                      pop ecx              
:00413c6b 50                      push eax             


* Possible StringData Ref from Code Obj -> "Available in registered ..."

....
....


Encore un saut conditionnel vous avez compris je pense, on le remplace le jne 004138e6
par je 004138e6 !!
On enregistre et on relance WinRAR !!
On essaie de cocher les cases !! Bingo !!! CRACKED !! :)

// extrait de mon cour sur WinRAR 2.05 (j'ai patch&eacute; comme un cow-boy mais
// si je commence &agrave; retoucher tout j'ai pas encore fini !!


Bon ben voil&agrave; !! C'&eacute;tait un exemple concret de comment patcher un programme
pour qu'il accepte tous les serials &agrave; la con, et comment r&eacute;activer
des fonctions d&eacute;sactiv&eacute;es !
Il existe des programmes BEAUCOUP plus durs &agrave; patcher et aussi encore plus
simple que celui l&agrave; !!
Note: si jamais apr&egrave;s avoir d&eacute;sassembl&eacute; vous ne voyez aucune String
Data References, il y a de fortes chances que le programme soit pack&eacute;
(crypt&eacute; gr&acirc;ce &agrave; un packer!!), pour savoir comment d&eacute;crypter un ex&eacute;cutable
&agrave; la main (manual unpacking) lisez la suite du cours !! Ca arrive ;-)

Et pour finir voici une source d'un patch en Delphi que j'ai programm&eacute;
il y a d&eacute;j&agrave; un bon moment :)

//-------------------------- start of sources: unit1.pas ---------------------------------

unit Unit1;

interface

uses
  Windows, Messages, SysUtils, Classes, Graphics, Controls, Forms, Dialogs,
  StdCtrls, ExtCtrls, Menus, jpeg;

type
  TForm1 = class(TForm)
    Button1: TButton;
    OpenDialog1: TOpenDialog;
    Label2: TLabel;
    Button2: TButton;
    MainMenu1: TMainMenu;
    About1: TMenuItem;
    Image1: TImage;
    Image2: TImage;
    procedure Button1Click(Sender: TObject);
    procedure Button2Click(Sender: TObject);
  
   
  private
    { Private declarations }
  public
    { Public declarations }
  end;

var
  Form1: TForm1;

implementation

uses Unit2;

{$R *.DFM}

procedure TForm1.Button1Click(Sender: TObject);
Const A: Array[1..4] of Record                   // nombre de changements: 4 octets
                          A : Longint;
                          B : Byte;

                         End =

((A:$5C8A;B:$85),          // (A = offset et B = valeur que l'on met a la place ) en hexa
(A:$5C93;B:$85),
(A:$5C9B;B:$EB),
(A:$7CD8;B:$EB));


Var Ch:Char;
    I:Byte;
    F:File;
    
begin
  if OpenDialog1.Execute then                       { affiche une "Open dialog box" }
  begin
    AssignFile(F, OpenDialog1.FileName);
{$I-} Reset (F, 1); {$I+}
   If IOResult <> 0 then
    begin
MessageDlg('File write protected or used !!!', mterror,
 [mbcancel], 0);
    halt(1);
    end;
 If FileSize (F) <> 512000 Then Begin          // taille du fichier
 MessageDlg('Wrong File size !!!', mterror,
 [mbcancel], 0);
 halt(1);
 end else
 For I:=1 to 4 do {<---------------------- nombres de changement: 4}

 Begin
 Seek(F,A[I].A);
  Ch:=Char(A[I].B);
  Blockwrite(F,Ch,1);
  
 end;
MessageDlg('Mem Turbo is now Cracked , enjoy !!!', mtInformation,  
 [mbOk], 0);
closefile(f); 
 end;
 end;

procedure TForm1.Button2Click(Sender: TObject);
begin
close
end;

end.

//-----------------------Fin des sources: unit1.pas --------------------------------



</pre>
<font size="+2"><a name="Sice"><b><u>Introduction &agrave; Soft-ice</u></B></a></font><br>
<br>
<pre>

Alors l&agrave; on commence les choses plus s&eacute;rieuses !!
Voici Soft-ice le d&eacute;bugger de chez Numega !! C'est le d&eacute;bugger utilis&eacute; par
tout crackers digne de ce nom.
Gr&acirc;ce &agrave; ce programme, la seule chose qui vous limite vraiment c'est vous
et vos connaissances, on peut cracker des dongles (AutoCAD, 3DSMax),
trouver des serials, faire des keygens (tr&egrave;s utile pour tracer les routines
de registration) ...
Bref, je vais vous citer ici les diff&eacute;rentes commandes utiles et n&eacute;cessaires
pour pouvoir se d&eacute;merder ;)
Mais d'abord, je vais vous expliquer comment configurer ce petit programme :)
La configuration de Soft-ice se passe dans le fichier Winice.dat .


Donc &eacute;ditez votre fichier winice.dat avec Notepad par exemple, et voici
les choses &agrave; modifier:

PHYSMB=64   <--- mettez ici votre nombre de RAM (j'en ai que 64 !!)

Pour une meilleur lisibilit&eacute;, &agrave; la ligne ou vous voyez ceci INIT, mettez:

INIT="lines 60;ww;wl;wr;wd 24;wc 24;code on;x;"

Bien entendu, ce n'est pas obligatoire, mais c'est pour que vous soyez dans
les meilleures conditions possibles!!!
Ensuite &agrave; la ligne ou vous voyez "AF4" mettez ceci:

AF4="^s 0 l ffffffff 56,57,8b,7c,24,10,8b,74,24,0c,8b,4c,24,14,33,c0,f3,66,a7;"

Ca, c'est une technique utilisée dans le Visual Basic (pour trouver des serials :)

Bon maintenant, on commence la partie qui est la plus utile car si on ne modifie
pas &ccedil;a ! Niet le cracking :)


; ***** Examples of export symbols that can be included for Windows 95 *****
;	Change the path to the appropriate drive and directory
;EXP=c:\windows\system\kernel32.dll
;EXP=c:\windows\system\user32.dll
;EXP=c:\windows\system\gdi32.dll
;EXP=c:\windows\system\comdlg32.dll
;EXP=c:\windows\system\shell32.dll
;EXP=c:\windows\system\advapi32.dll
;EXP=c:\windows\system\shell232.dll
;EXP=c:\windows\system\comctl32.dll
;EXP=c:\windows\system\crtdll.dll
;EXP=c:\windows\system\version.dll
;EXP=c:\windows\system\netlib32.dll
;EXP=c:\windows\system\msshrui.dll
;EXP=c:\windows\system\msnet32.dll
;EXP=c:\windows\system\mspwl32.dll
;EXP=c:\windows\system\mpr.dll


Voil&agrave; !! Cherchez &ccedil;a! C'est pas bien loin dans le fichier, et vous avez
s&ucirc;rement remarqu&eacute; les ";" , les points virgules mettent en commentaires !
donc il faut les enlever sinon on ne pourra rien cracker car les bpx
sur les API Windows seront impossibles (si vous comprenez pas ce que je raconte ;p
ca fait rien vous comprendrez bien assez t&ocirc;t !!)

Donc modifiez &ccedil;a en:

; ***** Examples of export symbols that can be included for Windows 95 *****
;	Change the path to the appropriate drive and directory
EXP=c:\windows\system\kernel32.dll
EXP=c:\windows\system\user32.dll
EXP=c:\windows\system\gdi32.dll
EXP=c:\windows\system\comdlg32.dll
EXP=c:\windows\system\shell32.dll
EXP=c:\windows\system\advapi32.dll
EXP=c:\windows\system\Msvbvm50.dll
EXP=c:\windows\system\Msvbvm60.dll
EXP=c:\windows\system\shell232.dll
EXP=c:\windows\system\comctl32.dll
EXP=c:\windows\system\crtdll.dll
EXP=c:\windows\system\version.dll
EXP=c:\windows\system\netlib32.dll
EXP=c:\windows\system\msshrui.dll
EXP=c:\windows\system\msnet32.dll
EXP=c:\windows\system\mspwl32.dll
EXP=c:\windows\system\mpr.dll



Vous avez s&ucirc;rement remarqu&eacute; que j'ai ajout&eacute; 2 fichiers dll dans la liste
ci-dessus par rapport &agrave; avant:

EXP=c:\windows\system\Msvbvm50.dll
EXP=c:\windows\system\Msvbvm60.dll

Rajoutez-les !! On en a besoin si on veut cracker les programmes en Visual
Basic :-)

Pour ceux qui s'en branlent de ce que je raconte (il y en a toujours :/), voici
le winice.dat que j'utilise actuellement, qui n'a aucune pr&eacute;tention si ce n'est
de marcher ;p

;************ACiD BuRN's Winice.dat copier &agrave; partir d'ici************************

PENTIUM=ON
NMI=ON
ECHOKEYS=OFF
NOLEDS=OFF
NOPAGE=OFF
SIWVIDRANGE=ON
THREADP=ON
LOWERCASE=OFF
WDMEXPORTS=OFF
MONITOR=0

PHYSMB=64
SYM=1024
HST=256
TRA=8
MACROS=32
DRAWSIZE=2048

INIT="lines 60;ww;wl;wr;wd 24;wc 24;code on;x;"

F1="h;"
F2="^wr;"
F3="^src;"
F4="^rs;"
F5="^x;"
F6="^ec;"
F7="^here;"
F8="^t;"
F9="^bpx;"
F10="^p;"
F11="^G @SS:ESP;"
F12="^p ret;"
SF3="^format;"
CF8="^XT;"
CF9="TRACE OFF;"
CF10="^XP;"
CF11="SHOW B;"
CF12="TRACE B;"
AF1="^wr;"
AF2="^wd;"
AF3="^wc;"
AF4="^s 0 l ffffffff 56,57,8b,7c,24,10,8b,74,24,0c,8b,4c,24,14,33,c0,f3,66,a7;"
AF5="CLS;"
AF8="^XT R;"
AF11="^dd dataaddr->0;"
AF12="^dd dataaddr->4;"
CF1="altscr off; lines 60; wc 32; wd 8;"
CF2="^wr;^wd;^wc;"

; WINICE.DAT
; (SIW95\WINICE.DAT)
; for use with SoftICE Versions greater than 3.0 (Windows 95)
; 

; *************************************************************************
; If your have MORE than 32MB of physical memory installed, change
; the PHYSMB line to the correct # of Megabytes.
; If you have LESS than 32MB you can save a bit of memory by 
; specifying the correct # of Megabytes
; Example: PHYSMB=32
; *************************************************************************
; ***** Examples of sym files that can be included if you have the SDK *****
;	Change the path to the appropriate drive and directory
;LOAD=c:\windows\system\user.exe
;LOAD=c:\windows\system\gdi.exe
;LOAD=c:\windows\system\krnl386.exe
;LOAD=c:\windows\system\mmsystem.dll
;LOAD=c:\windows\system\win386.exe
; ***** Examples of export symbols that can be included *****
;	Change the path to the appropriate drive and directory
;EXP=c:\windows\system\vga.drv
;EXP=c:\windows\system\vga.3gr
;EXP=c:\windows\system\sound.drv
;EXP=c:\windows\system\mouse.drv
;EXP=c:\windows\system\netware.drv
;EXP=c:\windows\system\system.drv
;EXP=c:\windows\system\keyboard.drv
;EXP=c:\windows\system\toolhelp.dll
;EXP=c:\windows\system\shell.dll
;EXP=c:\windows\system\commdlg.dll
;EXP=c:\windows\system\olesvr.dll
;EXP=c:\windows\system\olecli.dll
;EXP=c:\windows\system\mmsystem.dll
;EXP=c:\windows\system\winoldap.mod
;EXP=c:\windows\progman.exe 
;EXP=c:\windows\drwatson.exe 
; ***** Examples of export symbols that can be included for Windows 95 *****
;	Change the path to the appropriate drive and directory
EXP=c:\windows\system\kernel32.dll
EXP=c:\windows\system\user32.dll
EXP=c:\windows\system\gdi32.dll
EXP=c:\windows\system\comdlg32.dll
EXP=c:\windows\system\shell32.dll
EXP=c:\windows\system\advapi32.dll
EXP=c:\windows\system\Msvbvm50.dll
EXP=c:\windows\system\Msvbvm60.dll
EXP=c:\windows\system\shell232.dll
EXP=c:\windows\system\comctl32.dll
EXP=c:\windows\system\crtdll.dll
EXP=c:\windows\system\version.dll
EXP=c:\windows\system\netlib32.dll
EXP=c:\windows\system\msshrui.dll
EXP=c:\windows\system\msnet32.dll
EXP=c:\windows\system\mspwl32.dll
EXP=c:\windows\system\mpr.dll


;************End of ACiD BuRN's Winice.dat fin de s&eacute;lection *****************

Donc vous copier / coller ceci dans un fichier nommé winice.dat et
mettez-le &agrave; la place du v&ocirc;tre !! Mais changez quand m&ecirc;me le nombre de Ram par 
celui de votre PC (pas trop dur ;p)

Voil&agrave;, &ccedil;a sera tout pour la configuration de Soft-ice !!
Passons aux commandes maintenant !!!


*****************************
** Commandes de Soft-ice:  **
*****************************

- pour faire appara&icirc;tre Soft-ice, pressez:  Ctrl+D

Tout d'abord, les points d'arr&ecirc;t (Breakpoints)!
On les utilise sur les fonctions de Windows (API) mais c'est une autre histoire!
Vous verrez dans la suite du cours :]

Pour poser un breakpoint, sous Soft-ice tapez: BPX API_windows (apiwindows 
repr&eacute;sente la fonction Windows que vous voulez '&eacute;tudier')
Apres avoir mis un bpx sur une API Windows vous pouvez par exemple
voir la liste des bpx d&eacute;j&agrave; pos&eacute;s!

Liste des bpx: 		BL
Editer un bpx: 		BE num&eacute;ro_du_bpx
Effacer un bpx:		BC num&eacute;ro_du_bpx
Effacer tous les bpx:	BC *
Désactiver un bpx: 	BD num&eacute;ro_du_bpx
Désactiver tout:  	BD *
Activer un BPX:		BE numero_du_bpx
Activer tous les BPX:	BE *

Il y a les: BPINT (breakpoint sur les interruptions comme INT3 ...)
ex: BPINT 3

Il existe aussi les BPM et autres BPR (je vous reparle des BPR dans la partie
sur le keygening)

Je ne vois pas de commande TRES utile tout de suite! On verra bien si j'ai
oublié qq chose d'important!
Mais il existe des milliers de commandes dans Soft-ice! Le but premier
du Logiciel et de debugger gentiment ses propres programmes :)
Ce que je fais aussi, mais quand je code un keygen en asm (souvent comme un
cow-boy et que je dois tracer pour voir ce qui part en couille *grin*)


Maintenant quelques exemples d'utilisation de notre nouveau jouet !!

</pre>
<font size="+2"><a name="serial"><b><u>Trouver les serials (Serial Fishing)</u></B></a></font><br><br>
<pre>


Voil&agrave;, comment trouver les serials valides pour votre nom dans les programmes
telles que WinZIP, WinImage ... (WinRAR c'est pas encore pareil (v2.0 a 2.5))
On commence avec un exemple:


*******************************************
****		WWW GIF ANIMATOR 1.0       ****
*******************************************



Entrez un nom, pr&eacute;nom, et un num&eacute;ro de s&eacute;rie &agrave; la mord-moi-le-noeud!
On appuie sur OK.
L&agrave; le programme nous envoie chier car le num&eacute;ro est bidon.
On va donc poser un point d'arr&ecirc;t sur une fonction de Windows qui
est tr&egrave;s couramment utilisée dans ce genre de protection,
en fait il y en a 2:

Getwindowtexta  pour les progs 32 bits (Getwindowtext pour 16 bits)
getdlgitemtexta pour les progs 32 bits (getdlgitemtext pour 16 bits)

Pour aller sous Soft-ice, il faut presser les touches Control+D.
Une fois sous Soft-ice on tape:

si vous n'avez pas:
on appuie sur alt + R pour voir les registres (eax, edx ...)
on appuie sur alt + D pour voir la zone data.


Pour poser le point d'arr&ecirc;t:  BPX Getwindowtexta
                              BPX getdlgitemtexta 

On appuie sur F5 et on retourne &agrave; Windows.

J'ai entré pour First Name: ACiD
           pour Last Name : BuRN
                     code : 12345

on appuie sur OK.
Boum, Soft-ice est r&eacute;apparu et nous dit :

'break due to BPX Getdlgitemtexta'

On tape D EAX et on voit dans la zone data : ACiD BuRN
On appuie une fois sur F5 car on est dans le 'contr&ocirc;le' du nom
et que l'on veut s'occuper du serial.
Entre la zone data et la zone de code, il y a marqué : USER32 ....
Nous ne sommes donc pas dans le programme, donc on fait F12 puis il n'y a plus
rien. On est maintenant dans le programme.
On trace comme un fou avec F10 et au bout d'un moment on voit dans
la zone Registre EAX=00003039. Int&eacute;ressant car si on fait :
? EAX
on voit appara&icirc;tre : 00003039    0000012345  "09"
3039 c'est en hexad&eacute;cimal et 12345 c'est en d&eacute;cimal.

12345 ce ne serait pas le code que l'on a tap&eacute; au d&eacute;but ? Mais si,
on ne doit pas être tr&egrave;s loin.
On continue &agrave; tracer (avec F10) tout en surveillant EAX et apr&egrave;s
quelques F10, eax change !!!
EAX a changé. Il est devenu :  EAX=7D5F4
on tape ? EAX
on obtient:   0007D5F4    00005135314
Tiens si on essayait 513534 comme code ?

On fait control + D et on tape BC 0,1 pour effacer les 2 points d'arr&ecirc;t.
F5 et nous voil&agrave; sous Windows.

Donc on entre First Name: ACiD
              Last Name : BuRN
                   Code : 513524

Et voil&agrave; le programme ne nous envoie pas chier, nous sommes maintenant
enregistrés !!!  Hihihi, trop simple n'est-ce-pas ?
Mais bon, ne vous r&eacute;jouissez pas trop vite, il existe des protections 
par name/serial BCP BCP plus dures, un exemple est Phrozen Crew trial crackme!
Car dans ce cas l&agrave;, j'ai d&ucirc; faire une &eacute;quation, et le serial n'est pas tapable
au clavier directement.. je vous invite donc &agrave; lire ce cours qui se trouve sur
ma page :)


Petite astuce sur les programmes &eacute;crits en delphi:

les API pr&eacute;c&eacute;demment cit&eacute;es ne marchent pas en Delphi!! car ils ne sont pas
utilis&eacute;s! donc pour pouvoir Breaker:
BPX hmemcpy  <-- je me sers tr&egrave;s souvent de celui-l&agrave; !! On est s&ucirc;r de
stopper dans Soft-ice au moins!
Dans de nombreux programmes, la comparaison GOOD serial / BAD serial se fait
de la fa&ccedil;on suivante:

CMP EAX, EDX
je  good message
jmp get_the_fuck_outta_here!

En gros, le bon serial (dans EDX) est compar&eacute; au mauvais serial dans (EAX)
Il suffit de faire: d EAX (pour voir le faux serial)
                    d EDX (pour voir le bon serial)

Autre astuce, pour ce genre de contr&ocirc;le de serial !!
Si le programme est en Delphi et que vous ne cherchez qu'un serial valide:
mettez un bpx Hmemcpy apr&egrave;s avoir entré un nom et num&eacute;ro de s&eacute;rie.
Ensuite, pressez le bouton OK, et vous revenez sous Soft-ice, maintenant
pressez F5 le nombre de fois n&eacute;cessaire pour quitter Soft-ice mais comptez
les !! exemple: 12 fois
Ensuite, recommencez la m&ecirc;me chose, mais arr&ecirc;tez vous une fois avant le 
nombre de F5 que vous avez compté! Pour mon exemple: 12 fois - 1 = 11 fois
donc vous pressez F5 11 fois !!
Ensuite pressez F12 pour quitter les Dll tels que USER32, kernel32 une fois
que vous &ecirc;tes au bon endroit (vous verrez le nom de l'exe &agrave; la place du
nom des dlls) commencez &agrave; tracer avec F10!
Vous rencontrerez une s&eacute;rie de RET, mais &ccedil;a ne fait rien !!!!
Au bout d'un moment, pas long du tout ;p vous allez vous retrouver avec 
qq chose du style:

mov eax, blablabla    
mov EDX, blablabla    
Call blablabla      <-- entrez dans ce call gr&acirc;ce &agrave; F8
jz 	blablabla      


Tracez ensuite avec F10 et vous devriez voir le fameux: CMP EAX, EDX
d&eacute;crit plus haut ;))
Note: en faisant: D eax et D edx sans entrer dans le call, on aurait eu les
serials aussi !!!
Et le jz (jz = je) , c'est lui qui d&eacute;fini si c'est ok !! Remplacez-le
par un JMP par exemple et le programme ira toujours au bon message !!
donc vous serez enregistr&eacute; :) Oh my god hehe :)

Je ne vais pas encore &eacute;crire un tut pour &ccedil;a ;p mais je dois avoir encore
un exemple sur un name / serial.
Cette fois-ci, c'est sur un crackme programm&eacute; en Delphi :) donc
on va utiliser BPX hmemcpy comme pr&eacute;vu :))

***********************************
****    Hellforge Crackme 2    ****
***********************************


Ce crackme a une protection "Name/Serial"... chargez SI! 

Il y a 2 BPX utiles pour ce genre de protection :
- bpx Getwindowtexta 
- bpx Getdlgitemtexta 

Ctrl+D 
entrez les 2 breakpoints du dessus 
F5 

Enter name: ACiD BuRN et serial: 1122334455. 

Cliquez sur "Click here to check your serial !!!" 
Wrong code .. Quoi??? Nous ne sommes pas sous SI?? ! 

Donc ces breakpoints ne fonctionnent pas ici!! Merde!!
On va essayer bpx hmemcpy, &ccedil;a marche tout le temps!

Ok, on r&eacute;entre name: ACiD BuRN et serial: 1122334455. 
Cliquez sur le bouton et l&agrave; on est de retour dans Soft-ice ! 
Cool ! 
Nous voyons KERNEL en bas de la fen&ecirc;tre... il faut sortir d'ici. 
Pressez F12 autant de fois n&eacute;cessaire (7x) pour que vous voyez en bas de la fen&ecirc;tre:
HF CRACKME .. 

Nous sommes &agrave; la bonne place... F10 pour continuer &agrave; tracer...
EAX contient la longueur du nom : ACiD BuRN = 9

Continuez de tracer avec SI encore un peu et vous voyez que EAX=B92COC
tapez d eax dans SI et vous voyez ACiD BuRN
et un nombre: 104837121. Qu'est ce ? un serial?
On va l'essayer!

D&eacute;sactivez tous les breakpoints avec BD * :

nAME: ACiD BuRN
cODE: 104837121

Cool, le message !!!
Well done, Crackme cracked !!

</pre>
<font size="+2"><a name="keygen"><b><u>Comment keygener pas mal de programmes (utilisation des BPR...)</u></B></a></font><br><br>
<pre>

Avant de vous parler des m&eacute;thodes comme l'utilisation de BPR, je vais
vous d&eacute;crire ce qu'est le keygening pour ceux qui ne savent pas !!
Keygener un programme c'est quoi ?
C'est &eacute;crire un programme qui g&eacute;n&egrave;re des clefs (serials) valides pour
un programme donn&eacute;, en fonction des noms, num&eacute;ro de s&eacute;rie du
disque dur ...
Bref, on trace avec Soft-ice la g&eacute;n&eacute;ration du serial en m&eacute;moire et
on reprogramme ceci, afin que l'on obtienne les codes valides pour
ce programme tr&egrave;s rapidement :)
C'est tr&egrave;s int&eacute;ressant, croyez moi :)
Bon tout d'abord, je vais vous montrer un exemple tr&egrave;s simple !!
Sans m&eacute;thode sp&eacute;cifique, et ensuite, dans un prochain exemple
vous montrer qu'utiliser les BPR est un gain de temps non n&eacute;gligeable !!

*******************************************************************
****    How to keygen the Cracking4newies Crackme 3 project    ****
*******************************************************************

niveau: d&eacute;butant

I) C'est parti !!


Ok, c'est parti, il est temps de keygener cette chiotte :) donc dans
Soft-ice, mettez vos BPX pr&eacute;f&eacute;r&eacute;s !! Ceux utilis&eacute;s dans les protections par 
names / serials :
bpx getwindowtewta et getdlgitemtexta .

Entrez votre nom et un faux serial (name : ACiD BuRN /  Serial : 12345).
Clickez sur enter et vous &ecirc;tes de retour dans Soft-ice !!
Pressez F12 parce que vous n'&ecirc;tes pas &agrave; la bonne place, mais dans cette merde
de user32.dll...
Maintenant, vous &ecirc;tes dans le crackme ! (j'esp&egrave;re que vous comprenez tout,
je suis trop fatigu&eacute; !)
Tracez tant que vous n'arrivez pas &agrave; &ccedil;a:


* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:004010C6(C)
|
:004010AF 0FBE4415C0              movsx eax, byte ptr [ebp+edx-40]  
; mets en eax la 1&egrave;re valeur ascii de votre nom (pour ACiD BuRN :  A=41)

:004010B4 03F0                    add esi, eax                 /                  
:004010B6 8D7DC0                  lea edi, dword ptr [ebp-40] /   
:004010B9 83C9FF                  or ecx, FFFFFFFF           /               
:004010BC 33C0                    xor eax, eax              /               
:004010BE 42                      inc edx                  /        Boucle                        
:004010BF F2                      repnz                   /
:004010C0 AE                      scasb                  /
:004010C1 F7D1                    not ecx               /
:004010C3 49                      dec ecx              /      
:004010C4 3BD1                    cmp edx, ecx        /            
:004010C6 76E7                    jbe 004010AF       /              



Ok cool, mais que fait cette boucle ? :

movsx eax, byte ptr [ebp+edx-40]  <==   eax = valeur ascii du caract&egrave;re &agrave; la position EDX
add esi, eax                      <==   esi = esi + eax
inc edx                           <==   caract&egrave;re suivant
cmp edx, ecx                      <==   compare la longueur du nom avec le compteur en edx
jbe 004010AF                      <==   Boucle tant que tout les chars n'ont pas &eacute;t&eacute; faits!


Donc, cette boucle prends les valeurs ascii de chaque lettres et les ajoutes dans ESI.
R&eacute;sultat pour ACiD BuRN: 2A8h

41h + 43h + 69h + 44h + 20h + 42h + 75h + 52h + 4Eh = 2A8h
 A     C     i     D   space   B     u     R     N


Apr&egrave;s cette boucle, vous arrivez ici:


:004010C8 897508               mov dword ptr [ebp+08], esi  ; [ebp+8] prends la valeur d'ESI
:004010CB C1650807             shl dword ptr [ebp+08], 07   ; [ebp+8] = shl [ebp+8],7
:004010CF 8D4DF4               lea ecx, dword ptr [ebp-0C]  
:004010D2 6A0A                 push 0000000A
:004010D4 51                   push ecx
:004010D5 68E9030000           push 000003E9
:004010DA 53                   push ebx



Comme vous pouvez le voir, la valeur d'ESI (pour moi: 2A8) est plac&eacute;e dans [ebp+8].
Ensuite, on voit :  shl dword ptr [ebp+08], 07
Int&eacute;ressant ;)
Ben, on continue &agrave; tracer :-]
Tant que vous n'arrivez pas &agrave; &ccedil;a :


* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:004010E4(C)
|
:00401102 8D55F4              lea edx, dword ptr [ebp-0C]
:00401105 52                  push edx
:00401106 E840010000          call 0040124B
:0040110B 8B4D08              mov ecx, dword ptr [ebp+08] ; ECX = [ebp+8] ([ebp+8]= shl esi,7)
:0040110E 83C404              add esp, 00000004
:00401111 03CE                add ecx, esi             ; ECX = ECX + ESI  (ESI=2A8 pour moi)
:00401113 3BC8                cmp ecx, eax             ; ? eax = fake serial / ? ecx = bon
:00401115 6A00                push 00000000
:00401117 751B                jne 00401134             ; si c'est pas &eacute;gal saute &agrave; BAD CRACKER

* Possible StringData Ref from Data Obj ->"Good!"
                                  |
:00401119 685C504000              push 0040505C

* Possible StringData Ref from Data Obj ->"Congratulations!!"
                                  |
:0040111E 6848504000              push 00405048
:00401123 53                      push ebx



Sympa tout &ccedil;a! Vous pouvez coder un keygen facilement non ? !!
Laissez-moi vous r&eacute;p&eacute;ter l'algo:

1st part: Additionnez les valeurs ascii du nom et mettez le r&eacute;sultat qq part (ESI en m&eacute;moire)

2nd part: Prenez la valeur en ESI et faites un shl,7 dessus et mettez le r&eacute;sultat qq part
          ([ebp+8] en m&eacute;moire)

3rd part: Additionnez la valeur de la premi&egrave;re partie et additionnez l&agrave; &agrave; celle de la 
          2&egrave;me partie

4th part: Prenez le r&eacute;sultat en d&eacute;cimal et vous avez votre serial :)

Name : ACiD BuRN
sERiAL : 87720

Je vous ai tout donn&eacute; pour faire votre propre keygen, mais je vous file qd m&ecirc;me mes sources:
Je vais vous montrer 2 sources! Une en Delphi+asm et une en C+asm.
Celle en Delphi a &eacute;t&eacute; codée &agrave; 2h du matins !! vite fait :) mais &ccedil;a marche :))


*********************SOURCES DELPHI************************

procedure TForm1.Edit1Change(Sender: TObject);

var i,ascii,result: integer;

begin
	for i:=1 to length(edit1.text) do
begin

ascii:=ascii + ord(edit1.text[i]);
end;

asm
    mov eax,ascii
    mov ecx,ascii
    shl eax,7
    add eax,ecx
    mov ascii,eax
end;

result:=ascii;
edit2.text:=inttostr(result);
end;
end.


*********************FIN DE SOURCES DELPHI*********************************************


Maintenant la version en C+asm (le C me sert juste pour d&eacute;clarer les variables!
Bien moins chiant que l'asm direct!!)

*********************SOURCES C++ + ASM************************************************

#include <stdio.h>
#include <string.h>
#include <conio.h>

int main(){
    int i,len;

    unsigned char name[100];

    unsigned long check=0;

    printf("\[ Cracking4Newbies crackme3 ] *Keygen* By : ACiD BuRN / ECLiPSE 1999\n");
    printf("\______________________________________________________________________\n");
    printf("\nEnter your name: ");
    gets(name);
    len=strlen(name);

asm
{
       
       xor ecx, ecx
       xor edx, edx
       xor esi, esi
       xor edi, edi
       mov esi, [len]
start:

       movsx eax, [name+ecx]
       add edi, eax
       mov eax, edi
       inc ecx
       cmp ecx, esi
       jne start

       shl edi, 7
       add edi,eax
       mov [check], edi

}
    
    printf("Your Serial is: %lu" ,check);
    printf("\nEnjoy!");
getch();
return 0;

}


*********************FIN DE SOURCES C++ + ASM****************************************


*************************************************************************************
****                             BPR: La bonne m&eacute;thode :)                        ****
*************************************************************************************


Maintenant ! Utilisation des BPR pour keygener !
La technique que je vais vous montrer marche tr&egrave;s tr&egrave;s bien avec les programmes
en C++ par exemple :)
Je ne vais pas vous saouler longtemps, mais &eacute;crire directement un exemple
d'utilisation de cette commande!!

On va bosser sur un Crackme: RD116 Crackme

Ok, la protection est de type name / serial! Ca a &eacute;t&eacute; &eacute;crit en C++
Coool, tr&egrave;s bien pour s'amuser avec !!
On peut keygener ce crackme sans utiliser les BPR, mais gr&acirc;ce aux BPR.
Vous allez voir comment tomber directement sur la routine de g&eacute;n&eacute;ration
du serial !!! Let's go:

Entrez votre nom : ACiD BuRN et serial: 112233
Sous Soft-ice mettez les bpx suivants: bpx getdlgitemtexta et
bpx getwindowtexta ....
Ensuite pressez le bouton pour v&eacute;rifiez le serial et vous &ecirc;tes de retour
sous Soft-ice!!
On voit "Break due to BPX USER32!GETWINDOWTEXTA ...
Ok! Alors ne pressez pas F11 ni F12 encore sinon on ne pourra pas examiner
les param&egrave;tres sur la pile !!

On va agir intelligemment plut&ocirc;t ! On va examiner la pile !
Nous allons regarder les param&egrave;tres mais pour cela on va se mettre en
Dword sous Soft-ice !! Ca sera plus lisible d&eacute;j&agrave;.
Sous Soft-ice: dd esp
"dd" veut dire: display dword et "esp" c'est pour le pointeur de pile!
Apr&egrave;s avoir fait "dd esp", la fen&ecirc;tre de Soft-ice change et on peut voir les param&egrave;tres :

xxxx:yyyyyyyy  A     B     C     D  ................
xxxx:yyyyyyyy  E     F     G     H  ................


O&ugrave; A,B,C,D,E... sont du genre:  XXXXXXXX


Vous devez voir qq chose qui ressemble &agrave; cela:

xxxx:yyyyyyyy   5F403504	00000098	00654250	0000000A  ...........
On ne vas s'occuper que de &ccedil;&agrave; !!

(donc vous l'avez remarqu&eacute;, ici A=5F403504 , B=00000098 ...)
On voit ici l'adresse &agrave; laquelle notre nom se termine (00654250).

Tapez D "adresse &agrave; laquelle finis le nom"
exemple ici: D 00654250

Vous pouvez maintenant presser F11 et vous pouvez voir votre nom &agrave; l'adresse
que vous avez tap&eacute; :) C'est bon signe d&eacute;j&agrave; !!

Nous allons maintenant poser un bpr (break on memory range).
Ce type de bp marche de la fa&ccedil;on suivante:

bpr "adresse de d&eacute;part" "adresse de fin" RW

RW veut dire: Read et write (lecture et &eacute;criture)
Donc, &ccedil;a stoppera qd on lit ou &eacute;crit &agrave; cette adresse en m&eacute;moire !

Donc tapez ceci sous Soft-ice:
bpr 654250 654250+(longueur_du_nom - 1) rw

Dans notre exemple, cela donne pour ACiD BuRN (longueur: 9 -> 9 - 1 = 8)

bpr 654250 654250+8 rw

Vous pouvez d&eacute;sactiver les bpx sur getwindowtexta et getdlgitemtexta now !
Vous n'avez plus qu'&agrave; presser F5, et on se retrouvera directement dans la
routine de g&eacute;n&eacute;ration de serial !!

Notes: Pressez F5 tant que vous n'&ecirc;tes pas dans le crackme !!
C'est-&agrave;-dire que les DLL on s'en branle :)

Une fois que vous &ecirc;tes dans le crackme vous arrivez direct sur la
g&eacute;n&eacute;ration.

Une partie qui bosse sur le nom:


:00401580 8A18                mov bl, byte ptr [eax]   ; Prends la valeur ascii (position cl)
:00401582 32D9                xor bl, cl               ; XOR cette valeur avec le compteur
:00401584 8818                mov byte ptr [eax], bl   ; store le r&eacute;sultat
:00401586 41                  inc ecx                  ; incr&eacute;mente ecx (ecx = ecx + 1 )
:00401587 40                  inc eax                  ; incr&eacute;mente eax (eax = eax + 1 )
:00401588 803800              cmp byte ptr [eax], 00   ; encore des lettres ? 
:0040158B 75F3                jne 00401580             ; si oui, lettre suivante!
:0040158D 33C0                xor eax, eax             ; remet &agrave; zero 
:0040158F 33DB                xor ebx, ebx             ; les registres
:00401591 33C9                xor ecx, ecx             ; EAX, EBX, ECX
:00401593 B90A000000          mov ecx, 0000000A        ; ECX = Ah (10 en hexa)
:00401598 33D2                xor edx, edx             ; EDX = 0
:0040159A 8B45F0              mov eax, dword ptr [ebp-10] ; on r&eacute;cup&egrave;re les valeurs


2&egrave;me partie: sur le serial entr&eacute; :


* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:004015A8(C)
|
:0040159D 8A18                 mov bl, byte ptr [eax]  ; Prends la valeur ascii (position cl)
:0040159F 32D9                 xor bl, cl              ; XOR cette valeur avec le compteur
:004015A1 8818                 mov byte ptr [eax], bl  ; store le r&eacute;sultat
:004015A3 41                   inc ecx                 ; incr&eacute;mente ecx (ecx = ecx + 1 )
:004015A4 40                   inc eax                 ; incr&eacute;mente eax (eax = eax + 1 )
:004015A5 803800               cmp byte ptr [eax], 00  ; encore des chiffres ?
:004015A8 75F3                 jne 0040159D
:004015AA 8B45E4               mov eax, dword ptr [ebp-1C]
:004015AD 8B55F0               mov edx, dword ptr [ebp-10]


Et la derni&egrave;re routine: v&eacute;rification du serial


* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:004015BF(C)
|
:004015B0 33C9                 xor ecx, ecx              ; ECX = 0
:004015B2 8A18                 mov bl, byte ptr [eax]    ; on r&eacute;cup&egrave;re les valeurs et on les
:004015B4 8A0A                 mov cl, byte ptr [edx]    ; mets dans EAX et EDX
:004015B6 3AD9                 cmp bl, cl                ; on compare! c'est &eacute;gal ? 
:004015B8 7509                 jne 004015C3              ; non jmp : bad cracker
:004015BA 40                   inc eax                   ; eax = eax + 1
:004015BB 42                   inc edx                   ; edx = edx + 1
:004015BC 803800               cmp byte ptr [eax], 00    ; on fait &ccedil;a pour tout !
:004015BF 75EF                 jne 004015B0
:004015C1 EB16                 jmp 004015D9              ; si tout est ok! GENTIL CRACKER


* Referenced by a (U)nconditional or (C)onditional Jump at Addresses:
|:00401503(U), :0040151C(U), :004015B8(C)
|
:004015C3 6A00                 push 00000000

* Possible StringData Ref from Data Obj ->"Rat"
                                  |
:004015C5 686C304000           push 0040306C

* Possible StringData Ref from Data Obj ->"Mauvais serial, essaye encore... "


..........


* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:004015C1(U)
|
:004015D9 6A00                    push 00000000		; tout est ok !! on arrive ici

* Possible StringData Ref from Data Obj ->"Bien jou"
                                  |
:004015DB 6834304000              push 00403034

* Possible StringData Ref from Data Obj ->"C' est crack"
                                  |
:004015E0 6820304000              push 00403020
:004015E5 8B4DE0                  mov ecx, dword ptr [ebp-20]



Donc voil&agrave; !! Je crois que vous avez compris ce qu'il se passe ici :)
La routine de g&eacute;n&eacute;ration est tr&egrave;s simple !!
Je ne vais donc pas m'attarder dessus, mais je vais donner les sources du keygen
bien s&ucirc;r !!
Apr&egrave;s le C++, le Delphi, c'est au tour du VB !!
Ayant la flemme de traduire &ccedil;a en ASM (tr&egrave;s simple, mais j'ai pas le go&ucirc;t), je vous
propose tout de m&ecirc;me ces sources !!

Le but de cette explication &eacute;tait la familiarisation avec les BPR !!
Pas de savoir keygener juste ce crackme l&agrave; !!
Avec cette technique vous pouvez keygener bcp de choses, ensuite &ccedil;a d&eacute;pends
de votre niveau en asm et de la registration !!
Si &ccedil;a fait 1000 lignes ! On fait copier-coller ;) et on programme en ASM
sans trop se poser de questions !
Bref, voici les sources:


********************** Source en VB: RDD-116 Crackme 1 Keygen***********************


Private Sub Text1_Change()
If Len(Text1.Text) < 6 Then

	Text2.Text = "Le nom doit &ecirc;tre sup&eacute;rieur à 6 chars"
Else
	For i = 1 To Len(Text1.Text)
	a = 9 + i
	temp = Asc(Mid$(Text1.Text, i, 1)) Xor i Xor a
	result = result & Chr(temp)
Next i

Text2.Text = result
End If
End Sub


********************** Source en VB: RDD-116 Crackme 1 Keygen***********************


Hehe simple non ?
Voil&agrave;, la partie des keygens est termin&eacute;e, mais entra&icirc;nez-vous avec les BPR!
C'est super et utilis&eacute; par bcp de keygeners aussi...
Pour le Delphi, il vous faut trouver l'adresse m&eacute;moire de votre nom et faire
&agrave; peu pr&egrave;s la m&ecirc;me chose ensuite :))
Enjoy !

</pre>
<font size="+2"><a name="ownkey"><b><u>Transformer un programme en son propre 
keygen</u></b></a></font><br>
<br>
<pre>

Muad'dib Keygen Crackme #1


          - Afficher le bon serial &agrave; la place du msg d'erreur


Introduction:

Il faut faire un keygen, les keygens c'est marrant mais on va apprendre autre chose cette fois.
On ne va pas coder un keygen (qui d'ailleurs est tr&egrave;s simple &agrave; faire) mais forcer le crackme
&agrave; afficher le bon serial &agrave; la place du message: "try again , Blablabla.."


utils n&eacute;cessaires:

	- Soft-ice (it r0x)
	- &eacute;diteur hexad&eacute;cimal



Let's kick some ass =)


Bon, d&eacute;j&agrave; on lance ce con de crackme, et on entre son nom: ACiD BuRN et un serial
&agrave; 2 francs: 0800
Ensuite dans Soft-ice (ctrl+d) on tape: Bpx hmemcpy
On click sur Register et on arrive dans Soft-ice.. F12 pour sortir dans dlls et d&egrave;s
qu'on est dans le crackme on commence &agrave; tracer.
On arrive assez vite &agrave; une routine qui contr&ocirc;le le type de nom entr&eacute; (minuscules,
majuscules, espaces, chiffres ...) mais il y a d'abord un check sur la longueur du nom:

025F:004010A3  83F804              CMP     EAX,04     <-- compare la taille du nom &agrave; 4
025F:004010A6  7304                JAE     004010AC   <-- ok si sup&eacute;rieur ou &eacute;gal &agrave; 4
025F:004010A8  C9                  LEAVE
025F:004010A9  C21000              RET     0010

Apres &ccedil;a, il y a le contr&ocirc;le des caract&egrave;res :

025F:004010AC  BA00000000          MOV     EDX,00000000
025F:004010B1  8A8200314000        MOV     AL,[EDX+00403100]
025F:004010B7  3C00                CMP     AL,00
025F:004010B9  7426                JZ      004010E1
025F:004010BB  3C20                CMP     AL,20
025F:004010BD  7408                JZ      004010C7
025F:004010BF  3C41                CMP     AL,41
025F:004010C1  7C07                JL      004010CA
025F:004010C3  3C5A                CMP     AL,5A
025F:004010C5  7F03                JG      004010CA
025F:004010C7  42                  INC     EDX
025F:004010C8  EBE7                JMP     004010B1
025F:004010CA  6A00                PUSH    00
025F:004010CC  687D304000          PUSH    0040307D
025F:004010D1  684D304000          PUSH    0040304D
025F:004010D6  6A00                PUSH    00
025F:004010D8  E8BD000000          CALL    USER32!MessageBoxA


Cette merde check si notre nom a des minuscules, majuscules, espaces ...
Si c'est pas ok, &ccedil;a jump &agrave; 4010CA, et un message box nous dit de n'enter que des majuscules
et des espaces...
Merci, mais on avait compris ;)


Donc, on sort de Soft-ice, on met: ACID BURN comme nom, et 0800 tjs pour le serial
et on y retourne. On trace et on tombe sur la comparaison finale:

025F:0040112D  68F6304000          PUSH    004030F6      <- d 4030f6 = fake serial
025F:00401132  6800314000          PUSH    00403100      <- d 403100 = bon serial
025F:00401137  E840000000          CALL    KERNEL32!lstrcmp  
025F:0040113C  83F800              CMP     EAX,00
025F:0040113F  7517                JNZ     00401158
025F:00401141  6A00                PUSH    00
025F:00401143  68D3304000          PUSH    004030D3   <- d 4030D3 = Good (titre de la msg box)
025F:00401148  6889304000          PUSH    00403089   <- d 403089 = Bon message qd tu as le serial
025F:0040114D  6A00                PUSH    00
025F:0040114F  E846000000          CALL    USER32!MessageBoxA
025F:00401154  C9                  LEAVE
025F:00401155  C21000              RET     0010
025F:00401158  6A00                PUSH    00
025F:0040115A  68EA304000          PUSH    004030EA   <- d 4030EA = Bad (titre de la msgbox)
025F:0040115F  68DD304000          PUSH    004030DD   <- d 4030DD = bad boy ;p pas le bon pass
025F:00401164  6A00                PUSH    00
025F:00401166  E82F000000          CALL    USER32!MessageBoxA



En r&eacute;sum&eacute;, on voit une comparaison bon serial /  mauvais serial ex&eacute;cut&eacute;e par l'API
lstrcmp, qui compare des strings. On voit un CMP EAX,00 : si la comparaison est ok 
le serial est bon, donc EAX = 0 et on affiche le bon messagebox :)
Sinon, &ccedil;a saute &agrave; la mauvaise box !!

Ok donc pour nous, ici :

025F:0040112D  68F6304000          PUSH    004030F6      <- d 4030f6 = fake serial
025F:00401132  6800314000          PUSH    00403100      <- d 403100 = bon serial


d 4030f6 nous donne: 0800
d 403100 nous donne: XZP]P[LKW

Le bon serial ok, mais c'est pas &ccedil;a qu'on veut :)
On veut forcer le prog &agrave; montrer le bon serial &agrave; la place du message d'erreur :)
Pour cela, on voit que juste avant la msg box Bad serial il y a 2 push :

le caption du titre de la title bar = push 4030EA
le texte du message du msgbox  = push 4030DD

Il push ces merdes, et ensuite il affiche le message &agrave; la con !
Donc pour le faire afficher le bon serial tu prends l'adresse du push 'bon serial' et tu la
copies &agrave; la place du push 'message comme quoi tu as foir&eacute;' !!

025F:0040115A  68EA304000          PUSH    004030EA 
025F:0040115F  68DD304000          PUSH    004030DD 
025F:00401164  6A00                PUSH    00
025F:00401166  E82F000000          CALL    USER32!MessageBoxA


cela devient:


025F:0040115A  68EA304000          PUSH    004030EA   
025F:0040115F  6800314000          PUSH    00403100   <-- push bon serial
025F:00401164  6A00                PUSH    00
025F:00401166  E82F000000          CALL    USER32!MessageBoxA


On a maintenant plus qu'&agrave; modifier physiquement notre crackme, et le bon pass appara&icirc;tra
&agrave; la place de l'erreur :) et voil&agrave; notre super keygen pour branleurs :)
Hehe, c'est rapide, efficace, et on se fatigue pas :P

on cherche donc dans l'exe: 68EA30400068DD304000 
on remplace dans l'exe par: 68EA3040006800314000

Tu saves le fichier, et tu lances, mets un serial en majuscules et goodie :))
Le good serial appara&icirc;t, Facile ....

Remarques on a toujours le titre : erreur code dans la msg box, rien ne vous emp&ecirc;che
de le changer en: Keygen ;)


***********************************************************
****   Reprogrammer la routine de Contr&ocirc;le du serial   ****
***********************************************************

Toujours sur le m&ecirc;me crackme !!
On va donc recoder le check du serial dans Soft-ice pour s'occuper,
&ccedil;a va prendre 10 secs, mais bon ;)
C'est juste pour montrer que on peut faire bcp de choses en fait....

				notre routine de base:


025F:0040112D  68F6304000          PUSH    004030F6      <- d 4030f6 = fake serial
025F:00401132  6800314000          PUSH    00403100      <- d 403100 = bon serial
025F:00401137  E840000000          CALL    KERNEL32!lstrcmp  
025F:0040113C  83F800              CMP     EAX,00
025F:0040113F  7517                JNZ     00401158
025F:00401141  6A00                PUSH    00
025F:00401143  68D3304000          PUSH    004030D3   <- d 4030D3 = Good (titre de la msg box)
025F:00401148  6889304000          PUSH    00403089   <- d 403089 = Bon message qd tu as le serial
025F:0040114D  6A00                PUSH    00
025F:0040114F  E846000000          CALL    USER32!MessageBoxA
025F:00401154  C9                  LEAVE
025F:00401155  C21000              RET     0010
025F:00401158  6A00                PUSH    00
025F:0040115A  68EA304000          PUSH    004030EA   <- d 4030EA = Bad (titre de la msgbox)
025F:0040115F  68DD304000          PUSH    004030DD   <- d 4030DD = bad boy ;p pas le bon pass
025F:00401164  6A00                PUSH    00
025F:00401166  E82F000000          CALL    USER32!MessageBoxA


Comparaison gr&acirc;ce &agrave; l'API lstrcmp.
On va transcrire &ccedil;a en :


025F:0040112D  A1F6304000          MOV     EAX,[004030F6]
025F:00401132  8B1500314000        MOV     EDX,[00403100]
025F:00401138  3BC2                CMP     EAX,EDX
025F:0040113A  7405                JZ      00401141
025F:0040113C  EB1A                JMP     00401158
025F:0040113E  90                  NOP
025F:0040113F  90                  NOP
025F:00401140  90                  NOP
025F:00401141  6A00                PUSH    00
025F:00401143  68D3304000          PUSH    004030D3
025F:00401148  6889304000          PUSH    00403089
025F:0040114D  6A00                PUSH    00
025F:0040114F  E846000000          CALL    USER32!MessageBoxA
025F:00401154  C9                  LEAVE
025F:00401155  C21000              RET     0010
025F:00401158  6A00                PUSH    00
025F:0040115A  68EA304000          PUSH    004030EA
025F:0040115F  68DD304000          PUSH    004030DD
025F:00401164  6A00                PUSH    00
025F:00401166  E82F000000          CALL    USER32!MessageBoxA


Ceci fait exactement la m&ecirc;me chose, mais n'utilise pas d'API pour comparer.
On met en EAX: l'adresse du serial entr&eacute;, et en EDX le bon serial.
On les compare via : CMP EAX, EDX
Ensuite un saut conditionnel &agrave; la con et un Jump...
Les nop n'&eacute;taient pas utiles, mais &ccedil;a fais plus clean ;)
Voil&agrave;, le prog contr&ocirc;le si le serial est valide d'une autre mani&egrave;re, &ccedil;a sert &agrave;
rien, c'&eacute;tait juste pour montrer ce qu'on peut faire avec de l'imagination, hehe
On peut bien s'amuser donc :]

</pre>
<font size="+2"><a name="time"><b><u>Time Limits (limitation de 30 jours et autres 
merdes !!)</u></b></a></font><br>
<br>
<pre>

Comme vous l'avez s&ucirc;rement remarqu&eacute;, il existe des programmes
qui ne sont pas enregistrables car il n'y pas moyen de s'enregistrer !!
Ils sont en g&eacute;n&eacute;rale limit&eacute;s &agrave; 30 jours!!
C'est ce qu'on appelle: Time limit protection !!! Comment cracker &ccedil;a ?
Il y a plusieurs fa&ccedil;ons !! Nous allons voir &ccedil;a de suite !!


M&eacute;thode avec W32Dasm:

Vous avez un programme nomme X, qui apr&egrave;s 30 jours ne marche plus :(
Mais en revanche, il nous envoie une messagebox disant:
"La p&eacute;riode d'&eacute;valuation est termin&eacute;e..." ou "Trial version expir&eacute;e..."
Bref ce genre de conneries !! 
Alors si vous avez &ccedil;a, vous lancez W32Dasm et d&eacute;sassemblez le fichier &agrave; cracker.
Vous cherchez cette phrase dans les String Data References et une fois
que vous avez trouv&eacute;, double-clickez dessus afin d'aller &agrave; la place
de cette phrase dans W32Dasm !!
Et maintenant ?? Ben on &eacute;tudie le code aux alentours !! Ca ne vas pas &ecirc;tre
bien dur !!

G&eacute;n&eacute;ralement vous devriez trouver au dessus du message d'erreur des sauts
conditionnels de type JL, JLE, JG, JGE .....

Par exemple:


CMP DWORD PTR EAX, 1E     <-- 1Eh = 30 en d&eacute;cimal (30 jours!)
JLE 00405840              <-- jump au programme si c'est &eacute;gal ou inf&eacute;rieur &agrave; 30 jours                 


Ici on voit qu'il compare le nombre de jours &eacute;coul&eacute;s avec 30!
Tant que c'est inf&eacute;rieur ou &eacute;gal &agrave; 30 jours le programme marchera !!
Mais une fois d&eacute;pass&eacute; les 30 jours !! Ca marche plus :(
Donc pour cracker &ccedil;a on force le programme &agrave; sauter quoi qu'il arrive en changeant
le JLE en JMP !! et le programme sautera inconditionellement comme si de rien n'&eacute;tais!
Il croira tjs que l'on est encore dans la p&eacute;riode des 30 jours heheh !!


Avec Soft-ice:

Tout d'abord regardons les API utilis&eacute;es dans les time limites!! :
(eq: win32API.hlp)
Je ne traduirais pas, pour ne pas d&eacute;t&eacute;riorer les infos donn&eacute;es.

********************************************************************************************

* GetFileTime 

The GetFileTime function retrieves the date and time that a file was created, last accessed, 
and last modified. 

     BOOL GetFileTime(
      HANDLE  hFile,	                       // identifies the file 
      LPFILETIME  lpCreationTime,	       // address of creation time 
      LPFILETIME  lpLastAccessTime,	       // address of last access time  
      LPFILETIME  lpLastWriteTime 	       // address of last write time 
     );

Returns
If the function succeeds, the return value is TRUE.

If the function fails, the return value is FALSE. To get extended error information, call
GetLastError 


********************************************************************************************

* GetLocalTime

GetLocalTime function retrieves the current local date and time.

    VOID GetLocalTime(
      LPSYSTEMTIME  lpSystemTime 	       // address of system time structure  
     );

Returns
This function does not return a value. 

********************************************************************************************


* GetSystemTime 

The GetSystemTime function retrieves the current system date and time. The system time
is expressed in Coordinated Universal Time (UTC).

     VOID GetSystemTime(
      LPSYSTEMTIME  lpSystemTime 	      // address of system time structure  
     );

Returns
This function does not return a value.  


********************************************************************************************


* SystemTimeToFileTime 

The SystemTimeToFileTime function converts a system time to a file time.

    BOOL SystemTimeToFileTime(
      CONST SYSTEMTIME *  lpst,	              // address of system time to convert 
      LPFILETIME  lpft 	                      // address of buffer for converted file time 
    );

Returns
If the function succeeds, the return value is TRUE.

If the function fails, the return value is FALSE. To get extended error information,
call GetLastError.  

********************************************************************************************


Voil&agrave; !! Donc &ccedil;a c'&eacute;tait les API les plus couramment utilis&eacute;es dans les protections
par time limites!
Cependant, l'API la plus souvent utilis&eacute;e est : Getlocaltime
Donc vous mettez un Bpx dessus et vous lancez le programme !
Soft-ice break ! Pressez F12 pour arriver au bon endroit dans le programme et commencer
&agrave; tracer !!
Si vous voyez un saut de type: JL, JLE, JGE, JG vous savez ce qu'il vous
reste &agrave; faire !!
Je ne vais pas &eacute;crire des tonnes encore sur cette protection aussi stupide que
simple &agrave; cracker !!

Vous trouvez un exemple de Time limite mais dans la partie Visual Basic!!
Comment cracker un programme VB avec W32Dasm original !! ;-)
l33t hehe

Sinon, j'esp&egrave;re que vous voyez comment cracker &ccedil;a maintenant ......

</pre>
<font size="+2"><a name="nag"><b><u>Nag et autres Splash screen (diverse m&eacute;thodes...)</u></b></a></font><br>
<br>
<pre>

C'est la partie qui me fait le plus chier &agrave; &eacute;crire je pense !!
Pourquoi ? Car j'aime pas les nags screen !!
Je trouve &ccedil;a ennuyeux ;)
Mais on doit y passer alors commen&ccedil;ons d&egrave;s maintenant !!
Qu'est-ce qu'un Nag screen ?
Un nag screen, c'est une fen&ecirc;tre qui vient vous dire que vous
n'&ecirc;tes pas enregistr&eacute; et qu'il faut payer vite fait pour qu'elle disparaisse :)
Bref, c'est vraiment ennuyant, on peut tomber sur un NAG avec un bouton
d&eacute;sactiv&eacute; qui se r&eacute;active apr&egrave;s qq secondes par exemple !!
Bref casse-couilles &agrave; souhait ;)

Avant de commencer avec les trucs un peu plus compliqu&eacute;s avec Soft-ice et tout,
on va commencer par Simple !!

Cracker un nag screen avec seulement un &eacute;diteur hexad&eacute;cimal.

Quoi ? Vous vous demandez quelle connerie je suis en train de raconter lol !!
L'exemple que vais vous montrer est comment cracker le NAG screen de WinRAR 2.6
quand la limite dans le temps &agrave; expirée !!
Vous pourrez essayer cette technique sur ICQ99 afin de kicker les 8 secs au d&eacute;marrage!!

Bref assez bavardé !! Let's start :

*********************************
* Cracker le nag de WinRAR 2.6b *
*********************************


Tu lances WinRAR, apr&egrave;s avoir mis la date en avance, style : 2002.
L&agrave; tu vois un nag screen avec 5 boutons de merdes !!
Il y en a 1, avec Close...
Tu clicks dessus et WinRAR marche normalement. Donc, on va &eacute;muler la 
pression sur ce bouton.


Piner Le nag :)
~~~~~~~~~~~~~~


Donc, voici une m&eacute;thode qui marche souvent, pour &eacute;muler la pression d'un
bouton... Vous avez juste besoin d'un &eacute;diteur hexad&eacute;cimal (moi j'utilise hex workshop).
Donc, vous lancez WinRAR encore et regardez le caption du bouton : Close
puis ouvrez WinRAR avec un &eacute;diteur hexa et recherchez en hexa: 43006C006F0073006500
43006C006F0073006500 =
C   l   o   s   e

donc vous recherchez la valeur hexa de chaque Caract&egrave;res, plus 00 entre chaque valeur.
Vous devez arrivez ici :


4600 0E00 0100 FFFF 8000 4300 6C00 6F00    F.........C.l.o.   <== C l o s e  ici !!! heh
7300 6500 0000 0000 0000 0150 0000 0000    s.e........P....
9500 4300 4600 0E00 0900 FFFF 8000 2600    ..C.F.........&.
4800 6500 6C00 7000 0000 0000 0700 0050    H.e.l.p........P
0000 0000 0400 0400 8B00 4D00 FFFF FFFF    ..........M.....
8000 0000 0000 0000 0000 0250 0000 0000    ...........P....
0900 1000 8200 3700 FFFF FFFF 8200 5000    ......7.......P.
6C00 6500 6100 7300 6500 2000 6E00 6F00    l.e.a.s.e. .n.o.



Donc, voil&agrave; vous &ecirc;tes &agrave; la bonne place, now pour &eacute;muler, vous avez juste &agrave; regardez le
FFFF82 ou FFFFFFFF82  le plus proche et changer le 82 en 7E !!!


donc :

4600 0E00 0100 FFFF 8000 4300 6C00 6F00    F.........C.l.o.   
7300 6500 0000 0000 0000 0150 0000 0000    s.e........P....
9500 4300 4600 0E00 0900 FFFF 8000 2600    ..C.F.........&.
4800 6500 6C00 7000 0000 0000 0700 0050    H.e.l.p........P
0000 0000 0400 0400 8B00 4D00 FFFF FFFF    ..........M.....
8000 0000 0000 0000 0000 0250 0000 0000    ...........P....
0900 1000 8200 3700 FFFF FFFF 8200 5000    ......7.......P.    <== ici tu vois FFFFFFFF82 !!!
6C00 6500 6100 7300 6500 2000 6E00 6F00    l.e.a.s.e. .n.o. 



COOL !! L&agrave; tu es &agrave; la bonne place, donc tu remplaces le 82 par un 7E
et hop le nag a mouru ;)
Donc :

0900 1000 8200 3700 FFFF FFFF 8200 5000    ......7.......P.

		devient :


0900 1000 8200 3700 FFFF FFFF 7E00 5000    ......7.....~.P.


Tu saves ton fichier WinRAR, le relance et plus de nag du tout :)
Si tu remets la date en arri&egrave;re, toujours pas de nag, donc Voil&agrave; c'est termin&eacute;.
Conseil: Ils auraient d&ucirc; fermer le prog une fois le temps d&eacute;pass&eacute;! Ca aurait forc&eacute; le
cracker &agrave; jouer un peu plus et cracker le time limite !
Pour le reste des protections, c'est tres simple ! Avec ce que vous avez d&ucirc; lire
avant d'arriver ici, vous ne devriez pas avoir de probl&egrave;mes !



On va passer &agrave; un autre type de Nag Screen !! Les messagebox.
C'est tr&egrave;s chiant, mais quand on voit &ccedil;a !! On est quand m&ecirc;me content car &ccedil;a se vire
en 10 secondes ;)

Les messageboxes se reconnaissent gr&acirc;ce &agrave; leurs ic&ocirc;nes d&eacute;j&agrave; !
Les ic&ocirc;nes que l'on voit dans Windows avec comme signe: le point d'exclamation,
la croix blanche sur rond rouge.... et un message l'accompagnant !!

Comment cracker &ccedil;a ? Bien je vais montrer 2 fa&ccedil;ons!!

- Avec W32Dasm (cracker like a wanker):

Vous lancez votre programme et vous voyez le message qui nous dit:

"Version Shareware! please Register" ou un truc chiant du style !!
Pour virer &ccedil;a, vous ouvrez W32Dasm et d&eacute;sassemblez le fichier du programme!
Vous faites un tour dans les String Data References &agrave; la recherche de cette phrase!
Vous allez la trouver avec 98 % de chances !!
Donc vous double-cliquez sur cette phrase et recherchez au dessus d'un saut conditionnel
qui vous fait atterrir sur le nag ou au contraire le sauter !!
ET vous le nopez ou forcez a sauter en fonction de ce que vous trouvez !!

ex:

JE	00406280
.................

Possible String Data Reference BLABLA to: Please Register Now !...


XXXX:00406280  PUSH 00
XXXX:00406282  PUSH 004062E0                  ;"Register!"
XXXX:00406287  PUSH 00406360                  ;"Please Register Now!!.."
XXXX:0040628C  PUSH 00                       
XXXX:0040628E  CALL [USER32!MessageBoxA]

....................


Ici, si ce "je" nous am&egrave;ne &agrave; tout les coups sur le message d'erreur, on le NOP
et il ne sautera plus jamais !
Ceci est un exemple mais &ccedil;a ressemble &agrave; &ccedil;a en gros.
C'est pas tr&egrave;s clean, et &ccedil;a fait branleur mais bon :)
Plus &ccedil;a va vite et plus vous &ecirc;tes content je pr&eacute;sume ....


- Avec Soft-ice:


Avec Soft-ice on va tout simplement poser un BPX sur MessageBoxA!
Donc Ctrl+D et tapez votre BPX!
Lancez le programme et Soft-ice break! Pressez F12 et vous retournez sous
Windows !! L&agrave; vous clickez sur le bouton OK du nag et vous vous retrouvez sous
Soft-ice encore une fois !!
Juste au dessus de votre emplacement actuel vous devez voir le Call qui appelle
le messageBox !! 
On peut cracker comme un bourin en nopant ce call, mais &ccedil;a fait pas tr&egrave;s pro,
le mieux c'est de foutre un RET juste apr&egrave;s &ecirc;tre entr&eacute; dans le CALL..

Petit exemple th&eacute;orique:


XXXX:00406280  PUSH 00                        
XXXX:00406282  PUSH 004062E0                  ;"Register!"
XXXX:00406287  PUSH 00406360                  ;"Please Register Now!!.."
XXXX:0040628C  PUSH 00
XXXX:0040628E  CALL [USER32!MessageBoxA]       <--- ici on fait F8


Apr&egrave;s avoir fait le F8 on voit un truc comme &ccedil;a :

025F:00401510  FF253C324000        JMP     [USER32!MessageBoxA]   <-- le F8 nous m&egrave;ne ici
025F:00401516  FF2540324000        JMP     [USER32!MoveWindow]
025F:0040151C  FF2544324000        JMP     [USER32!DialogBoxParamA]
........................

Apr&egrave;s avoir fait le F8, on est donc sur un JMP qui va appeler le MessageboxA .
Donc sur cette ligne vous faites:

A {enter}
RET {Enter}
{echap}


Le programme arrive et prends le RET et sort de cette routine en 2 temps 3 mouvements!
et hop il continue sa route sans jamais afficher aucune connerie !
Ensuite vous faites la modif dans l'ex&eacute;cutable lui-m&ecirc;me et on en parle plus :]

Je vais expliquer Rapidement une m&eacute;thode qui utilise un BPX qui est tr&egrave;s rarement
utilis&eacute; pour cracker les Nags, mais plut&ocirc;t dans les names / serials !
Mais c'est un plaisir de l'utiliser dans les programmes &eacute;crits en Delphi par exemple !
Le BPX est : hmemcpy

M&eacute;thode th&eacute;orique:

Vous mettez ce BPX et vous lancez le programme en Delphi &agrave; cracker!
Soft-ice break! Vous pressez F5 le nombre de fois qu'il faut pour obtenir le NAG screen
et vous comptez le nombre de F5 qu'il vous a fallut bien s&ucirc;r!!
On va dire: 14 fois F5 pour voir le nag !!
Alors on relance le programme et on fera F5 le nombre de fois que vous avez trouv&eacute;
moins 1 !! (14 - 1 = 13 ici)
On presse 13 fois F5 ici !! Ensuite on presse F12 pour revenir dans l'ex&eacute;cutable
et quitter ces dlls &agrave; la con :=)
Apr&egrave;s avoir fait &ccedil;a, vous tracez comme un dingue avec F10 et vous allez arriver sur une s&eacute;rie
de CALL , MOV , CALL , MOV ....
Ca se voit tout de suite, il y a quasiment que &ccedil;a !!
Et l&agrave; vous mettez un BPX &agrave; l'emplacement o&ugrave; cette routine commence et vous tracez avec
F10! Le NAG screen va appara&icirc;tre en passant sur un call normalement !! Vous rep&eacute;rez
quel CALL c'est et puis vous lui mettez un bpx une fois avoir d&eacute;sactiv&eacute; tout les autres!
Vous breakez dessus! Premi&egrave;re fa&ccedil;on bourin: on nope le call comme un goret ;)
On a de la chance &ccedil;a marche !! KeWl !!
Alors on peut entrer dans le Call avec F8 et mettre un ret sur le Push ebp qui doit
s'y trouver!! (c'est pas tjs un Push ebp ;p)
On presse F5 et si le nag est parti et que &ccedil;a ne crash pas, c'&eacute;tait le bon endroit !!
Si tout &ccedil;a a amen&eacute; &agrave; un m&eacute;chant crash :-/ , il vous faut apr&egrave;s avoir entr&eacute; ce call
chercher un autre call qui affiche le nag &agrave; l'int&eacute;rieur !!
et le noper !!
Si le nag est avec timer, on doit trouver un CALL GETTICKCOUNT pas loin de celui-ci
non plus !! Cette API est souvent utilis&eacute;e pour &ccedil;a ;)

On peut aussi utiliser L'API: Destroywindow qui nous am&egrave;ne dans Soft-ice apr&egrave;s avoir
tu&eacute; le nag ! L&agrave; on presse F12 et on regarde les calls plus haut et on retrouve
souvent les calls et les movs de tout &agrave; l'heure qui sont si charmants, lol.
Bref, cette technique, je ne l'ai jamais vu dans aucun cours en fran&ccedil;ais ou bien
US, mais elle permet de cracker un nag Delphi en 2 mins sans se faire chier &agrave; tracer
comme un dingue jusqu'&agrave; trouver LE CALL !!

Sinon, voici une liste d'API utilis&eacute;es dans le cracking des nags screen:


pour tout ce qui est messagebox:

MessageBox
MessageBoxA
MessageBoxExA
MessageBeep   

ou encore ceci pour afficher du texte!

SENDMESSAGE
WSPRINTF


et pour les g&eacute;n&eacute;rations de fen&ecirc;tre:

createwindow
createwindowexa
showwindow


Voil&agrave;, je pense que vous avez d&eacute;j&agrave; de quoi cracker pas mal de nags screen &agrave; la con!
La plus part du temps c'est : Posez le BPX, tracez, trouvez le CALL, killez le !
et on ne reparle plus du NAG !!

</pre>
<font size="+2"><a name="keyfile"><b><u>Keyfile</u></b></a></font><br>
<br>
<pre>

Qu'est ce qu'un keyfile ?
C'est un fichier licence que l'on place dans le r&eacute;pertoire courant du programme
pour l'enregistrer !
On a donc rien &agrave; entrer comme un name / serial!
On n'utilise pas les m&ecirc;mes API mais surtout l'API CreateFileA.
Je vais montrer un exemple:

******************************** 
* termial Cilla's CrackMe 1.0  *
********************************

Je vous pr&eacute;viens de suite, ce crackme contient une protection par Key file, qui
est tr&egrave;s simple, mais que je consid&egrave;re bien pour le sujet d'un cours g&eacute;n&eacute;ral !
Je ne vais pas vous faire un cours sur un keyfile qui est trop long et qui va vous
perturber !!

Le crackme a besoin d'un fichier keyfile, ici il s'appelle TC1.key .

Je cr&eacute;e un fichier keyfile &agrave; la con contentant le texte: 
"ACiD BuRN 4 EVER Ph34rs        "

Si on &eacute;dite en hexa on obtient ceci:

00000000:  41 43 69 44 20 42 75 52 4E 20 34 20 45 56 45 52 
00000010:  52 20 50 68 33 34 72 73 20 20 20 20 20 20 20 20   

Lancez le crackme et on voit qu'il y a un bouton pour checker le keyfile !!
Un open box appara&icirc;t si vous clickez dessus et vous dit de choisir un fichier, ok on va le
faire l'ami :)
Tout d'abord mettez un BPX sur createfilea et quittez Soft-ice avec F5 !
Ensuite il vous suffit de choisir le fichier et Soft-ice revient de plus belle !
Pressez F11 et vous devriez voir le code suivant:


  :0040461F    CALL    KERNEL32!CreateFileA
  :00404624    CMP     EAX,-01                   ; Est-ce que le fichier existe ?
  :00404627    JZ      00404652                  ; si il n'existe pas &ccedil;a saute
  :00404629    MOV     [EBX],EAX
  :0040462B    POP     EDI
  :0040462C    POP     ESI
  :0040462D    POP     EBX
  :0040462E    RET                               ; tout est ok! on sort d'ici!

On a notre fichier, donc le test est ok ! On continue &agrave; tracer avec F10 on passe le RET
et on trouver un code du genre:



  :00429D93    CALL    00402618
  :00429D98    JMP     00429DB4
  :00429D9A    LEA     EDX,[EBP-01]
  :00429D9D    LEA     EAX,[EBP-0150]
  :00429DA3    CALL    004044E8
  :00429DA8    CALL    00402618
  :00429DAD    XOR     EAX,EAX                 ; EAX = 0
  :00429DAF    MOV     AL,[EBP-01]             ; Prends le caract&egrave;re du keyfile (dans ebp-1)
  :00429DB2    ADD     EBX,EAX                 ; additionne la valeur &agrave; EBX
  :00429DB4    LEA     EAX,[EBP-0150]
  :00429DBA    CALL    00404494
  :00429DBF    CALL    00402618
  :00429DC4    TEST    AL,AL                   ; On a fait toutes les lettes ?
  :00429DC6    JZ      00429D9A                ; non ? alors on saute sinon on continue
  :00429DC8    LEA     EAX,[EBP-0150]
  :00429DCE    CALL    00404458
  :00429DD3    CALL    00402618
  :00429DD8    CMP     EBX,000020A9            ; La somme des caract&egrave;res = 20A9h ?
  :00429DDE    JNZ     00429DEE                ; Si c'est &eacute;gal alors le keyfile est valide 


La somme de mon fichier fait: 794h
Ce n'est pas &eacute;gal &agrave; 20A9h donc le keyfile n'est pas valide!!
On va rectifier &ccedil;a !! 20A9h - 794h = 1915h
Il nous faut donc ajouter 1915h &agrave; notre keyfile! On va ajouter des FFh (255)

Je n'ai plus le keyfile sous la main, mais je pense que vous avez compris comment &ccedil;a marche !
Alors je vous laisse vous amuser !!



Sinon, le keyfile le plus petit possible est :



00000000:      FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00000010:      FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF FF
00000020:      C9


Il n'y a aucun texte dans cette keyfile, on retrouve juste la somme n&eacute;cessaire: 20A9h
Alors amusez vous &agrave; faire votre propre keyfile et si vous n'avez pas compris comment
faire, essayez de compl&eacute;ter mon keyfile :)

Voil&agrave;, la partie keyfile fut br&egrave;ve !
Il existe un crackme un peu plus compliqu&eacute; mais tr&egrave;s int&eacute;ressant &agrave; essayer:
Cruehead Crackme 3 ! 
Il est toujours simple, mais plus fin &agrave; cracker ;)
Vous devez l'essayer, et pourquoi par faire un keymaker !
Il existe d'autres crackme utilisant les keyfiles! Alors vous pouvez vous entra&icirc;ner
si vous avez du mal!
Note: N'essayer pas de cracker CuteFTP juste apr&egrave;s avoir lu ce cours, si vous n'avez jamais
      crack&eacute; de keyfiles de votre vie! C'est un conseil ....

</pre>
<font size="+2"><a name="cdcheck"><b><u>CD Check (les BPX, et techniques diverses...)</u></B></a></font><br>
<br>
<pre>

Alors l&agrave;, c'est la partie cracking jeux!!
Qu'est qu'un CD check ? 
Un CD check est la d&eacute;tection du CD dans le lecteur pour &eacute;viter aux petits
pirates en herbes de copier les jeux sur leur disque durs pour y jouer
sans CD :)
lol!! Il y a bcp de jeux prot&eacute;g&eacute;s par CD check mais bon, les 3/4 on se pisse
de rire!!
La protection actuelle qui calme les "petits" crackers est CDilla,
cette protection est en effet d'un niveau &eacute;lev&eacute; par rapport aux protections
que l'on trouve dans: Quake 2, Formula 1, King Pin et bcp d'autres !!
Mais, je vais vous montrer comment cracker les 2 avant-derni&egrave;res protections
de CDilla !! N'ayant aucun jeux originaux (hehe, no way ) je n'ai pas pu
tester la toute derni&egrave;re version encore, qui est soi-disant plus dure;)
Je vais aussi vous parler des protections commerciales !
Mais je ne vous d&eacute;crirais que CD Lock et CDilla ! Il existe de nombreux cours
sur securom, et autres protections CD commerciales !
J'&eacute;cris pas un roman lol

Alors nous allons commencer par les protections TRES TRES simples !!


Les CD check de bases:

*** Avec W32Dasm: *****

Comme exemple on va prendre Formula 1:
Il contr&ocirc;le si il y a le CD du jeu et si ce n'est pas le cas il refuse 
de se lancer.
Apr&egrave;s avoir install&eacute; le jeu on le lance (apr&egrave;s avoir retiré le CD !!!)
Et un message appara&icirc;t "Formula 1 CD NOT Found". Il n'en faut pas plus
pour le cracker.
Prenez W32Dasm et d&eacute;sassemblez le fichier ex&eacute;cutable, en l'occurrence
F1win.exe.
Cherchez dans String Data References (Menu "Refs") de W32Dasm et recherchez
la phrase. On trouve ça quelques lignes avant le message d'erreur :



00409AC3 FF5234         call [edx+34]
00409AC6 85C0           test eax, eax
00409AC8 7D50           jge 00409B1A

L&agrave; il y a un test qui ne nous envoie pas au jeu si il ne trouve pas le CD,
donc on place des NOP et il n'y a plus aucun Test et le jeu se lance
quoi qu'il arrive. Cela donne :


00409AC3 FF5234         call [edx+34]
00409AC6 90             nop
00409AC7 90             nop
00409AC8 7D50           jge 00409B1A

Donc pour le cracker il faut rechercher avec un &eacute;diteur hexadécimal
la cha&icirc;ne FF 52 34 85 C0 7D 50 et la remplacer par FF 52 34 90 90 7D 50
c'est tout.



2&egrave;me exemple : Quake 2 v3.14

Apr&egrave;s avoir install&eacute; le jeu ou apr&egrave;s avoir mis le patch 3.14,
quand on lance Quake 2 sans le CD dans le lecteur, il marche jusqu'au
menu puis lorsqu'on lance une nouvelle partie boum! Le message
"You must have the Quake 2 CD in ..." 

On d&eacute;sassembles le fichier avec W32Dasm puis on cherche dans String Data References 
le message "You must have the Quake 2 CD in ..." 
Bcp de jeux utilisent cette connerie de message !! (ils sont rares de nos jours
cependant!)

Vous marquez "Please insert the XXX CD" (vous cherchez cette phrase dans 
String Data References.)
Apr&egrave;s avoir trouv&eacute; cette phrase dans String Data References, clicker 2
fois dessus, cela vous am&egrave;nera au d&eacute;sassembler &agrave; la ligne du message.
Remontez un peu avec la barre de d&eacute;filement, vous trouverez juste au
dessus:

E82BFFFFFF     call 0042F520
803800         cmp byte ptr [eax], 00
750F           jne 0042F609

L&agrave; on voit un petit "750F" qui repr&eacute;sente le "Jne" (celui dont je vous
parlais au d&eacute;but), il repr&eacute;sente un saut si ce n'est pas &eacute;gal. Donc si
il n'y a pas le CD dans le lecteur, ce n'est pas "&eacute;gal au CD" donc le
programme saute au message d'erreur et le jeu ne marche pas!
On va noper ce con de saut !!

Le code devient:

E82BFFFFFF     call 0042F520
803800         cmp byte ptr [eax], 00
90	       nop
90	       nop

Et c'est partie !! Les CD checks de ce type!!: That's bullshits !

Donc pour cracker d&eacute;finitivement le jeu on cherche la cha&icirc;ne
Hexad&eacute;cimale suivante avec un &eacute;diteur Hexa du style HexWorkshop, Hedit. 
La cha&icirc;ne :  FF FF 80 38 00 75 0F et la remplacer par FF FF 80 38 00
90 90.
Fermez W32Dasm et lancez Quake 2. Bingo le jeu marche c'est cool!

Vous allez me dire !! Ca marche que sur les vieux jeux &ccedil;a ;PP
Alors comme autre Exemple: KingPin version Fr

***************
*** KingPin ***
***************



Cracking part:

Qd vous lancez le jeu avec un CD grav&eacute;, on voit les super (lol) messages:
You must have the KingPin CD in the drive to play...

Hahah, j'adore ce genre de conneries!
Lancez W32Dasm et d&eacute;sassemblez le jeu!

Allez dans les References et cherchez la phrase du jeux!
Double click dessus et on ne voit rien de super! donc on re-double click dessus !
Et cette fois-ci!! On trouve qq chose de bien :


* Referenced by a CALL at Address:
|:0043D5F1                                                       <== hoho :))
|
:00442030 56                      push esi
:00442031 E84AFFFFFF              call 00441F80
:00442036 8BF0                    mov esi, eax
:00442038 85F6                    test esi, esi
:0044203A 750E                    jne 0044204A

* Possible StringData Ref from Data Obj ->"You must have the KINGPIN CD in "
                                        ->"the drive to play."
                                  |
:0044203C 68C8414500              push 004541C8                   <== on arrive ici
:00442041 50                      push eax
:00442042 E859D7FDFF              call 0041F7A0
:00442047 83C408                  add esp, 00000008



Donc, nous voyons le message d'erreur et un petit jne juste avant !!
Mais bon, remplacez un je en Jne et autres, &ccedil;a fait branleur !!!
R&eacute;fl&eacute;chissons un peu ;)

On a vu :

* Referenced by a CALL at Address:
|:0043D5F1 


Donc avec W32Dasm on va regarder ce call !!
Allez dans le menu "Goto" et clickez sur "goto code location" et entrez : 43D5F1
Maintenant on arrive ici:


:0043D5E5 A184274900              mov eax, dword ptr [00492784]
:0043D5EA 83C40C                  add esp, 0000000C
:0043D5ED 85C0                    test eax, eax
:0043D5EF 7505                    jne 0043D5F6

* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:0043D5D2(U)
|
:0043D5F1 E83A4A0000              call 00442030           <== get the fuck outta here!

* Referenced by a (U)nconditional or (C)onditional Jump at Addresses:
|:0043D51F(U), :0043D532(C), :0043D55A(U), :0043D5BA(C), :0043D5D0(C)
|:0043D5EF(C)


Hehehe, voil&agrave; !! C'est ce call de merde qui appelle la routine de CD check !
On va le noper et il nous tanera plus !! Promis.

Clickez sur ce call, en bas de la fen&ecirc;tre de W32Dasm, vous devez voir offset : 3D5F1
Lancez votre &eacute;diteur hexa et allez &agrave; cet offset !
On remplace E83A4A0000 par 9090909090.

Enregistrez le fichier et lancez le ;)

Choisissez new game, et WOW !! Le jeu marche *grin* !
Piece of cake !!
On vient de cracker King Pin ! Un jeux super r&eacute;cent mais avec une protection 
de merde :) (tant mieux hehe, vous allez voir CDilla, c'est autre choses)
Voil&agrave;, c'est fini pour les CD checks de bases avec W32Dasm !


**** CD check avec Soft-ice *****


Voici un exemple Tr&egrave;s simple de CD check !
Mais cette fois-ci on utilise Soft-ice (my love)

Le but du crackme et de faire afficher le message de bon CD qd on a pas un
seul CD dans le lecteur :)

On le lance sans CD, on click sur le bouton et une messagebox de merde
arrive !! mouahah
Les BPX les plus utilis&eacute;s dans le CD checks sont: GETDRIVETYPEA et 
GETVOLUMEINFORMATIONA !!

Mettez un bpx sur GETDRIVETYPEA et clickez sur le bouton! Pressez F12 tant que l'on
est pas &agrave; la bonne place !!

Vous devriez voir qq chose comme &ccedil;a:


025F:00401032  83F805              CMP     EAX,05           <--- c'est un CD ?
025F:00401035  75DC                JNZ     00401013
025F:00401037  6A00                PUSH    00
025F:00401039  6A00                PUSH    00
025F:0040103B  6A00                PUSH    00
025F:0040103D  6A00                PUSH    00
025F:0040103F  6A00                PUSH    00
025F:00401041  6A20                PUSH    20
025F:00401043  68F7214000          PUSH    004021F7
025F:00401048  685A224000          PUSH    0040225A
025F:0040104D  E85E000000          CALL    KERNEL32!GetVolumeInformationA
025F:00401052  0BC0                OR      EAX,EAX
025F:00401054  74BD                JZ      00401013          <-- JMP BAD CRACKER
025F:00401056  6A00                PUSH    00
025F:00401058  685F224000          PUSH    0040225F
025F:0040105D  6A00                PUSH    00
025F:0040105F  6A00                PUSH    00
025F:00401061  685A224000          PUSH    0040225A



Ok, c'est trop simple, il compare la valeur d'EAX avec 5!
Hmm pourquoi 5 ?
Voici un petit tableau des diff&eacute;rents type de lecteurs et leurs r&eacute;f&eacute;rences:

La valeur dans EAX veux dire:

     0                 Lecteur ind&eacute;termin&eacute;
     1                 R&eacute;pertoire sur la racine n'existe pas
     2                 Disque removable
     3                 Disque dur 
     4                 Remote Drive(Network)
     5                 CD ROM
     6                 RamDisk

Donc le crackme ici compare EAX avec 5 ! Donc il veut un CD ROM arff
sinon il saute!!


025F:00401032  83F805              CMP     EAX,05          
025F:00401035  75DC                JNZ     00401013        <-- on NOP &ccedil;a

On nop &ccedil;a ! Et plus jamais de probl&egrave;mes avec &ccedil;a hehehe !!
On ouvre le crackme avec un &eacute;diteur hexa, on cherche 83F80575DC et on remplace par
83F8059090.
Apr&egrave;s ce contr&ocirc;le de type de disque, on voit un  "CALL    KERNEL32!GetVolumeInformationA"
Hehe, une API souvent utilis&eacute;e par les CD checks!

Ca ressemblais &agrave; &ccedil;a:

025F:0040104D  E85E000000          CALL    KERNEL32!GetVolumeInformationA
025F:00401052  0BC0                OR      EAX,EAX
025F:00401054  74BD                JZ      00401013          <-- Jump to bad boy



Encore une fois ! On NOP le saut conditionnel et le CD is no more :)
Ben voil&agrave;, c'est fini, je ne vais pas faire un roman non plus sur les CD checks ehehe

********************************************
**  CD CHECKS: PROTECTIONS COMMERCIALES:  **
**                                        **
**       CD LOCK: TOMB RAIDER 3 FR        **
********************************************

Vous êtes s&ucirc;rement beaucoup &agrave; vouloir Tomb Raider III mais ce jeu est protégé
contre la copie ! Enfin, en th&eacute;orie !!!!
Tout d'abord nous allons voir la protection. Un CD Vierge ne peut contenir que 650 Mo
de données et le CD original de Tomb Raider III contient 3 Go de données ?!
Oui en fait il y a 4 fichiers qui font 600 Mo chacun : Awcs.afp ; Neir.afp ; Oket.afp et
Vfaw.afp . Pour Pouvoir le graver il faut d'abord copier tous les fichiers du CD sur le 
disque dur, sauf les 4 cités plus haut. Ensuite cr&eacute;er 4 fichiers avec le m&ecirc;me nom avec un
caract&egrave;re dedans pour que le fichier fasse 1 octet. Maintenant on grave le CD sans probl&egrave;me
mais le jeu ne marchera pas car il est encore prot&eacute;gé !!! Et c'est là qu'intervient le
cracking!

Nous sommes en pr&eacute;sence d'un CD Check (contr&ocirc;le du CD) et le jeu nous affiche le message
" Tomb Raider III CD ?" malgré la pr&eacute;sence du CD Gravé.
Si vous avez lu le premier cours, vous vous dites comme moi, on va le d&eacute;sassembler et chercher
cette phrase dans String Data References. Le probl&egrave;me c'est que l'on ne trouve pas cette phrase,
donc il suffit de r&eacute;fl&eacute;chir un tout petit peu.
Il y a 4 fichiers qui ne servent à rien donc on va chercher le nom de l'un d'eux dans
les String Data References. On voit d:\Awcs.afp , d:\Neir.afp , d:\Oket.afp et d:\Vfaw.afp. 
 


Donc on double-click dessus et on retourne dans W32Dasm, juste au code source de cette r&eacute;f&eacute;rence,
on remonte avec les barres de d&eacute;filement et on trouve:

	test edi, edi
	jne 0048D2CE

* Possible string data reference from Obj ->"rb"

	Push 004C7AD4

* Possible string data reference from Obj ->"d:\AWCS.AFP"
.......



Le Jne (Jump if not equal) fait le saut s'il ne trouve pas le fichier de 600 Mo donc on le
change en je (jump if equal) et le programme ne saute que si il trouve le fichier. Il peut
toujours chercher !!! Donc maintenant on ouvre le fichier Tomb3.exe avec un &eacute;diteur hexad&eacute;cimal,
on cherche la cha&icirc;ne 85FF756568D4 et on la remplace par 85FF746568D4 .
Et on enregistre le fichier. Le jne 0048D2CE est devenu Je 0048D2CE.
Maintenant on refait la m&ecirc;me chose avec les autres fichiers.(d:\Neir.afp , d:\Oket.afp et
d:\Vfaw.afp)
Les 2 premiers seront casi-identiques mais on ne trouvera pas la m&ecirc;me chose au fichier "D:\Vfaw.afp"
C'est normal il n'y a rien à changer. Donc vous avez chang&eacute; :

- pour "Neir.afp":
0F85F9000000   par  0F84F9000000     ===> le 85 (jne) devient 84 (je)
- pour "Oket.afp":
0F85AD000000   par  0F84AD000000     ===> le 85 (jne) devient 84 (je)
- rien pour "Vfaw.afp"

Normalement, vous avez tout chang&eacute; avec l'&eacute;diteur Hexad&eacute;cimal et Sauvegardez. Une fois ceci
fait vous pouvez lancer le jeu avec un CD gravé dans le lecteur !!!
					
					Tomb Raider III is Now Cracked !!!


Voil&agrave;!!
La Protection CD lock est assez stupide en fait !!
M&ecirc;me tr&egrave;s simple &agrave; cracker ! Vous la retrouverez dans Commandos par exemple aussi :)
Pour le cours qui suit sur CDilla, il serait pr&eacute;f&eacute;rable d'aller jeter un oeuil
&agrave; la partie unpacking qui suit ce cours si vous ne connaissez rien en unpacking et 
autres dumping !! Mais si vous &ecirc;tes d&eacute;j&agrave; &agrave; l'aise avec le PE, et que vous vous prenez
pour un 133t Cr4x0R hehe, lisez !! Mais ne pleurez pas si vous ne comprenez rien !!!
Voil&agrave;, let's go


************************************************************************
****                       CDilla : Safe disc                       ****
************************************************************************


      MidTown Madness version Fran&ccedil;aise: Une autre approche sur CDilla   
								 

Outils n&eacute;cessaires:   * CD Original de Midtown Madness
                      * Soft-ice 3.23			 
                      * Soft-ice Tool pour patcher Soft-ice (pour dumper les sections)
                      * HexWorkshop
                      * Frogsice (pour cacher Soft-ice)
                      * ProcDump (comme PE Editor)
                      * Exescope



Introduction:

Salut &agrave; tous, je sais qu'il y a d&eacute;j&agrave; un cours sur Midtown Madness par black check
mais la m&eacute;thode que j'utilise n'est pas la m&ecirc;me que lui...
Je vais expliquer le plus de choses possible et en plus c'est le 1er cours sur
CDilla en fran&ccedil;ais !!!
Il serait pr&eacute;f&eacute;rable de lire le cours de black check avant, et d'avoir quelques
connaissances sur le format PE...


A Mort CDilla:


Apr&egrave;s avoir install&eacute; le jeu, &eacute;ditez le PE du fichier ".icd" avec ProcDump.
(lancez ProcDump, clickez sur PE Editor, allez o&ugrave; se trouve votre fichier ".icd")
Le fichier est : Midtown.icd 

Maintenant, vous devez voir ceci:


		     - Entry Point : 00166C10
		     - Image Base  : 00400000

Ok, nous allons avoir besoin de l'OEP (Original Entry Point) plus tard donc
nous allons le calculer d&egrave;s maintenant.
Pour cela on a besoin de l'Image base et de l'Entry point que l'on obtient avec 
ProcDump : 00400000 + 00166C10 = 566C10  (on les additionnes)


Maintenant, clicker sur le bouton "sections" pour voir toutes les sections du fichier.

On ne va avoir besoin que des valeurs Virtual Offset, Raw Size, et Raw Offset !


- pour la section ".text" :


   Virtual Offset: 00001000 
         Raw Size: 18D78F
       Raw Offset: 600


- pour la section ".Rdata" :


   Virtual Offset: 0018F000
         Raw Size: 14C99
       Raw Offset: 18DE00



- pour la section ".data" :


   Virtual Offset: 001A4000
         Raw Size: 3D8A4
       Raw Offset: 1A2C00



- pour la section ".data1" :


   Virtual Offset: 00314000
         Raw Size: 20
       Raw Offset: 1E0600


- pour la section ".rsrc" :


   Virtual Offset: 00315000
         Raw Size: CB3
       Raw Offset: 1E0800


Nous allons donc dumper toutes les sections du fichier ".icd" except&eacute; la section ".Rdata" 
car, c'est plus compliqu&eacute; pour celle-ci !!

Il faut tout d'abord additionner l'Image base avec le Virtual Offset de toutes les sections:

.text  : 400000 + 00001000 = 00401000
.rdata : 400000 + 0018F000 = 0058F000
.data  : 400000 + 001A4000 = 005A4000
.data1 : 400000 + 00314000 = 00714000
.rsrc  : 400000 + 00315000 = 00715000


Ok, maintenant nous allons dumper les sections...
Pour cela,  mettez un breakpoint sur EOP (566C10 pour ce jeu).
Vous avez s&ucirc;rement remarqu&eacute;, que si vous lancez le jeu avec Soft-ice charg&eacute;,
il vous envois chier, car il y a de l'anti Soft-ice.
CDilla utilise meltice (createfilea) et l'int68h pour d&eacute;tecter Soft-ice.
Le mieux, c'est d'utiliser Frogsice, pour le cacher. J'utilise la version 0.20b, mais
il faut la patcher pour qu'elle cache compl&egrave;tement Soft-ice de la d&eacute;tection par int68h.
Dans le cours de black check on voit qui faut rechercher dans le fichier: FrogSice.vxd

-60 80 7d 1d 43
et le remplacer par :
-C3 80 7d 1d 43

Voil&agrave;, maintenant, plus aucun probl&egrave;me avec la d&eacute;tection de Soft-ice, on va pouvoir
s'occuper des choses s&eacute;rieuses !!
Lancez votre Frogsice (version patch&eacute;e) et lancez le jeu.
Pendant la vid&eacute;o, faites appara&icirc;tre Soft-ice (ctrl+D) et mettez votre bpx sur l'OEP:
Bpx 56CC10 pour ce jeu...

Pressez F5, le jeu continue de se lancer, et quittez-le.
Maintenant relancez-le et Soft-ice breaks sur 56CC10. Si Soft-ice ne break pas, regardez
si vous avez bien mis votre bpx au bon endroit! (tapez bl et vous devez obtenir qq chose
comme &ccedil;a #025F:56CC10)

Donc, Soft-ice break sur l'OEP, vous n'avez plus qu'&agrave; dumper les sections :)

Avant le dump, d&eacute;sactivez tous les bpx (bd *) car on veut pas de merdes dans nos sections
dump&eacute;es ehe !!

Gr&acirc;ce &agrave; Sice Tool, vous avez modifi&eacute; la commande pagein qui vous permettra de dumper... 
La commande pagein fonctionne donc comme ceci pour dumper:

pagein "l'adresse du d&eacute;but du dump" "longueur du dump" "nom du fichier"
Donc dans Soft-ice, tapez:


pagein 401000 18D78F c:\text.bin
pagein 5A4000 3D8A4 c:\data.bin
pagein 714000 20 c:\data1.bin
pagein 715000 CB3 c:\rsrc.bin

Voil&agrave;, nous avons donc nos sections sur le disque dur !!!!


Passons aux choses s&eacute;rieuses !!! : La Section Rdata :


Bon, pour dumper cette section, c'est pas aussi simple =)


Tout d'abord, nous devons trouver l'adresse r&eacute;elle de la fonction de d&eacute;cryptage et pour
cela nous allons tracer dans le call qui appelle dans la section rdata...
Apr&egrave;s que Soft-ice ai stopp&eacute; sur l'OEP, on arrive ici :




00566C10   PUSH    EBP               <-- on stoppe ici sur l'entry point
00566C11   MOV     EBP,ESP
00566C13   PUSH    FF
00566C15   PUSH    005968D0
00566C1A   PUSH    00566724
00566C1F   MOV     EAX,FS:[00000000]
00566C25   PUSH    EAX
00566C26   MOV     FS:[00000000],ESP
00566C2D   ADD     ESP, -5C
00566C30   PUSH    EBX
00566C31   PUSH    ESI
00566C32   PUSH    EDI
00566C33   MOV     [EBP-18],ESP
00566C36   CALL    [0058F14C]        <-- voici notre call, on trace dedans (F8)


Dans le call , on arrive ici :

009A6485     pushad
009A6486     push 00000031              
009A6488     push 00000000       ---> 0 d&eacute;signe les imports kernels, pour les users &ccedil;a sera 1
009A6490     call [9A64A6]       ---> l'adresse r&eacute;elle de la fonction (9A64A6)
009A6496     add esp, 8
009A6499     popad
.......      jmp [XXXXXXXX]


Tracez dans le call et vous allez voir que le jmp [XXXXXXXX] devient jmp [KERNEL32!GetVersion]
Ok, c'est normal, on est sur le bon chemin :o)
Nous allons bient&ocirc;t programmer le Call fixer...
Mais avant tout, nous devons conna&icirc;tre le nombre d'import de Kernels et users qu'il y a dans
le jeu que l'on crack.
Pour cela, plusieurs m&eacute;thodes, on peut d&eacute;sassembler le fichier ".icd" avec W32Dasm
et les compter ou bien tracer avec Soft-ice, mais j'ai utilis&eacute; un programme nommé : EXESCOPE
pour savoir le nombre d'imports...
Donc dans le fichier midtown.icd , j'ai :

- 127 imports pour kernel32
- 42 import pour user32

Ok, nous avons besoin des ses valeurs en hexad&eacute;cimal, car dans Soft-ice on n'utilise pas de 
d&eacute;cimal:

127 = 7Fh
 42 = 2Ah

Ma partie pr&eacute;f&eacute;rée qd on crack CDilla:  Programmer le call fixer.
Nous n'avons pas l'acc&egrave;s en &eacute;criture dans la section Rdata, donc nous allons la d&eacute;placer
dans la section rdata...
Pour coder le call fixer, je commence sur l'entry point, donc il faut r&eacute;activer le bpx
sur l'OEP, et relancer le jeu. Attendez que le jeu stoppe dans Soft-ice.

Maintenant on va d&eacute;placer notre rdata section &agrave; la place de la data section en m&eacute;moire.
Pour faire &ccedil;a, taper :

m "le virtual offset de la section RDATA + l'image base" l "la longueur de RDATA" "le virtual offset de la section DATA"

NOTE: Pour le virtual offset de la section data, utiliser un nombre plus grand, c'est mieux...


5A4000 est notre virtual offset, j'ai utilis&eacute; 5B0000 (Plus grand comme je vous ai dit)

Vous avez donc &agrave; taper:

m 58F000 l 14C99 5B0000

Maintenant, nous allons programmer le call fixer !!

Vous &ecirc;tes donc &agrave; la ligne: 566C10     PUSH   EBP

Ce que nous allons taper va ressembler &agrave; cela:

00 pushad
01 push ebx
02 push 0
04 call [XXXXXXXX]
0A add esp,8
0D mov edx, XXXXXX 
12 cmp eax,[edx] 
14 je 20
16 inc edx
17 cmp edx, XXXXXX + XXXXX
1D jne 12
1F int 03       
20 mov [edx],ecx
22 popad
23 inc ebx
24 cmp ebx, XX  
2A jne 00
2C int 03


C'est partis !!!

Tapez dans Soft-ice: A "et la touche entr&eacute;e"

et programmez :

566C10   pushad
566C11   push ebx
566C12   push 0
566C14   call [009A64A6]            <-- adresse de la fonction trouvé en tra&ccedil;ant dans le call
566C1A   add esp,8
566C1D   mov edx, 5B0000            <-- adresse o&ugrave; nous avons copié notre section .rdata 
566C22   cmp eax,[edx]    
566C24   je 566C40
566C26   inc edx
566C27   cmp edx, 5B0000 + 14C99    <-- adresse o&ugrave; nous avons copié notre section .rdata + rdata size 
566C3D   jne 566C22
566C3F   int 03                     <-- par s&eacute;curit&eacute;, si il ne trouve rien, il stoppe ici
566C40   mov [edx],ecx    
566C42   popad
566C43   inc ebx
566C44   cmp ebx, 7F                <-- Nombre d'API &agrave; r&eacute;parer
566C4A   jne 566C10
566C4C   int 03


Mettez ebx à 0 (R ebx 0) , et votre eip à la ligne  0 (ligne 0 = 566C10 ici, donc: R EIP 566C10)
tapez "i3here on" et pressez F5 pour ex&eacute;cuter le code, normalement on devrait stopper sur 566C4C .
Remettez votre ebx &agrave; 0, changez la ligne 02 (56CC12 ici) en "push 1" et changez la ligne 24 en
'cmp ebx, user_import_number' (2A for us) et remettez votre eip à la ligne 0 (R EIP 566C10). 
Ex&eacute;cuter &ccedil;a encore (F5). Normalement tout est ok, et on doit encore avoir stopp&eacute; sur 566C4C .
Nous pouvons maintenant dumper la section rdata sans crainte car tout est d&eacute;crypt&eacute; :o)

pagein 5B0000 14C99 c:\rdata.bin


Hehe !! Maintenant on va reconstruire un fichier ex&eacute;cutable qui va &ecirc;tre le fichier final.
J'ai essay&eacute; ProcDump pour importer les sections, mais cette merde n'a rien chang&eacute; GRR !
Donc, je l'ai fait &agrave; la main comme un grand ;)
Voil&agrave; comment faire :

En premier faites une copie du fichier ".icd" (Midtown.icd) et renommez-le en ce que vous voulez
mais avec l'extension ".exe" (ex: fuckit.exe)

Ok, lancez HexWorkshop, ouvrez "Damnit.exe", ainsi que le fichier de notre premi&egrave;re section
dumpé :

C'&eacute;tait: c:\text.bin

On va avoir besoin du Raw offset de chaque section, on les trouves au d&eacute;but du cours mais
je vais vous les remettre pour une meilleure compr&eacute;hension:

 for the ".text" section : Raw Offset: 600         size : 18D78F 
for the ".Rdata" section : Raw Offset: 18DE00      size : 14C99
 for the ".data" section : Raw Offset: 1A2C00      size : 3D8A4
for the ".data1" section : Raw Offset: 1E0600      size : 20
 for the ".rsrc" section : Raw Offset: 1E0800      size : CB3

Ok, you got all shits here !! We want to do the 1st section ".text" so :

Dans HexWorkshop, pressez alt+f5, entrez le Raw offset de la section que vous voulez importer
ici : 600 et cliquez sur ok. Allez dans le menu Edit, et cliquez sur "select block"
Entrez la longueur (size) de la section, ici : 18D78F...
Regardez le fichier ouvert (text.bin) et pressez 'ctrl+a' pour tout s&eacute;lectionner..
copiez tout &ccedil;a avec 'ctrl+c'.
Retournez dans la fen&ecirc;tre principale de l'ex&eacute;cutable dans HexWorkshop (damnit.exe), et coller
ce que vous venez de copier dans le presse papier, faites: 'ctrl+v' ou menu Edit et paste.
Enregistrez votre fichier, cool !! Voil&agrave;, c'est fini pour la section '.text', elle est maintenant
d&eacute;crypt&eacute;e!!


Ok, je vais vous montrer l'import d'une autre section et vous ferez les autres de la m&ecirc;me fa&ccedil;on!


2&egrave;me section : Rdata!

Vous pouvez fermer la fen&ecirc;tre 'text.bin', et ouvrez le fichier: 'rdata.bin' avec HexWorkshop.
Retournez dans la fen&ecirc;tre de l'ex&eacute;cutable et pressez 'alt+f5', entrez le Raw offset de la
section rdata: 18DE00.
Cliquer sur le menu Edit, et cliquer sur "select block" entrez la longueur (size) de la
section, ici : 14C99

Regardez la fen&ecirc;tre de rdata.bin , pressez 'ctrl+a' pour s&eacute;lectionner tout et copiez les bytes 
avec 'ctrl+c'... 
Retournez dans la fen&ecirc;tre de l'ex&eacute;cutable (damnit.exe) dans HexWorkshop et collez avec
'ctrl+v' ou avec le menu Edit..

Ok, je pense que vous avez compris maintenant, faites de m&ecirc;me avec toutes les sections 
et enregistrez les modifications dans l'ex&eacute;cutable.

Vous pouvez quitter Frogsice car l'anti Soft-ice n'est plus dans notre nouvel ex&eacute;cutable !!
Virez le CD original de Midtown Madness et lancez 'damnit.exe'.

WOW, le jeu marche, se lance tr&egrave;s rapidement et sans cette merde de fen&ecirc;tre qui nous dit
d'attendre durant la v&eacute;rification du CD.
Le jeux marche superbement bien :o)

Mais pour faire une ex&eacute;cutable parfait, il faut reconstruire le PE en utilisant ProcDump
afin qu'il marche avec tous les OS.

Si vous lancez le jeu sur une autre version de Windows &ccedil;a va planter :(
Allez, on va r&eacute;parer &ccedil;a !!


- Lancez ProcDump (Merci G-RoM :)
allez dans les Options et s&eacute;lectionnez:

[X]Recompute Object Size
[X]Optmize PE Structure

[X] Use actual import infos
et cliquer sur OK

Cliquez sur Rebuild PE, et cherchez notre nouveau fichier (Damnit.exe pour nous)

ProcDump nous fais une valide import table et notre ex&eacute;cutable est PARFAIT :o)
du moins, j'esp&egrave;re hehe !!

Voil&agrave;, je pense que &ccedil;a suffira pour les protections CD !!
On va passer &agrave; autre choses now !! hehehe

</pre>
<font size="+2"><a name="vb"><b><u>Visual Basic</u></b></a></font><br>
<br>
<pre>

Bon je vais vous montrez une paire de tuts sur le VB!!
Comment le keygener, patcher, trouver les serials !! TOUT !!!!

Pourquoi? Parce qu'il n'y a pas beaucoup de tutorial sur le keygening de programmes VB 
donc j'ai voulu en faire ...

Tout abord:

*********************************************
***        Configurer Smart Check         ***
*********************************************

Qu'est-ce que Smart Check ?
C'est un programme qui permet de d&eacute;bugger les programmes &eacute;crits en VB
et il est tr&egrave;s utile en cracking!!
Mais il doit &ecirc;tre configur&eacute; correctement sinon &ccedil;a marche pas !

Pour configurer il suffit juste de cocher quelques cases et apr&egrave;s c'est parti
pour l'&eacute;clate lol !! :)

Voici comment configurer Smart Check:


Dans le menu Program Settings:

- Error Detection: cocher toutes les cases except&eacute; "Report errors immediately".

- Advanced: cocher les 4 premi&egrave;res cases.
  Mais surtout ne pas cocher "Suppress system API and OLE calls" is not "ticked"

- Reporting: s&eacute;lectionner toutes les cases except&eacute; "Report MouseMove events from OCX controls". 


Ensuite dans le menu View, il faut que "argument" soit s&eacute;lectionn&eacute; ainsi que "suppressed error".


Voil&agrave;, maintenant vous allez pourvoir lire la suite du cours !
Mais pour vous aider, je vais vous d&eacute;crire quelques fonctions VB que vous rencontrerez souvent
en Visual Basic !


Fonctions importantes:



* __vbasrtcmp(String:"XXXX",String:"YYYY")returns DWORD:0 

Description:

__vbastrcmp est utilis&eacute; pour comparer des "Strings" comme  "XXXX" et "YYYY" 
Si vous rencontrez &ccedil;a, et que XXXX = votre faux num&eacute;ro de s&eacute;rie, il y a de fortes chances
pour que ce qui se trouve dans YYYY soit le bon serial !!



* Mid(VARIANT:String:"ACiD BuRN", long:1, VARIANT:Integet:1) 

Description:

Prends la lettre dans les "ACiD BuRN" &agrave; l'emplacement 1 en partant de la gauche!
donc ici il prends "A" dans "ACiD BuRN .



* Asc(String:"A") returns Integer:65 

Description:

Prends la valeur ascii de la lettre en DECIMAL
(la valeur ascii de "A" en decimal = 65)



* __vbaVarCat(VARIANT:String:"12", VARIANT:String:"34") returns DWORD:63F974 

Description:

__vbaVarCat est utilis&eacute; pour ajouter des strings ensemble, ce qui nous donne ici: 1234
(12 + 34 = 1234 c'est ajout des strings! pas une addition des valeurs)



* __vbaVarTstEq(VARIANT:XXXX, VARIANT:YYYY) returns DWORD:0 

Description:

__vbaVarTstEq est utilis&eacute; pour comparer des strings aussi !!
Regardez pour __vbastrcomp , le principe est le m&ecirc;me !

Il existe aussi: __vbaVarCmpEq 



* Len(String:"ACiD BuRN") returns LONG:9

Description:

La fonction len sert &agrave; r&eacute;cup&eacute;rer la longueur d'un string! Ici "ACiD BuRN" a pour longueur 9
(9 lettres, l'espace compte aussi)



Les op&eacute;rations de bases tr&egrave;s souvent utilis&eacute;es (keygen) :




* __vbaVarAdd(VARIANT:Integer:10, VARIANT:Integer:15) returns .... (25) 

Description:

Additionne 10 et 15, cela donne: 25




* __vbaVarDiv(VARIANT:Integer:100, VARIANT:Long:2) returns..... (50)


Description:

Divise 100 par 2, cela donne: 50




* __vbaVarMul(VARIANT:String:"100", VARIANT:String:"2") returns ... (200) 

Description:

Multiplie 100 par 2, cela donne: 200




* __vbaVarSub(VARIANT:String:"100", VARIANT:String:"2") returns ... (98)

Description:

Soustrait 2 &agrave; 100, cela donne: 98




* __vbaVarXor 

Description:

Il marche sur le m&ecirc;me principe.. il effectue un XOR entre les valeurs



* MsgBox(VARIANT:String:"She owns Me", Integer:0, VARIANT:String:"Love",VARIANT.....) 

Description:

Sert &agrave; afficher une messagebox avec le message: "She owns Me" avec comme titre: "Love"
L'API en VB pour les messages box n'est pas: MessageBoxA mais : rtcMsgBox



		M&eacute;thode tr&egrave;s utilis&eacute;e pour trouver les serials:


Vous avez entr&eacute; un num&eacute;ro &agrave; la con, et le programme vous a envoy&eacute; chier avec un 
messagebox !
Comment trouver le serial rapidement dans Beaucoup de cas ??!

Facile, il vous suffit d'aller &agrave; la ligne o&ugrave; on voit cette messageBox et de clicker dessus.
Ensuite clicker sur: Show all events et l&agrave; on voit BCP BCP plus d'informations qu'avant,
on descends un peu et on trouve qq chose comme &ccedil;a:


 __vbasrtcmp(String:"112233",String:"Oui_mec_c'est_le_serial")returns DWORD:0 


On voit tr&egrave;s bien que le programme compare "112233" avec le bon serial!
Vous prenez ce que vous trouvez &agrave; la place de "Oui_mec_c'est_le_serial"!
exemple: "AC4VA4EV"

Relancez le programme et entrez &ccedil;a comme serial : AC4VA4EV
Boom Registered!!

Easy, isn't it ?

Pour des choses plus complexes, lisez la suite!

****************
* VB PATCHING: *
****************

       EscapeRC v1.0.1


Description : une VB5 Time_Limit!


tools utilis&eacute;s : - W32Dasm89 (version de base non patchée pour le VB)
                 - hexeditor!


Comme vous pouvez le voir, j'utilise W32Dasm pour du VB !! et m&ecirc;me pas Soft-ice
ou Smart Check !
Comme c'est la version non patch&eacute;e de W32Dasm, on aura aucunes String Data References
!! VB oblige :p
Mais bon!! on a les imports ;) et on va s'en servir hehe!

Donc, lancez le programme apr&egrave;s avoir avanc&eacute; la date du PC en 2001 par exemple..
Boom, on voit une messagebox qui nous dit: Trial period is over, blablabla

Ok, mais les progs en VB n'utilisent pas l'API : messageboxa.
Mais qqchose de similaire: rtcmsgbox

Donc en VB, pour les messagebox, on utilise : Bpx rtcmsgbox (pour vb6 : bpx msvbvm60!rtcmsgbox)
On peut tr&egrave;s bien utiliser Soft-ice, mais on veux aussi innover un peu !! et se servir
de W32Dasm ;)

Lancez W32Dasm, et ouvrez le fichier avec ! (EscapeRC.exe)...
Allez dans les imports et cherchez : rtcmsgbox
Clickez 2 fois car la premi&egrave;re ne contient rien de bien important :)
Vous verrez ceci:

* Reference To: MSVBVM50.rtcMsgBox, Ord:0253h 
Remontez et vous voyez :



* Referenced by a (U)nconditional or (C)onditional Jump at Address:    <== Referenced at 
|:0041FA39(C)                                                              41FA39
|
:0041FB84 B904000280              mov ecx, 80020004
:0041FB89 B80A000000              mov eax, 0000000A
:0041FB8E 894DAC                  mov dword ptr [ebp-54], ecx
:0041FB91 894DBC                  mov dword ptr [ebp-44], ecx
:0041FB94 894DCC                  mov dword ptr [ebp-34], ecx
:0041FB97 8D5594                  lea edx, dword ptr [ebp-6C]
:0041FB9A 8D4DD4                  lea ecx, dword ptr [ebp-2C]
:0041FB9D 8945A4                  mov dword ptr [ebp-5C], eax
:0041FBA0 8945B4                  mov dword ptr [ebp-4C], eax
:0041FBA3 8945C4                  mov dword ptr [ebp-3C], eax
:0041FBA6 C7459C205A4000          mov [ebp-64], 00405A20
:0041FBAD C7459408000000          mov [ebp-6C], 00000008

* Reference To: MSVBVM50.__vbaVarDup, Ord:0000h
                                  |
:0041FBB4 FF158CD34200            Call dword ptr [0042D38C]
:0041FBBA 8D55A4                  lea edx, dword ptr [ebp-5C]
:0041FBBD 8D45B4                  lea eax, dword ptr [ebp-4C]
:0041FBC0 52                      push edx
:0041FBC1 8D4DC4                  lea ecx, dword ptr [ebp-3C]
:0041FBC4 50                      push eax
:0041FBC5 51                      push ecx
:0041FBC6 8D55D4                  lea edx, dword ptr [ebp-2C]
:0041FBC9 6A00                    push 00000000
:0041FBCB 52                      push edx

* Reference To: MSVBVM50.rtcMsgBox, Ord:0253h         <=== vous arrivez ici apr&egrave;s le click

------------------------------------------------------------------------------------


Donc vous avez vu  : Referenced at 0041FA39
Dans W32Dasm, menu goto, et choisissez Code location et entrez : 0041FA39

Vous arriverez ici:


* Referenced by a (U)nconditional or (C)onditional Jump at Address:
|:0041FA24(C)


:0041FA34 66837DEC1F              cmp word ptr [ebp-14], 001F  <== compare avec 1F (31 en d&eacute;cimal)
:0041FA39 0F8D45010000            jnl 0041FB84                 <== un saut conditionnel :)        
:0041FA3F 6830394000              push 00403930

* Reference To: MSVBVM50.__vbaNew, Ord:0000h
                                  |
:0041FA44 FF15E8D24200            Call dword ptr [0042D2E8]
:0041FA4A 50                      push eax
:0041FA4B 6810A04200              push 0042A010




On n'a donc qu'&agrave; patcher ce truc :)
Pour &ecirc;tre s&ucirc;r de ne pas avoir d'ennuis, j'ai patch&eacute; en:

:0041FA34 66837DEC00         cmp word ptr [ebp-14], 00
:0041FA39 0F8445010000       je 0041FB84


Editez le fichier avec votre &eacute;diteur hexa:
- cherchez : 66837DEC1F et remplacez par : 66837DEC00.
- cherchez : 0F8D45010000 et remplacez par : 0F8445010000 



WOW !! Plus de prob de temps :pp facile .........
Voil&agrave;, vous avez une id&eacute;e de comment patcher les progs en VB, avec W32Dasm :)


VB Patching: Avec Smart Check:


Aujourd'hui je vais vous apprendre comment cracker des prog VB avec 3 nags
et un timelimit!!
Je suis sur que vous allez dire "putain c'est dur!"
Hehehe !! J'&eacute;tais en train de tracer avec SI quand j'ai eu une idée...
Je vais vous expliquer en quoi &ccedil;a consiste...




1) Tools requis : - Smart-Check 6
                  - Hex editor
                  - un cerveau =)


2) Comment cracker les nags !!

Bon pour cela on utilisera SC !
Chargez Oyc avec SC et ex&eacute;cutez-le. Clickez sur le nag, attendez
que le bouton OK soit activ&eacute; et ensuite quittez cette app...
Dans SC double clickez sur : frmOYCMain_load et regardez jusqu'à
ce que vous trouviez le ".show" ... dans SC vous verrez:


+ frmStart_Load
+ frmStart.Show
....
....
....
....
....
....
frmShareware_Load
frmShareware.Show



Donc, dans ce cas la chose importante est frmstart.show
A droite de SC vous voyez l'offset o&ugrave; il est situ&eacute; et le fichier.
Pour ce nag, nous voyons qu'il est dans OYC.EXE @ 000FDA4D
Ok!
Je suppose que vous pensez que c'est ce que je voulais vous montrer !!!

Maintenant j'utilise mon cerveau pour virer le nag, parce que je sais
que le nag peut &ecirc;tre appel&eacute; par un call, donc je pense pourquoi n'irions
nous pas &agrave; cet offset et regarder le premier call pr&egrave;s de l&agrave;?

Prenez votre HEXEDITEUR et allez &agrave; l'offset 000FDA4D.
Ok, maintenant vous savez que ce call commence avec : E8h et sa
longueur est de 5 octets...
Apr&egrave;s avoir fait une recherche de ce E8h vous trouvez:
E8986FF0FF :)

Remplacez-le par des NOP (90)... ce qui vous donne:
9090909090

Sauvez (faites un backup on ne sait jamais) et r&eacute;ex&eacute;cutez le programme...
Comme par magie le premier Nag a &eacute;t&eacute; vir&eacute;!!!!!!!
Bien!! hehe
Maintenant on va passer au suivant!
Vous voyez sur la figure ci-dessus qu'il y a un autre ".show"
Proc&eacute;dez de la m&ecirc;me fa&ccedil;on et vous virerez ainsi le timer et le nag!!
Je ne vais pas vous montrer la valeur &agrave; remplacer parce que c'est
exactement la m&ecirc;me que dans le premier nag. Et puis c'est bien
d'avoir des ex. d'application :)

Ok... bon maintenant le dernier nag mais ce sera moins facile que les
autres...
Dans SC, double click sur : "mnuFExit_click" (vous le trouverez
&agrave; la fin du rapport de SC)
Ensuite double click sur "frmOYCMain_Unload" et descendez jusqu'à
ce que vous voyez: "frmEnd.Show". Regardez &agrave; droite et prenez
l'offset : 1001A1
Ok, maintenant vous vous dites, on va faire la m&ecirc;me chose qu'avec les deux autres,
et &ccedil;a va &ecirc;tre ok!
Eh bien non! Ca ne marchera pas!
Ok... j'ai r&eacute;fl&eacute;chi un peu et je me suis rem&eacute;mor&eacute; que vous pouvez
chercher un jump pour virer le nag, et dans les apps VB, je jump
toujours comme &ccedil;a: 0F85 or 0F84 =)
Donc utilisez votre hex&eacute;diteur et allez &agrave; l'offset : 1001A1.
Faites une recherche de "OF" vers le haut. Et nous trouvons:
0F849A000000 ... remplacez-le par 0F859A000000 (je => jne) et sauvegardez!

Maintenant, ex&eacute;cutez &agrave; nouveau!!
Plus de nag! plus de timelimit!
Parfait!


3) Notes:

J'ai &eacute;cris ce tut pour montrer comment on peut patcher les apps VB et que
parfois un cerveau est plus utile que le tra&ccedil;age avec SI (j'ai bien dit : parfois).
Donc, cette fa&ccedil;on de cracker les nags VB ne marche pas &agrave; tous les coups, mais j'ai
r&eacute;ussi &agrave; cracker plusieurs apps VB comme &ccedil;a donc faites pas chier! :)
Si vous voyez que l'offset est dans un DLL genre MSVBVM50 ou MSVBVM60, faites
juste une copie et placez-le dans le r&eacute;pertoire du programme et patchez-le.
De cette mani&egrave;re, le prog utilisera la DLL qui est dans son r&eacute;pertoire et pas
celle du WINDOWS\SYSTEM.
Vous n'aurez comme &ccedil;a pas de probl&egrave;me avec d'autres applications qui utilisent
les DLL... !!!


**********************************
** Dawai 's VB CD check crackme **
**********************************


Infos données avec le crackme:

--------------------------------------------------------

   This is a VB CD-check crackme.
   Patching is allowed, but it
   would be cooler if you could
   tell me what CD the crackme 
   looks for :)

   Dawai

----------------------------------------------------------

I)Qu'est-ce que contr&ocirc;le ce con de crackme ?

tool: Smart Check ( Que vous avez bien configur&eacute; d'apr&egrave;s mon cours )


Si vous lancez ce crackme, vous allez voir &eacute;crit: Welcome
Quand on click sur le bouton check, si ce n'est pas le bon CD, on obtient le 
super message: Unregistered
hmmm.. ok


Lancez Smart Check et ouvrez le crackme avec ! Clickez sur le bouton et fermez le crackme,
vous devez voir: + _click
Double clickez dessus pour voir ce qui se passe la dessous hehe!

On voit une liste de:

GetdrivetypeA (API utilis&eacute;e pour d&eacute;terminer le type de disque et renvoyer 5 si c'est un CD)
Cette API est utilis&eacute;e pour cracker les CD check sur les jeux ...


Sur mon PC, j'ai vu &ccedil;a:

GetdrivetypeA(blabla) UINT: 2
..
GetdrivetypeA(blabla) UINT: 1
..
GetdrivetypeA(blabla) UINT: 3
..
GetdrivetypeA(blabla) UINT: 5
..

On veut cracker un CD check, donc il cherche pour un CD, alors clickez sur celui qui renvoie: 5

Maintenant dans Smart Check clickez sur "show all events".

Ensuite commencez &agrave; scroller vers le bas avec les fl&egrave;ches et regardez dans la fen&ecirc;tre de
droite!

Descendez tant que vous ne verrez pas qq chose qui commence comme &ccedil;a:


W
..
Wi
..
Win
..
Win9
..
Win98
..
Win98 S
..
Win98 SE
..


Hmm ! On dirait qu'il v&eacute;rifie le label de CD hehe.
Mort de rire, descendons un peu pour voir cela de plus pr&egrave;s:


__vbaStrCmp(String:"Win98 SE", String:") returns DWORD: FFFFFFFF

Kewl! Il compare vraiment le label! Je n'avais pas mis de CD donc il compare avec rien
ici !

Cher ami dawai, ton VB CD check crackme v&eacute;rifie le label du CD ROM !
Si c'est: Win98 SE Alors c'est correct (Windows 98 Second Edition)

Mais de toutes fa&ccedil;on, je me sert tjs de mes jeux sans CD! Alors je veux pas avoir de CD
dans le lecteur !
Sux0r :)


II) How to Patch it:

Patcher un prog en Visual Basic est plut&ocirc;t simple quand on sait comment faire...

Donc clickez sur: __vbaStrCmp(String:"Win98 SE", String:") returns DWORD: FFFFFFFF
prenez l'offset dans la fen&ecirc;tre de droite, on voit: CRACKME2!0000CB68

Lancez W32Dasm, et clickez sur le menu goto et prenez goto code location...
Additionnez 400000 a l'offset et on obtient l'emplacement dans W32Dasm ! (400000 = image base)
400000 + CB68 = 40CB68
Entrez &ccedil;a dans Goto Code location

On arrive ici :


* Reference To: MSVBVM60.__vbaStrCmp, Ord:0000h
                                  |
:0040CB68 E89346FFFF              Call 00401200                     <--- ici!
:0040CB6D 8BF0                    mov esi, eax
:0040CB6F 8D4584                  lea eax, dword ptr [ebp-7C]
:0040CB72 F7DE                    neg esi
:0040CB74 50                      push eax
:0040CB75 8D4588                  lea eax, dword ptr [ebp-78]
:0040CB78 1BF6                    sbb esi, esi
:0040CB7A 50                      push eax
:0040CB7B 46                      inc esi
:0040CB7C 8D458C                  lea eax, dword ptr [ebp-74]
:0040CB7F F7DE                    neg esi
:0040CB81 23B534FFFFFF            and esi, dword ptr [ebp+FFFFFF34]
:0040CB87 50                      push eax
:0040CB88 6A03                    push 00000003

* Reference To: MSVBVM60.__vbaFreeStrList, Ord:0000h
                                  |
:0040CB8A E87746FFFF              Call 00401206
:0040CB8F 83C410                  add esp, 00000010
:0040CB92 663BF3                  cmp si, bx
:0040CB95 751F                    jne 0040CBB6             <-- hmm :) int&eacute;ressant!
:0040CB97 6A02                    push 00000002
:0040CB99 5E                      pop esi



Comme on peut le voir, on voit une petite comparaison et juste en dessous un saut conditionnel!

Changez-le jne en jmp !


:0040CB95 751F                    jne 0040CBB6  
			
                   devient

:0040CB95 EB1F                    jmp 0040CBB6  


Faites les modification dans le fichier et sauvegardez!
Relancez le crackme et clickez sur le bouton!  jezuz :) Ca marche heh
REGISTERED
Oh my god , c'&eacute;tait simple :)

*****************************************************************************************
** Pour finir avec le VB: comment r&eacute;activer un Bouton, rendre une fen&ecirc;tre invisible... **
*****************************************************************************************

Boutons:

Pour un bouton on cherche qq chose comme &ccedil;a dans Smart Check:

Command1.Enabled <-- False (Boolean)
Clickez dessus et regardez dans la fen&ecirc;tre de droite sous Smart Check pour r&eacute;cup&eacute;rer
l'offset, on l'ajoute &agrave; l'image base comme j'ai d&eacute;crit plus haut et on va dans
W32Dasm !
On retrouve quelque chose comme &ccedil;a :


6A00                    push 00000000
50                      push eax
8945E4                  mov dword ptr [ebp-1C], eax
FF928C000000            call dword ptr [edx+0000008C]

On voit le Push 00 (false) et on veut r&eacute;activer le bouton, donc il faut mettre en (True)
c'est pas push 01 :P , mais push FF
Donc on remplace &ccedil;a en:


6AFF                    push FFFFFFFF
50                      push eax
8945E4                  mov dword ptr [ebp-1C], eax
FF928C000000            call dword ptr [edx+0000008C]

On sauvegarde le fichier et hop-la, le bouton est enabled !
Notes: des fois on trouve pas de: Command1.Enabled
Pas encore &eacute;tudi&eacute; ce probl&egrave;me yet !
Donc on prends the customizer pour &ccedil;a et on en parle plus :)


Cette m&eacute;thode marche pour activer les : boutons donc, les menus, check box, labels
et autres ... :

Command1.Enabled <-- False (Boolean)
Text1.Enabled <-- False (Boolean)
Label1.Visible <-- False (Boolean)
.....

Ca marche aussi pour cracker un nag screen!

On click sur le form1.visible .... on prends l'offset et on se rend sur les lieux:)
On examine le code! on doit voir un: Push FFFFFFFFF (enabled) donc visible
On le remplace par un Push 0000000 (disabled) donc invisible ...

Et hop-la, finis les probl&egrave;mes de nags screen :)
Bon assez sur le patching en VB sinon on va pas finir hehe
Un peu de serial fishing &agrave; pr&eacute;sent et ensuite du keygening ;)



************************************************************************
**   					Serial Fishing                                **
************************************************************************


*****************************
*** 	MIZ CRACKME 2	  ***
*****************************



Quelles sont les protections? 
Il y a 2 protections dans ce crackme :  

1) anti Smart Check 
2) Serial 
  

1)Comment supprimer la protection anti Smart Check ? 

La protection anti SC est plac&eacute;e au début du crackme 
et quand le crackme est ex&eacute;cut&eacute;, il v&eacute;rifie la pr&eacute;sence de SC avec un 
timer! 
Apr&egrave;s avec regard&eacute; avec SI si l'anti SC &eacute;tait bas&eacute; sur la v&eacute;rification 
de "NMSCWM50" (l'ID de la fen&ecirc;tre de SC), j'ai regard&eacute;
le crackme avec un hex&eacute;diteur pour cette cha&icirc;ne et je l'ai trouv&eacute;e.
Mais si vous ne cherchez que NMSCWM50, vous ne trouverez 
rien parce que c'est un programme VB qui utilise le format WIDE donc: 
w.i.d.e. .c.h.a.r.a.c.t.e.r. .f.o.r.m.a.t 
Regardez cette cha&icirc;ne: 4E004D00530043004D005700350030 en hex
Cool! Vous l'avez trouv&eacute;e! Remplacez par des 0 par exemple et sauvez. 
Maintenant la protection anti SC est &eacute;limin&eacute;e! 
On peut donc ex&eacute;cuter SC dessus!

2) Trouver le serial ! 

Ex&eacute;cutez SC et le prog. Entrez un serial: 123456 et pressez 
"Check Now" puis sortez du programme. 
Retournez dans SC et vous verrez un timer et apr&egrave;s:

label3_Click 

Mais il n'y a rien de bien ici...
Mais quand j'ai vu GetVolumeInformationA , j'ai pens&eacute; que le serial 
d&eacute;pend s&ucirc;rement du PC ! On verra &ccedil;a apr&egrave;s ...

Nous allons essayer de le trouver avec SI parce qu'il n'y rien de bien avec SC! 
On va utiliser bpx __vbastrcomp parce que on le retrouve couramment dans les prog VB!
ctrl + D et tapez bpx __vbastrcomp. F5 pour retourner au programme et tapez: 123456
comme serial.
Cliquez sur check et on est de retour dans SI Cool!!!
Pressez F12 pour sortir du call __vbastrcomp !
Vous devriez voir ESP en couleur et c'est bon signe!
Maintenant tapez dd esp (pour afficher la memoire en esp),
vous voyez: aaaaaaaa bbbbbbbb cccccccc dddddddd 

Essayez de faire  d aaaaaaaa , mais vous ne voyez rien d'int&eacute;ressant alors 
essayez d bbbbbbbb , et vous obtenez une phrase qui n'est pas 
votre serial et vous voyez __vbar8str. 
Hey !! C'est break points ? On va essayer!!
ctrl+D et tapez bc * pour supprimer tous les bpx. 
Tapez __vbar8str puis pressez F5.
Entrez 123456 comme serial et clickez sur check ! 
Cool on est dans SI!!! 
Tapez WF pour afficher la fen&ecirc;tre concernant la pile &agrave; virgule flottante. 
Vous voyez:

ST0 empty ST4 empty 
ST1 empty ST5 empty 
ST2 empty ST6 empty 
ST3 empty ST7 empty 
  

Commencez &agrave; tracer avec F12 pour aller dans la fonction:__vbaR8str ! 
Vous devriez voir: ST0 123456 !! 
Cool, continuez avec F10 et ST0 devient : 892935893 !!! <== qu'est ce que c'est? 
Essayons!! bd * pour d&eacute;sactiver tous les bpx et entrez ce nombre! 
Et la message box appara&icirc;t: Mail the solution to : ...  
Cool crackme Cracked !!! 

Mais attendez, nous voyons dans SC que &ccedil;a d&eacute;pendait du PC avec 
GetVolumeInformationA !! 
Ok, je vais essayer ce nombre sur mon second PC et &ccedil;a ne marche pas!!! 
J'avais donc raison, ce nombre d&eacute;pend de la machine !! 
Donc ce nombre ne fonctionnera pas chez vous, essayez de le trouver 
c'est un bon moyen de savoir si vous avez tout compris!!!


Avant de passer au keygen pure et dure (plus compliqu&eacute; que le premier exemple),
je vais vous montrer 2 fa&ccedil;ons de r&eacute;cup&eacute;rer les serials pour les programmes en
VB 5 ou 6 :)
En effet, il existe une API tr&egrave;s souvent utilis&eacute;e dans les contr&ocirc;les des serials!
--> __vbastrcomp 
Nous allons voir cela de plus pr&egrave;s !

*****************************
***     MIZ CRACKME 3     ***
*****************************


Protections : 
1) Code 
2) Anti SmartCheck  
Il existe un bonne BPX pour les app VB c'est __vbastrcomp! 
Donc on va essayer celui-ci dans Soft-ice! 

Tapez ctrl+D 
puis 
BPX __vbastrcomp 
F5 

nAME: ACiD BuRN 
cODE: 123456 

Entrez serial nom et cliquez sur Check ! 

Nous sommes de retour dans SI gr&acirc;ce &agrave; la BPX! Cool!
Pressez F12 pour sortir du call,
vous devriez voir EBP en couleur! c'est bon signe! 
tapez maintenant:
dd esp (on examine la pile)

Vous devriez voir: aaaaaaaa bbbbbbbb cccccccc dddddddd  

Essayez de faire: 
d aaaaaaaa , et vous ne devriez pas voir des choses int&eacute;ressantes.
donc essayez &ccedil;a:
d bbbbbbbb , et vous obtenez dans mon cas: Oy!iYt^LK 

Ca ressemble &agrave; un code! On va l'essayer... 

nAME: ACiD BuRN 
cODE: Oy!iYt^LK 

et &ccedil;a marche !!!!!!!!


Apr&egrave;s les BPX sur les fonctions couramment utilis&eacute;es en VB, voici une autre m&eacute;thode
simple et rapide pour trouver un serial en VB:

*********************
***    HDMorph    ***
*********************

Il change l'ic&ocirc;ne du disque dur... c'est pas vraiment utile mais 
c'est pas ReGGed!! 
On va s'amuse un peu avec!! 
Tout d'abord, c'est une bonne idée lorsque vous voulez cracker des programmes 
VB de chercher: 

S 0 L ffffffff 56,57,8b,7c,24,10,8b,74,24,0c,8b,4c,24,14,33,c0,f3,66,a7 

NOTE: le mieux &eacute;tant de le mettre dans le WINICE.DAT. 
Alt F4 &eacute;tant rarement utilis&eacute;, vous pouvez l'utiliser comme bon vous semble: 
AF4="^s 0 l ffffffff 56,57,8b,7c,24,10,8b,74,24,0c,8b,4c,24,14,33,c0,f3,66,a7;" 

Ca vous &eacute;vitera de tout retaper... Red&eacute;marrez le PC pour que les changements prennent effet! 
  

Quand c'est fait on peut commencer &agrave; cracker le programme! 

Lancez-le et allez dans register. 
Entrer nAME: ACiD BuRN 
sERIAL: 123456 

ctrl+D 
Soft-ice arrive et tapez 
bpx hmemcpy. 
F5 

Click sur Ok et nous sommes de retour dans SI! Bien!... 

Maintenant tapez F11 et F12 jusqu'à ce que vous voyez MSVBVM50 en bas de la fen&ecirc;tre
de SI.
Nous somme au bon endroit... ALT F4 pour rechercher l'emplacement de comparaison!!
Vous devriez voir:
"search pattern found at XXX:XXXXXXXX".
Chez moi les XXX:XXXXXX sont
25F:7B1DD9EA.
Placez un BPX sur cette adresse et enlevez le bpx hmemcpy (BD 0)
F11 et nous sommes arr&ecirc;t&eacute;s &agrave; cause de 25F:7B1DD9EA .
C'est l&agrave; o&ugrave; il y a la comparaison, on voit: 

: 56 push esi 
: 57 push edi 
: 8B7C2410 mov edi, [esp + 10] ; Move real serial into edi 
: 8B7C240C mov esi, [esp + 0C] ; Move fake serial into esi 
: 8B4C2414 mov ecx, [esp + 14] 
  

Tapez F10 pour passer "mov edi, [esp + 10]" et tapez d edi pour voir le bon serial ! 
pour ACiD BuRN nous voyons: 1.3.0.2.6.8.6.3.0.5.4.4.3.2.0.7.9.2.1.6.3.8.1.3.1.2.1.4.0.4 
Parce que c'est un programme VB nous avons des espaces (nul) entre chaque chiffre.
Donc le bon code est :130268630544320792163813121404
On vérifie:
nAME: ACiD BuRN
cODE: 130268630544320792163813121404

Pressez OK mais rien ne nous dit que c'est le bon serial... Red&eacute;marrez....
Allez dans ABOUT et vous voyez : Registered to: ACiD BuRN 
No comment ;)


****************************************************
**** 		VB KEYGENING:			            ****
****************************************************

*******************************************
*** Eternal Bliss 's Camouflage Crackme ***
*******************************************


Protections : - anti SmartCheck 
              - serial / name 
  
  

1) anti SmartCheck (SC): 

Il y a plusieurs façons de détecter si SC est activé. Je vais vous donner la plus courante: 

Le programme regarde la barre des titres de SC et il trouve: 
"NuMega SmartCheck" 

Puis se ferme tout seul! Merde!

La deuxième façon est de regarder l'ID de le fen&ecirc;tre de SC: NMSCVM50 
Et si il le trouve alors il se ferme aussi tout seul! 

Comment l'&eacute;viter? 
Si vous voulez cracker la plupart des applications avec un anti SC, c'est préférable de
patcher directement l'exécutable SC. Pour cela, utilisez un hexéditeur et 
cherchez NuMega SmartCheck. Ensuite changez-le en ce que vous voulez! 

Pour patcher l'ID de la fen&ecirc;tre, c'est plus difficile parce que vous ne le voyez pas
avec un hexéditeur! 
Vous pouvez utiliser le programme de CyberBlade (un ami): UPK. 

Mais je ne l'ai pas et je vais vous dire comment j'ai fait! 

Tout d'abord, j'ai mis un BPX sur l'API avant le MessageBox qui dit "you are not registered 
blabla...". Ensuite, vous devrez charger le crackme dans SC et l'exécuter!!! 
On retourne dans Soft-ice et vous allez rechercher: 
s 0 l ffffffff 'NMSC' (je n'ai pas recherch&eacute; NMSCWM50... soyez s&ucirc;r que vous trouverez le bon) 
tapez S jusqu'&agrave; ce que vous trouviez NMSCVM50. La premi&egrave;re fois que vous le verrez, r&eacute;&eacute;crivez 
par dessus des 00000000. Hehe, le crackme continue son exécution sous SC!! 
  

2) Comment l'enregistrer?

Clicker sur Register et entrez un nom et un serial au hasard genre 123456 
et cliquez sur "Check It", vous verrez : 
Wrong Try again &agrave; l'emplacement de votre nom... 
Donc ce n'est pas le bon =)!! 

Ok, quittez le crackme et retournez dans SC. 
D'abord, sauvez votre projet, avec File/Save as... 
Parce que je pense que vous ne voudrez pas refaire cette premi&egrave;re partie du tut plusieurs fois! 

Vous verrez command5_click, double click and regardez cette chose int&eacute;ressante: 
Maintenant allez sous SC et regardez votre nom, vous verrez: 

--------------Start of SC cut-------------------------------- 

Mid(varian:byReF String:"ACiD BuRN",long1,VARIANT:Integer:1) 
Asc(string:"A")returns Integer:65 
Trim(VARIANT:Integer:34) 
Mid(varian:byReF String:"ACiD BuRN",long2,VARIANT:Integer:1) 
Asc(string:"C")returns Integer:67 
Trim(VARIANT:Integer:32) 
Mid(varian:byReF String:"ACiD BuRN",long3,VARIANT:Integer:1) 
Asc(string:"i")returns Integer:105 
Trim(VARIANT:Integer:10) 
Mid(varian:byReF String:"ACiD BuRN",long4,VARIANT:Integer:1) 
Asc(string:"D")returns Integer:68 
Trim(VARIANT:Integer:39) 
Mid(varian:byReF String:"ACiD BuRN",long5,VARIANT:Integer:1) 
Asc(string:" ")returns Integer:32 
Trim(VARIANT:Integer:67) 
Mid(varian:byReF String:"ACiD BuRN",long6,VARIANT:Integer:1) 
Asc(string:"B")returns Integer:66 
Trim(VARIANT:Integer:33) 
Mid(varian:byReF String:"ACiD BuRN",long7,VARIANT:Integer:1) 
Asc(string:"u")returns Integer:117 
Trim(VARIANT:Integer:22) 
Mid(varian:byReF String:"ACiD BuRN",long8,VARIANT:Integer:1) 
Asc(string:"R")returns Integer:82 
Trim(VARIANT:Integer:49) 
Mid(varian:byReF String:"ACiD BuRN",long8,VARIANT:Integer:1) 
Asc(string:"N")returns Integer:78 
Trim(VARIANT:Integer:45) 
  

------------------End of Smartcheck cut---------------------- 
  

Regardez maintenant le code : avez-vous trouv&eacute; un truc cool? 

Ici: 

Mid(varian:byReF String:"ACiD BuRN",long1,VARIANT:Integer:1) <= 1er caract&egrave;re 
Asc(string:"A")returns Integer:65 <=== Valeur ASCII -> décimal 
Trim(VARIANT:Integer:34) <=== la valeur de serial?? 

Pourquoi ne pas essayer toutes ces valeurs comme un serial? 
Donc prenez toutes les valeurs pour chaque lettre et &ccedil;a donne: 

Essayons: 
name : ACiD BuRN 
serial : 343210396733224945 

Clickez sur "Check It" et &ccedil;a marche!!!!! Bon on l'a cracké!!! Maintenant je vais vous 
expliquer comment le keygener. 
  

3) Keygen it 
  

Bon... Comment a-t-il trouv&eacute; cette putain de valeur?!!! 
Hehe!! Laissez-moi voir... 
Pourquoi pas un XOR? 
  

Asc(string:"A")returns Integer:65 <== 1st ascii value 
Trim(VARIANT:Integer:34) <== 1st good key 
Asc(string:"C")returns Integer:67 <== 2nd ascii value 
Trim(VARIANT:Integer:32) <== 2nd good key 
..... 
  
Si nous faisons 65 XOR 34 (&agrave; l'aide la calculatrice Windows en mode scientifique) 

Nous trouvons: 99 

hehe !! 
Si nous trouvons la m&ecirc;me valeur avec 67 XOR 32 alors on a de quoi faire un keygen! 
Regardez!! 
67 XoR 32 = 99 ! 
Cool!! On l'a fait!! 

Parce que si nous faisons 67 XOR 99=32 =) La bonne valeur de la cl&eacute;! 
Donc pour faire un bon serial de votre nom vous devrez prendre la valeur 
ASCII de chaque lettre et le XOR 99. Sauvegarder cette valeur et ajouter  
&agrave; c&ocirc;t&eacute; le prochain r&eacute;sultat pour chaque lettre de votre nom!! 

Comment le coder? Voici le code source VB5: 
  

4) Source du Keygen: 
  

--------------Start of the source------------- 

Private Sub Command1_Click() 
For i = 1 To Len(Text1.Text) 
code = Asc(Mid$(Text1.Text, i, 1)) Xor 99 
Text2.Text = Text2.Text & code 
Next i 
End Sub 

----------------End of the source------------- 

Pour le tester, cr&eacute;ez un nouveau projet avec un bouton et 2 textbox .
Double clickez sur le bouton et copiez le code! 
hehe !!

Fini!

Crackme Cracked!! =)

C'&eacute;tait un keygen tr&egrave;s simple &agrave; faire !! Mais il y en a des pires !!!
Vous verrez &ccedil;a bien assez t&ocirc;t !! Croyez moi :)

**************************
* Keygen de Lan-Box 1.01 *
**************************

type: Visual Basic 6 app
niveau: tr&egrave;s facile
tools demand&eacute;s: Smart Check 6, VB pour coder le keygen
URL: http://members.tripod.com/LAN-BOX


Lancez Smart Check, et lancez le programme avec :)
Clickez sur le bouton Info et ensuite sur Register!

Entrez votre name : ACiD BuRN
et votre serial : 112233

Clickez sur le bouton pour contr&ocirc;ler le serial et cet encul&eacute; nous sort bad serial 
blablabla...
Heh, fermez lan-box et faites une research de texte sur: ACiD

Nous allons atterrir l&agrave; o&ugrave; l'algo commence!!
Regardez un peu et vous verrez qu'il prends les valeurs ascii de chaque lettres
du nom entr&eacute;...
Clickez sur la ligne:

asc(String:"A") returns Integer:65 

Pour voir ce que fait ce putain de programme, on click sur : "Show all event" dans le menu
View..

Ensuite on voit ceci:

asc(String:"A") returns Integer:65   &lt;== on voit le programme prendre la valeur ascii de la
                                     premi&egrave;re lettre (1ere lettre: "A" provenant d'ACiD BuRN) 

Ensuite il ajoute aux autres...


En 1er, il ajoute  "65" a "0" car il n'y avait pas de lettre avant!
On voit &ccedil;a dans Smart Check avec la ligne suivante:

__vbavaradd(VARIANT:Empty,VARIANT:Integer:65)

Ceci ajoute 65 &agrave; 0 (empty veut dire : pas encore de valeur donc vide)

Si on regarde plus bas, on voit la m&ecirc;me chose avec la lettre d'apr&egrave;s "C" (C de ACiD BuRN)

Asc(String("C") returns Integer: 67   <== prends la valeur ascii de la lettre o&ugrave; nous
                                          somme actuellement, ici on a "C"
Ensuite ajoute cette valeur au r&eacute;sultat de l'ancienne addition!


__vbavaradd(VARIANT:65,VARIANT:Integer:67)

R&eacute;sultat:

_vbavarmove(VARIANT:integer:132,VARIANT:Integer:65)
Le r&eacute;sultat est: 132 et la valeur: 65 est l'ancienne valeur. Donc il efface la valeur qu'il avait
mis de c&ocirc;t&eacute; et la remplace par la nouvelle valeur: 132..

Bien il fait ceci avec chaque valeur ascii, et cette boucle prends les valeurs ascii du nom
et les additionnes entre elle!

Cela donne ceci:

--------------------------------
A = 65 + 0
C = 67 + 65 = 132
i = 132 + 105 = 237
D = 237 + 68 = 305
space = 305 + 32 = 337
B = 337 + 66 = 403
u = 403 + 117 =  520
R = 520 + 82 = 602
N = 602 + 78 = 680
---------------------------------

Donc la valeur finale de ces op&eacute;rations est 680 en d&eacute;cimal ....

Maintenant descendez tant que vous n'aurez pas atteint la fin de la boucle sur
les valeurs ascii, c'est l&agrave; o&ugrave; vous verrez la valeur: "680" :)

Heh, maintenant on regarde un peu plus et si on descend encore, on voit:

__vbavarmul(VARIANT:680,VARIANT:232354) : multiplie le r&eacute;sultat des valeurs ascii avec 232354
le r&eacute;sultat est : 158000720

__vbavarmul(VARIANT:158000720,VARIANT:653435) : multiplie le r&eacute;sultat de la premi&egrave;re
multiplication avec 653435
le r&eacute;sultat est: 103243200473200

__vbavardiv(VARIANT:1.03243e014,VARIANT:23446534) : divise le r&eacute;sultat de la 2nd multiplication 
avec 23446534 (note: 1.03243e014 est la m&ecirc;me chose que 103243200473200 
C'est pour cela qu'il est bon de faire les calculs pour v&eacute;rifier les valeurs :)

Le r&eacute;sultat est: 4403345.947558817 (on vois cette valeur dans Smart Check)

et finalement on trouve:

__vbavarmove(VARIANT:Double:4.40335e+006,VARIANT:Integer:680) 

Cela d&eacute;place le r&eacute;sultat final (bon serial) o&ugrave; la valeur "680" a &eacute;t&eacute; &eacute;crite ! Il l'ecrase donc!
Donc la premi&egrave;re fois, j'ai cru que c'&eacute;tait le bon serial!! Mais c'&eacute;tait pas le bon !
J'ai entr&eacute;: 4403345.947558817 , putain c'est pas le bon !
Mauvaise message box de merde!


Si on descend encore un peu, on voit la valeur: 4403345,94755882
Essayons-le: Ca marche :) 

Donc, je me demandais comment 4403345.947558817 est devenu 4403345,94755882 ..
J'ai commenc&eacute; &agrave; programmer le keygen pour voir comment je pourrais r&eacute;parer le probl&egrave;me ...
Je l'ai programm&eacute; en VB5 (c'est tjs bien les keygens en VB, sur des programmes VB car
on utilise les m&ecirc;mes op&eacute;rations et fonction que le programme lui-m&ecirc;me)

Donc j'ai g&eacute;n&eacute;r&eacute; un serial avec le nom: ACiD BuRN et il m'a donn&eacute;: 4403345,94755882
Cooooool ! Je sais pas pkoi &ccedil;a marche, s&ucirc;rement &agrave; cause des fonctions VB :)
D'o&ugrave; l'int&eacute;r&ecirc;t encore une fois du keygen en VB!
Bref, &ccedil;a marche, je suis fatigu&eacute; et je vais pas me poser des questions 30 ans !

Explication global de l'algo:

--------------------------ALGO---------------------------------

1st : additionne toutes les valeurs ascii du nom
2nd : multiplie la valeur (de la 1ere partie de l'algo) avec 232354
3rd : multiplie la valeur (de la 2eme partie de l'algo) avec 653435
4th : et divise la valeur (de la 3eme partie de l'algo) avec 23446534

---------------------END OF ALGO-------------------------------

Le r&eacute;sultat en 4 est le serial valide !!!!!!!!



3) BONUS SOURCE : le keygen en VB



-----------------------------START OF SOURCE-----------------

For i = 1 To Len(Text1.Text)
temp = Asc(Mid(Text1.Text, i, 1))
final = final + temp
Next i
final = final * 232354
final = final * 653435
final = final / 23446534
Text2.Text = final

-----------------------------END OF SOURCE--------------------


Dernier Exemple:

*******************
*The Power 1.0 fr *
*******************


Apr&egrave;s Le keygen d'un programme en name / serial !! Voici celui
sur un serial only!


on a besoin de: - Smart Check 6 (doit &ecirc;tre bien configur&eacute;)
                - Visual Basic : pour programmer le keygen (un autre langage fera l'affaire aussi)
                - le programme : <a href="http://www.ifrance.com/vbandjava">http://www.ifrance.com/vbandjava</a> 
                - un cerveau ;) 
 


Lancez Smart Check et ouvrez le programme avec !!
On voit appara&icirc;tre : "the power est un shareware...."
C'est juste un nag screen, on s'en tape!
On click sur OK, et on voit maintenant une INPUT BOX avec le texte suivant:

"Le num&eacute;ro de votre disque (celui &agrave; partir duquel vous avez lancé the power)
est : (il vous donne le num&eacute;ro)
Si vous souhaitez vous enregistrez, notez ce num&eacute;ro et blablablabla"


Donc on voit que le programme nous demande de noter ce num&eacute;ro bas&eacute; sur notre
disque dur! et de l'envoyer si on veut s'enregistrer !! ok ok !!
Donc ce programme n&eacute;cessite un keygen car le serial valid pour votre PC ne marchera
pas sur les autres ordis !


Donc entrez un serial &agrave; la con: 112233 et clickez sur OK!
On a le sale msg d'erreur *grin* : "Vous vous &ecirc;tes trompé(e) blablabla" (pas pour tr&egrave;s longtemps
lol )

Donc on ferme le programme et on retourne sous Smart Check pour &eacute;tudier tout &ccedil;a !
on va examiner l'algo :)


Dans Smart Check, double clickez sur : Form1_load
Donc on va d'abord chercher qq chose qui se sert de notre disque dur,
(l'API la plus utilis&eacute;e est GetvolumeinformationA) rappelez-vous des CD checks!

Regardez donc un peu plus bas et on trouve:

GetVolumeInformationA(LPSTR:00413BA4....)
2 lignes plus bas on voit : Right(VARIANT:Double:8.92936e+008,long:8)

Terrible ! Ca a l'air sympathique tout &ccedil;a ! Clickez dessus et regardez la valeur dans la fen&ecirc;tre
de droite!!
On voit : 892935893  <== c'est notre num&eacute;ro de disque dur

donc "Right(VARIANT:Double:8.92936e+008,long:8)" est &eacute;gal &agrave; :
"Right(VARIANT:Double:892935893,long:8)"

Cela veut dire qu'il prends les valeurs &agrave; partir de la droite avec une longeur de: 8
les 8 valeurs a partir de la droite de 892935893 sont 92935893 .
Ne serait-ce pas le serial que l'on voit dans la boite de dialogue au d&eacute;but ?
mais si ! Tout &agrave; fait :)

Vous n'aurez pas les m&ecirc;mes valeurs chez vous car &ccedil;a d&eacute;pend du disque dur !!

Environ 2 lignes plus bas on trouve:

Len(String:"92935893")returns LONG:8

Click dessus et dans le menu View, faites: show all events...

Maintenant on voit qqchose comme ceci :

Mid$(String:"92935893",long:1,VARIANT:Integer:1)
....
String("9") --> Double (9)
Double (9) --> Integer (9)

......

Mid$(String:"92935893",long:2,VARIANT:Integer:1)
....
String("2") --> Double (2)
Double (11) --> Integer (11)

......

Mid$(String:"92935893",long:3,VARIANT:Integer:1)
....
String("9") --> Double (9)
Double (20) --> Integer (20)

......

Mid$(String:"92935893",long:4,VARIANT:Integer:1)
....
String("3") --> Double (3)
Double (23) --> Integer (23)

......

Mid$(String:"92935893",long:5,VARIANT:Integer:1)
....
String("5") --> Double (5)
Double (28) --> Integer (28)

......

Mid$(String:"92935893",long:6,VARIANT:Integer:1)
....
String("8") --> Double (8)
Double (36) --> Integer (36)

......


Mid$(String:"92935893",long:7,VARIANT:Integer:1)
....
String("9") --> Double (9)
Double (45) --> Integer (45)

......


Mid$(String:"92935893",long:8,VARIANT:Integer:1)
....
String("3") --> Double (3)
Double (48) --> Integer (48)

......

Hmm!! Vous devez vous demander ce que ce truc fait !!!
et comment les valeurs sont calcul&eacute;es.

Laissez-moi vous &eacute;claircir:

Il prends les valeurs une par une du serial (la version modifi&eacute;e de celui du disque dur)
et les ajoutes au r&eacute;sultat de l'addition d'avant !
Voici l'exemple, c'est plus clair:


 0 + 9 = 9  (0 car 9 est le 1er nombre donc rien &agrave; ajouter encore!)
 9 + 2 = 11
11 + 9 = 20
20 + 3 = 23
23 + 5 = 28
28 + 8 = 36
36 + 9 = 45
45 + 3 = 48


Donc vous voyez comment ces valeurs sont calcul&eacute;es!! 
Pas tr&egrave;s compliqu&eacute;, il faut juste r&eacute;fl&eacute;chir!

Bref, ensuite on voit:

Mid$(String:"92935893",long:8,VARIANT:Integer:1)
....
String("3") --> Double (3)
Double (48) --> Integer (48)

et il y a :

Hex(VARIANT:integer:19952)
__vbastrVarMove(VARIANT:String:"4DF0") ....
.....

Donc il prends la valeur hexa de 19952 (4DF0)

et si on descend plus bas, on voit la comparaison:

__vbaStrCmp(String:"4DF0",String:"112233") returns DWORD: FFFFFFFF

C'est celui qui est le plus utilis&eacute; pour comparer!!
Ici il compare: 4DF0 avec 112233 
112233 = faux serial , celui qu'on a entr&eacute;
4DF0 = le serial en hexad&eacute;cimal qu'on a vu !! C'est le serial valide.

Mais le probl&egrave;me est : d'o&ugrave; vient ce putain de 19952 ?!


Regardons encore ce que nous avons vu avec Smart Check:

Mid$(String:"92935893",long:8,VARIANT:Integer:1)
....
Double (48) --> Integer (48)
Hex(VARIANT:integer:19952)
__vbastrVarMove(VARIANT:String:"4DF0") ....

Hmm, si on ajoute 48 à 19952, on obtient: 20000
Hoho !! On dirait que le programme soustrait la valeur calcul&eacute;e &agrave; partir
du serial provenant du disque dur &agrave; 20000 .

48 = valeur venant du disque dur
20000 = constante

20000 - 48 = 19952

Et apr&egrave;s &ccedil;a, il convertit le r&eacute;sultat en hexad&eacute;cimal:
19952(d) = 4DF0(h)

Et on obtient le bon serial: 4DF0
C'est le code valide !!! donc si on faisait un petit keygen:


--------------------------------------------------------------------------------
The keygen:


Pour cela on utilise les API Windows pour r&eacute;cup&eacute;rer le num&eacute;ro de s&eacute;rie
du disque dur..
et ensuite on fait le reste des calculs !
Je vais montrer la partie calculation car celle qui r&eacute;cup&egrave;re le num&eacute;ro du 
disque n'est pas tr&egrave;s importante, mais tr&egrave;s longue :/
Voici les sources en VB:

-----------------------------little cut of source---------------------------------


'ici il y a les sources pour r&eacute;cup&eacute;rer les num&eacute;ros du disque normalement

serial = Right(Format$(lngVolumeSerialNumber), 8)

Label1.Caption = "The value from your hard drive is: " + serial
For i = 1 To Len(serial)
temp = temp + Val(Mid(serial, i, 1))
Next i

Text1.Text = "Your personal  unlocking code is :" + Hex(20000 - temp)

-------------------------end of little cut of source-------------------------------


Et voil&agrave; !! C'est terminé pour les keygens des programmes en VB!!
Mais je vous invite &agrave; lire les nombreux autres cours que j'ai &eacute;crit
&agrave; ce sujet !!
May the Force be with you ;p

</pre>
<font size="+2"><a name="java"><b><u>JAVA Reverse Engineering</u></b></a></font><br>
<br>
<pre>
 

Cracker du java peut &ecirc;tre extr&ecirc;mement facile &agrave; condition d'avoir un d&eacute;compilateur
Je vais donc vous montrer comme quoi reverser du java, &ccedil;a peut &ecirc;tre tr&egrave;s simple !
Il existe des protections java beaucoup plus dure bien s&ucirc;r, mais c'est juste une
approche sur le reversing du java !!

On a besoin de:
		- JAD (java decompiler)
		- rien de plus :)	


URLS: <br>        <a href="http://www.lawrencegoetz.com/">www.lawrencegoetz.com/</a> (Trucs &agrave; cracker)
        <a href="http://www.acidburn2000.com">http://www.acidburn2000.com</a> (le d&eacute;compilateur java)
</pre>
<pre>

Dans ce cours nous allons cracker 3 choses: Goetz's Banner V 2.0 , Goetz's Marquee 1.1,
et ManKind java crackme !


Let's kick some ass !
Dézippez l'archive de Goetz's Banner V 2.0 dans un r&eacute;pertoire quelquonque, vous devez voir
des fichiers de type .class et html entre autres!
Lancez the fichier d'exemple exemple.html), et vouz verrez l'effet de banni&egrave;re sur ce 
petit truc en java ! Mais un Putain de UNREGISTERED &agrave; la con pointe son nez hehe Doh!
Donc, les fichiers java sont de type: .class . Apr&egrave;s avoir r&eacute;cup&eacute;ré le d&eacute;compilateur java
sur mon site, et l'avoir plac&eacute; dans le r&eacute;pertoire o&ugrave; vous venez de d&eacute;zipper ces applets
d&eacute;placez le fichier .class sur le d&eacute;compilateur (jad.exe) pour qu'il le d&eacute;compile!!
Mais, il est pr&eacute;f&eacute;rable de faire un fichier .Bat , pour d&eacute;finir le chemin de destination
du fichier d&eacute;compilé, car il peut se retrouver dans le r&eacute;pertoire de Windows par exemple!
Bref, une fois que vous l'avez (les fichiers d&eacute;compil&eacute;s portent l'extension ".jad"),
&eacute;ditez-le avec un &eacute;diteur de textes, et vous devriez voir qq chose comme &ccedil;a:



--------------------------------------gbanner.JAD------------------------------------------

// Decompiled by Jad v1.5.7. Copyright 1997-99 Pavel Kouznetsov.
// Jad home page: http://www.geocities.com/SiliconValley/Bridge/8617/jad.html
// Decompiler options: packimports(3) 
// Source File Name:   gbanner.java

import java.applet.Applet;
import java.applet.AppletContext;
import java.awt.*;
import java.io.*;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.Vector;

public class gbanner extends Applet
    implements Runnable
{

    public boolean mouseEnter(Event event, int i, int j)
    {
        if(info[place] != null && displaying)
            getAppletContext().showStatus(info[place]);
        mouseInside = true;
        return true;
    }

    public void stop()
    {
        running = false;
        if(animate != null)
        {
            animate.stop();
            animate = null;
        }
    }

    public gbanner()
    {
        m_background = "white";
        test_it = "";
        drawn = true;
        zoom = true;
        pausable = true;
        m_target = "_self";
    }

    public boolean mouseExit(Event event, int i, int j)
    {
        mouseInside = false;
        getAppletContext().showStatus("");
        return true;
    }

    public void paint(Graphics g)
    {
        if(drawable)
        {
            g.drawImage(offImage, 0, 0, this);
            place = loadImage;
        }
        drawn = true;
    }

    public String[][] getParameterInfo()
    {
        String as[][] = {
            {
                "image", "String", "lineN where N is the line number"
            }, {
                "background", "String", "Background color"
            }, {
                "URL", "String", "URLN where N is the URL for the image N."
            }, {
                "target", "String", "Target of URL"
            }, {
                "info", "String", "infoN where N is the infomation for the image N."
            }, {
                "pause", "String", "pauseN where N is the pause time for the image N."
            }, {
                "zoom", "String", "Zoom the images or not."
            }, {
                "shuffle", "String", "Shuffle the images or not."
            }, {
                "pauseable", "String", "Pause the applet when the mouse is in it."
            }, {
                "one", "String", "Display only one image. Good for use with shuffle to display one random image."
            }
        };
        return as;
    }

    public void destroy()
    {
        running = false;
        if(animate != null)
        {
            animate.stop();
            animate = null;
        }
    }

    public int[] shuffle()
    {
        Vector vector = new Vector();
        int ai[] = new int[amount];
        for(int j = 0; j < amount; j++)
            vector.addElement(new Integer(j));

        for(int k = 0; k < amount; k++)
        {
            int i = (int)(Math.random() * (double)(amount - k));
            Integer integer = (Integer)vector.elementAt(i);
            ai[k] = integer.intValue();
            vector.removeElementAt(i);
        }

        return ai;
    }

    public void update(Graphics g)
    {
        paint(g);
    }

    public void start()
    {
        place = 0;
        if(offImage == null)
        {
            offImage = createImage(d.width, d.height);
            offGraphics = offImage.getGraphics();
        }
        try
        {
            myInfo = new URL(getDocumentBase(), "gboption.ini");
        }
        catch(MalformedURLException _ex)
        {
            good = false;
        }
        if(myInfo != null)
            try
            {
                input = myInfo.openStream();
                dataInput = new DataInputStream(input);
                test_it = dataInput.readLine();
                dataInput.close();
            }
            catch(IOException _ex) { }
        if(test_it.equals("InFeb"))
            good = true;
        running = true;
        if(animate == null)
        {
            animate = new Thread(this);
            animate.start();
        }
    }

    public String getAppletInfo()
    {
        return "Title: Goetz's Banner\r\n" + "Author: Lawrence Goetz\r\n" + "E-mail: goetz@lawrencegoetz.com\r\n" 
                     + "Web: http://www.lawrencegoetz.com/\r\n" + "Copyright Lawrence Goetz 1998";
    }

    public boolean mouseDown(Event event, int i, int j)
    {
        if(locations[place] != null && displaying)
            getAppletContext().showDocument(locations[place], m_target);
        return true;
    }

    public void run()
    {
        int i = 20;
        int ai[] = null;
        if(shuffle)
            ai = shuffle();
        int j1 = 0;
        if(!shuffle)
            loadImage = j1;
        setMyColor(offGraphics, "blue");
        offGraphics.fillRect(0, 5, 110, 20);
        setMyColor(offGraphics, "yellow");
        offGraphics.drawString("Loading Image", 5, 20);
        drawable = true;
        repaint();
        try
        {
            Thread.sleep(100L);
        }
        catch(InterruptedException _ex) { }
        Thread.yield();
        images = new Image[amount];
        while(running) 
        {
            while(!drawn) 
                try
                {
                    Thread.sleep(10L);
                }
                catch(InterruptedException _ex) { }

            if(shuffle)
                loadImage = ai[j1];
            if(!shuffle)
                loadImage = j1;
            images[loadImage] = getImage(getDocumentBase(), getParameter("image" + Integer.toString(loadImage + 1)));
            MediaTracker mediatracker = new MediaTracker(this);
            mediatracker.addImage(images[loadImage], 0);
            try
            {
                mediatracker.waitForID(0);
            }
            catch(InterruptedException _ex) { }
            drawn = false;
            drawable = false;
            if(!zoom)
                i = 1;
            image_w = images[loadImage].getWidth(this);
            image_h = images[loadImage].getHeight(this);
            int j = image_w / i;
            int k = image_h / i;
            int l = d.width / 2 - j / 2;
            int i1 = d.height / 2 - k / 2;
            setMyColor(offGraphics, m_background);
            offGraphics.fillRect(0, 0, d.width, d.height);
            if(i != 1)
                offGraphics.drawImage(images[loadImage], l, i1, j, k, this);
            else
            if(i == 1)
                offGraphics.drawImage(images[loadImage], l, i1, this);
            if(!good)
            {
                setMyColor(offGraphics, "blue");
                offGraphics.fillRect(0, 5, 200, 100);
                setMyColor(offGraphics, "yellow");
                offGraphics.drawString("UNREGISTERED VERSION!!!", 5, 25);
                offGraphics.drawString("Please Register this applet.", 5, 50);
                offGraphics.drawString("Registration is only $5.", 5, 80);
            }
            drawable = true;
            try
            {
                Thread.sleep(50L);
            }
            catch(InterruptedException _ex) { }
            if(i > 1)
                i -= 2;
            if(i <= 0)
                i = 1;
            else
            if(i == 1)
                i = 20;
            repaint();
            displaying = true;
            if(i == 20)
            {
                if(pause[loadImage] > 0)
                    try
                    {
                        Thread.sleep(pause[loadImage] * 1000);
                    }
                    catch(InterruptedException _ex) { }
                while(pausable && mouseInside) 
                    try
                    {
                        Thread.sleep(100L);
                    }
                    catch(InterruptedException _ex) { }

                while(one && running) 
                {
                    drawable = true;
                    repaint();
                    try
                    {
                        Thread.sleep(100L);
                    }
                    catch(InterruptedException _ex) { }
                }

                if(++j1 == images.length)
                {
                    j1 = 0;
                    if(shuffle)
                        ai = shuffle();
                }
            }
            Thread.yield();
        }

    }

    public void init()
    {
        int i = 1;
        String s4 = "image" + Integer.toString(i);
        for(String s = getParameter(s4); s != null; s = getParameter(s4))
        {
            amount++;
            i++;
            s4 = "image" + Integer.toString(i);
        }

        locations = new URL[amount];
        for(int j = 0; j < amount; j++)
        {
            String s1 = getParameter("URL" + Integer.toString(j + 1));
            if(s1 != null)
            {
                try
                {
                    locations[j] = new URL(getDocumentBase(), s1);
                }
                catch(MalformedURLException _ex) { }
            }
            else
            {
                String s2 = getParameter("URL");
                try
                {
                    locations[j] = new URL(getDocumentBase(), s2);
                }
                catch(MalformedURLException _ex) { }
            }
        }

        String s3 = getParameter("target");
        if(s3 != null && !s3.equals(""))
            m_target = s3;
        info = new String[amount];
        for(int k = 0; k < amount; k++)
        {
            info[k] = getParameter("info" + Integer.toString(k + 1));
            if(info[k] == null)
                info[k] = getParameter("info");
        }

        pause = new int[amount];
        for(int l = 0; l < amount; l++)
        {
            String s6 = getParameter("pause" + Integer.toString(l + 1));
            if(s6 != null && !s6.equals(""))
            {
                pause[l] = Integer.parseInt(s6);
            }
            else
            {
                String s7 = getParameter("pause");
                if(s7 != null && !s7.equals(""))
                    pause[l] = Integer.parseInt(s7);
            }
        }

        String s5 = getParameter("background");
        if(s5 != null)
            m_background = s5;
        s3 = getParameter("zoom");
        if(s3 != null && s3.equalsIgnoreCase("false"))
            zoom = false;
        s3 = getParameter("pauseable");
        if(s3 != null && s3.equalsIgnoreCase("false"))
            pausable = false;
        s3 = getParameter("shuffle");
        if(s3 != null && s3.equalsIgnoreCase("true"))
            shuffle = true;
        s3 = getParameter("one");
        if(s3 != null && s3.equalsIgnoreCase("true"))
            one = true;
        d = size();
        place = 0;
        offImage = createImage(d.width, d.height);
        offGraphics = offImage.getGraphics();
        resize(d.width, d.height);
    }

    public void setMyColor(Graphics g, String s)
    {
        if(s.equals("white"))
        {
            g.setColor(Color.white);
            return;
        }
        if(s.equals("black"))
        {
            g.setColor(Color.black);
            return;
        }
        if(s.equals("light gray"))
        {
            g.setColor(Color.lightGray);
            return;
        }
        if(s.equals("gray"))
        {
            g.setColor(Color.gray);
            return;
        }
        if(s.equals("dark gray"))
        {
            g.setColor(Color.darkGray);
            return;
        }
        if(s.equals("red"))
        {
            g.setColor(Color.red);
            return;
        }
        if(s.equals("pink"))
        {
            g.setColor(Color.pink);
            return;
        }
        if(s.equals("orange"))
        {
            g.setColor(Color.orange);
            return;
        }
        if(s.equals("yellow"))
        {
            g.setColor(Color.yellow);
            return;
        }
        if(s.equals("green"))
        {
            g.setColor(Color.green);
            return;
        }
        if(s.equals("magenta"))
        {
            g.setColor(Color.magenta);
            return;
        }
        if(s.equals("cyan"))
        {
            g.setColor(Color.cyan);
            return;
        }
        if(s.equals("blue"))
            g.setColor(Color.blue);
    }

    private String m_background;
    private final String PARAM_imageN = "image";
    private final String PARAM_background = "background";
    private final String PARAM_URLN = "URL";
    private final String PARAM_infoN = "info";
    private final String PARAM_pauseN = "pause";
    private final String PARAM_zoom = "zoom";
    private final String PARAM_shuffle = "shuffle";
    private final String PARAM_target = "target";
    private final String PARAM_pausable = "pauseable";
    private final String PARAM_one = "one";
    private Dimension d;
    private boolean running;
    private Image images[];
    private int place;
    private Image offImage;
    private Graphics offGraphics;
    private boolean good;
    private URL locations[];
    private URL myInfo;
    private String test_it;
    private final String option = "InFeb";
    private InputStream input;
    private DataInputStream dataInput;
    private Thread animate;
    private boolean drawable;
    private boolean drawn;
    private MediaTracker imageTracker;
    private int image_w;
    private int image_h;
    private String info[];
    private int pause[];
    private int amount;
    private boolean zoom;
    private boolean shuffle;
    private boolean pausable;
    private String m_target;
    private int loadImage;
    private boolean displaying;
    private boolean mouseInside;
    private boolean one;
}

-------------------------------------------End of jad file---------------------------------

Ok balaise huh ?
Donc pour les prochains fichier, je ne vous montrerai que les parties importantes!
Donc, vous avez jet&eacute; un oeil &agrave; la source ci-dessus, et vous avez (j'esp&egrave;re ;p) rep&eacute;ré la
protection ! Un petit keyfile &agrave; la mord-moi-le-noeud :p *grin*
Donc, on cherche qq chose qui ressemble &agrave; un contr&ocirc;le de fichiers:


      try
      {
          myInfo = new URL(getDocumentBase(), "gboption.ini");  <--- eheheh! Nom du keyfile
      }
      catch(MalformedURLException _ex)
      {
          good = false;
      }
      if(myInfo != null)
          try
          {
              input = myInfo.openStream();
              dataInput = new DataInputStream(input);
              test_it = dataInput.readLine();
              dataInput.close();
          }
          catch(IOException _ex) { }
      if(test_it.equals("InFeb"))   <--- hmm ! on dirait qu'il compare le texte dans du fichier
          good = true;              <--- si le texte = InFeb donc c'est OK
      running = true;        	    //	 sinon Get the fuck outta here!!
      if(animate == null)



w0w , &ccedil;a craint! Cr&eacute;ez un fichier nommé gboption.ini et mettez 'InFeb' dedans!!
(sans les ' ' bien s&ucirc;r), enregistrez ce fichier, copiez-le dans le r&eacute;pertoire de l'applet 
et lancez le fichier exemple.hml!
Kewl !! Voil&agrave; le Putain D'UNREGISTERED texte a mouru lol :)
Facile non ??


Part2: Goetz's Marquee V 1.1


Toujours la m&ecirc;me chose! Keyfile based protection
D&eacute;compilez le fichier class et ouvrez-le avec notepad par exemple !

Je vous montre les parties importantes seulement, car c'est exactement la m&ecirc;me merde!


-------------------------------------cut from gmarquee.jad-------------------------------- 
 public void start()
    {
        if(offImage == null)
        {
            offImage = createImage(d.width, d.height);
            offGraphics = offImage.getGraphics();
        }
        if(f == null)
        {
            f = new Font("Helvetica", 0, m_font);
            fm = offGraphics.getFontMetrics(f);
        }
        try
        {
            myInfo = new URL(getDocumentBase(), "gmoption.ini");     <---- hehe :p
        }
        catch(MalformedURLException _ex)
        {
            good = false;
        }
        if(myInfo != null)
            try
            {
                input = myInfo.openStream();
                dataInput = new DataInputStream(input);
                test_it = dataInput.readLine();
                dataInput.close();
            }
            catch(IOException _ex) { }
        if(test_it.equals("Eggplant"))  <--- si le cracker a mit Eggplant jmp goodboy
            good = true;		   // sinon: jmp GET the fuck outta here :p	
        if(!good)
            try
            {
                reg = new register(300, 200, "Please Register Goetz's Marquee",
                      "http://www.lawrencegoetz.com/programs/nettools.htm", this);
            }
            catch(Exception _ex)
            {
                System.err.println("You are missing the file register.class");
                return;
            }
        if(animate == null)



-----------------------------End of quotes from marquee.jad---------------------------------



Encore, cr&eacute;ez un fichier nommé gmoption.ini et mettez 'Eggplant' dedans !
(sans les ' ' ). Enregistrez les fichiers, et lancez le fichier d'exemple!
Et voil&agrave;, plus de m&eacute;chant Texte hehe !

C'est maintenant enregistré et vous pouvez appr&eacute;cier ce petit applet java :p

Ok, assez avec ces conneries de keyfile &agrave; la mord-moi-le-noeud, regardons ce petit crackme
cod&eacute; par notre ami MandKind en java!
Il n'y a aucun fichier html fournis pour tester le serial, mais on n'en a pas besoin hehe!!

Ph43R !!

Comme d'hab, d&eacute;compilez le fichier class, et ouvrez-le avec notepad !!
On peut voir cette merde:


---------------------------------Start of CrackMe.jad--------------------------------------


   public CrackMe()
    {
    }

    public static void main(String args[])
    {
        if(args.length != 1)
        {
            System.out.println("Usage: java CrackMe Registration Code");
            System.exit(0);
        }
        System.out.println("");
        System.out.println("");
        System.out.println("Welcome to ManKind's Java CrackMe 0.1");
        System.out.println("=====================================");
        System.out.println("This is an Alpha Test of ManKind's Java CrackMe, please do send your comments,
                                  suggestions, opinions, feedbacks and support words to me!");
        System.out.println("");
        System.out.println("");
        int i = Integer.valueOf(args[0]).intValue();
        if(i == 0x7f42b)
            System.out.println("Congratulations, you succeeded in cracking this!");
        if(i != 0x7f42b)
            System.out.println("Sorry, invalid registration code. Please try again!");
        System.out.println("");
        System.out.println("");
        System.out.println("This program is Copyright \251 1999 ManKind");
        System.out.println("Service for Mankind");
        System.out.println("mankind001@bigfoot.com");
        System.exit(0);
    }
}


---------------------------------End of CrackMe.jad-------------------------------------------


Hehe, &ccedil;a a l'air marrant!
Nous voyons:

"      int i = Integer.valueOf(args[0]).intValue();
        if(i == 0x7f42b)
            System.out.println("Congratulations, you succeeded in cracking this!");
        if(i != 0x7f42b)
            System.out.println("Sorry, invalid registration code. Please try again!");
        System.out.println("");      "


En Visual Basic, &ccedil;a donnerait ceci:


IF serial= $7f42b then
msgbox "Congratulations, you succeeded in cracking this!"
Else
msgbox "Sorry, invalid registration code. Please try again!"
End if

"0x7f42b" est en hexad&eacute;cimal (0x nous le montre) mais nous voulons le bon serial donc on
le convertit en d&eacute;cimal! Si vous avez Soft-ice chargé:

Ctrl+d
? 7b42b

on voit donc: 521259


FACILE non ??

Bon, je n'ai plus d'autre fichier prot&eacute;g&eacute; en java, donc je m'en vais finir ce tut :-(

J'esp&egrave;re que le reversion du java est plus claire maintenant pour vous !!
C'est quelque chose de tr&egrave;s simple les 3/4 du temps :
Bien s&ucirc;r, c'est gr&acirc;ce au d&eacute;compilateur !!

</pre>
<font size="+2"><a name="unpacking"><b><u>Manual Unpacking (comment unpacker, 
les tools, m&eacute;thodes...)</u></B></a></font><br>
<br>
<pre>


Qu'est-ce que le manual unpacking ??
Vous avez s&ucirc;rement remarqu&eacute; que certaine fois quand on d&eacute;sassemble un fichier,
on ne trouve plus de String Data References !!!
Car c'est que le fichier est crypt&eacute; ou compressé !!
Merde alors.... Ben il existe des unpackers me direz vous, mais c'est pas
marrant quand &ccedil;a fait tout tout seul !! :-o
Donc, je vais tenter de vous expliquer comment, et avec quoi d&eacute;crypter les fichiers...
Je vais vous montrer quelques exemples comme : ASPACK , ARMADILLO , UPX , NEOLITE ....
(Note: lisez aussi le cours sur CDilla dans la section CD check)
Tout d'abord qq infos sur le format PE !!

Sch&eacute;ma pour vous donner une id&eacute;e de la bestiole ;) :
(from PE.txt)

    +-------------------+
    | DOS-stub          |
    +-------------------+
    | file-header       |
    +-------------------+
    | optional header   |
    |- - - - - - - - - -|
    |                   |
    | data directories  |
    |                   |
    +-------------------+
    |                   |
    | section headers   |
    |                   |
    +-------------------+
    |                   |
    | section 1         |
    |                   |
    +-------------------+
    |                   |
    | section 2         |
    |                   |
    +-------------------+
    |                   |
    | ...               |
    |                   |
    +-------------------+
    |                   |
    | section n         |
    |                   |
    +-------------------+


Je vais pas m'attarder trop sur le format lui-m&ecirc;me, mais je vais vous donner quelques
infos sur les sections et autres caract&eacute;ristiques !!
Vous avez s&ucirc;rement remarqu&eacute; que dans ProcDump (unpacker), il y a un PE editor (&eacute;diteur
de PE) tr&egrave;s tr&egrave;s utile, vous le verrez plus tard...
Que se passe-t-il si on &eacute;dite un fichier ??
On peut r&eacute;cup&eacute;rer l'entry point, l'image base, les caract&eacute;ristiques des sections ...

A propos des caract&eacute;ristiques:

0x20...... : Cela Veut dire executable
0x40...... : Cela Veut dire Readable (lisable)
0x80...... : Cela Veut dire Writeable (&eacute;criture possible)

exemple 0x60.. -> ex&eacute;cutable + lisable 

0x......20 : Cela Veut dire contains Code
0x......40 : Cela Veut dire Initialized data
0x......80 : Cela Veut dire Unitialized data

(pris d'une doc sur le PE)

Voil&agrave;, je ne vais pas faire un cours sur le PE, car mes connaissances sont plut&ocirc;t limit&eacute;es
&agrave; ce sujet! Je cherche donc de la doc sur le PE en fran&ccedil;ais !!!
J'ai vraiment pas le go&ucirc;t de traduire les Docs disponibles en anglais !
Si quelqu'un sait o&ugrave; trouver &ccedil;a, merci de me mailer ;-)
Bon assez de blablabla, on va commencer par un cours sur ASPACK:


******************************
****		ASPACK		  ****
******************************


Ce tut est pour apprendre &agrave; unpacker ! Vous apprendrez les bases !!
Mais je vais prendre une application, freeware, compact&eacute;e avec Aspack
(on s'en fout de toutes fa&ccedil;ons! hehe !!)
Je ne vous montrerais que comment on retrouve les String Data References
dans l'app donc pas de table d'import, car ce tut a pour but de mettre
&agrave; l'aise avec l'unpacking !! (pour des imports table: lisez le tut sur CDilla)
Vous pourrez donc patcher le programme comme si il &eacute;tait normal :)


On a besoin de:

         - Soft-ice 3.x or 4

         - ProcDump 1.5 (seulement pour dumper)



Premi&egrave;re partie: le loader!



Vous devrez utiliser le loader de SI pour d&eacute;compacter, donc exécutez-le!
et choisissez l'exe que vous voulez!
Pour nous, ce sera : Konix.exe.
Ok, ex&eacute;cutez-le avec le loader mais le probl&egrave;me c'est que cette
application ne veut pas s'interrompre... :(
Hehe, no problem!, ex&eacute;cutez ProcDump et utilisez un &eacute;diteur PE!
Editez la section du Code de l'ex&eacute;cutable.
(PE editor: choisissez le fichier, sections, CODE et bouton droit "EDIT SECTION")



Ok, vous voyez dans section caracteristic : C0000040

Ok, changez-le en : E0000020

Pour des questions &agrave; propos de ce geste, lisez les infos plus haut sur les
caract&eacute;ristiques des sections !!

Maintenant, ex&eacute;cutez le Loader de SI et &ccedil;a marche! :))
Super, &ccedil;a a march&eacute; hehe


Deuxi&egrave;me partie: Tracer et dumper le fichier de la m&eacute;moire vers le disque!


Ok, donc vous avez tout juste arr&ecirc;t&eacute; l'ex&eacute;cution dans SI, vous voyez naturellement
les INVALID mais &ccedil;a ne pose pas de probl&egrave;me. Tracez avec F10 et vous
arrivez ici:



XXXXXXXX   PUSHAD        <-- int&eacute;ressant...

XXXXXXXX   CALL 45A006

XXXXXXXX   POP EBP

XXXXXXXX   SUB EBP,43D93E

............



XXXXXXXX   CALL 0045A051

XXXXXXXX   CALL 0045A2B2

XXXXXXXX   CALL 0045A350



............



XXXXXXXX   POPAD       <-- Tr&egrave;s int&eacute;ressant &ccedil;a !!!

XXXXXXXX   JMP EAX     <-- Arr&ecirc;tez de tracer ici !! &ccedil;a saute vers le programme decrypter!



.......





Donc... quand vous d&eacute;compactez vous voyez un POPAD et un JMP, regardez celui
qui jump vers un registre comme EAX, ECX, EDX...
Mais le plus souvent c'est EAX!
Ok, donc quand vous &ecirc;tes au niveau du JMP EAX, regardez la valeur de EAX et
&eacute;crivez-la sur un bout de papier: pour moi c'&eacute;tait: 43F0A0.
Vous l'utiliserez sous peu croyez moi!! hehe
Pour savoir si vous &ecirc;tes &agrave; la bonne place, essayez de tracer avec F10 une
fois et regardez si il jump vers la vraie entr&eacute;e du programme.
Pour nous, il l'a fait, alors c'est ok!


Maintenant, sortez de SI et r&eacute;ex&eacute;cutez l'EXE avec le loader de SI.
Et tracez jusqu'au JMP.
Maintenant, tapez : 

A       {enter}  <== pour assembler le code

JMP EIP {enter}  <== c'est pour faire une boucle infinie sans avoir &agrave; dumper n'importe quoi

{escape}

F5


Maintenant le programme est en train de faire une boucle infinie en m&eacute;moire
et on peut le dumper!!!
Ok, ex&eacute;cutez ProcDump et vous voyez dans la liste les t&acirc;ches en cours.
Clickez sur celle contenant Konix.exe. Maintenant bouton droit et choisissez
FULL DUMP. Savez le nouveau EXE avec le nom que vous voulez.
ex: KonixDumped.exe


Maintenant, cliquez avec le bouton droit comme tout &agrave; l'heure mais
choisissez KILL TASK au lieu de FULL DUMP sinon le programme
continuerait sa boucle infinie!


Troisi&egrave;me partie: Fixer le point d'entr&eacute;e du programme!


Ok, regardez le nouvel EXE que l'on vient de dumper et vous voyez
que sa taille est plus grande que celle du fichier crypté... bien! :)
Mais attendez! Si vous l'ex&eacute;cutez le prog va crasher comme un chien! :(

Ok... vous vous souvenez, vous avez not&eacute; le OEP (Original Entry Point) sur
un papier, cette valeur que vous avez trouv&eacute; dans EAX.
Dans ce cas, c'&eacute;tait 43F0A0. Ok, ex&eacute;cutez ProcDump PE Editor et changez
le point d'entr&eacute;e en 0x0003F0A0. (OEP - the image base : 43F0A0-400000=3F0A0)

Quand je disais que ce nombre allait nous aider!! hehe

Maintenant, fermez ProcDump, et le programme compact&eacute;/crypt&eacute;
CA MARCHE!!!!!!!!!!!!!!!!!!!!

D&eacute;sassemblez-le !! Et oui on voit les String Data References !!! Cool
on peut donc patcher et tout et tout :)



Voil&agrave; pour Aspack!! Maintenant que vous &ecirc;tes d&eacute;j&agrave; plus familier avec l'unpacking,
on continue avec un cours sur Armadillo!! 
Protection commerciale avec anti debugging =)
Nous allons voir comment kicker cette merde de l'exe :)



**********************************************************************
****	Unpacker un ex&eacute;cutable prot&eacute;gé par Armadillo v1.76 	     *****
**********************************************************************

 


Tout d'abord voici une description d'Armadillo trouv&eacute;e sur leur site officiel:


-------------------------------------------------------------------------------------------

Armadillo is a powerful software protection system. It wraps around your program like an
armored shell, defending your work from pirates and program crackers with state-of-the-art 
encryption, data compression, and other security features. It also allows you to add a 
complete software protection and registration-key system to your existing programs in five 
minutes or less, with no changes to your program's code! And it works with any langage
that produces a 32-bit Windows EXE file.

.....


Armadillo modifies your program's EXE file, using a key you select and state-of-the-art 
compression and encryption tools to foil any attack relying on a decompiler -- all they can 
decompile is the code for the Armadillo decompressor itself, not your program. Your program 
is decrypted in memory when it is run, after Armadillo is satisfied that it's safe to do so 
and that the user has a valid license (more on licenses below). This, along with some advanced
 snoop-detection functions, prevents most patch/bypass attacks -- it would require far more 
knowledge (and a great deal more work) to patch your program while it's encrypted.


-------------------------------------------------------------------------------------------

Ca a l'air cool ;P (du moins &ccedil;a avait l'air heheheh)


0) Introduction:


Bon, en passant sur le site officiel o&ugrave; on peut downloader la version shareware
d'Armadillo, j'ai vu toutes les options possibles de ce petit truc et je me suis
dis que j'allais voir &ccedil;a d'un peu plus pr&egrave;s...
Donc, apr&egrave;s l'avoir install&eacute;, j'ai pris calc.exe et je l'ai crypt&eacute; avec les options par
d&eacute;fauts, pour voir un peu la b&ecirc;te ;p



1) Lancer l'ex&eacute;cutable avec Soft-ice charg&eacute;:


Comme vous pouvez vous en douter, les ex&eacute;cutables prot&eacute;g&eacute;s disposent d'un anti Soft-ice
Il y a en fait 3 d&eacute;tections :

- la premi&egrave;re est tr&egrave;s connue meltice.(Createfila \\.\SICE, \\.\NTICE and \\.\SIWDEBUG)
- la seconde est connue sous le nom de:IsDebuggerPresent. On trouve l'appel &agrave; l'API
  getprocaddress.
- et pour finir, c'est un petit int 3h :p


Comment bypasser toutes ces conneries ??

Il va falloir lancer l'ex&eacute;cutable avec le loader de Soft-ice. Donc charger le fichier
avec le loader, et lancer le calc.exe.
Soft-ice doit revenir et vous devez s&ucirc;rement voir des petits: INVALID
A ce moment l&agrave;, mettez votre BPX Createfilea. Pressez F5 3 fois et vous arrivez sur les
checks, qui ressemblent &agrave; &ccedil;a:

025F:10003895  FF1520A00010        CALL    [KERNEL32!CreateFileA]
025F:1000389B  83F8FF              CMP     EAX,-01
025F:1000389E  7409                JZ      100038A9   <-- ici changez-le en jmp 100038A9
025F:100038A0  50                  PUSH    EAX
025F:100038A1  FF1538A00010        CALL    [KERNEL32!CloseHandle]
025F:100038A7  EB0B                JMP     100038B4
025F:100038A9  FF1544A00010        CALL    [KERNEL32!GetLastError]
025F:100038AF  83F802              CMP     EAX,02
025F:100038B2  7404                JZ      100038B8
025F:100038B4  C645FF01            MOV     BYTE PTR [EBP-01],01
025F:100038B8  8B4604              MOV     EAX,[ESI+04]



Il faut changer le JZ 100038A9 en JMP 100038A9
Pour cela il suffit de se positionner &agrave; la ligne du JZ, et ensuite tapez sous Soft-ice:
A "presser entr&eacute;e"
JMP 100038A9 "presser entr&eacute;e"
"presser &eacute;chap"

Et voil&agrave;, la ligne est devenue un jump, maintenant on trace avec F10, et on ex&eacute;cute le
CALL  [KERNEL32!GetLastError] , apr&egrave;s l'avoir pass&eacute; on voit un CMP EAX,2.
En gros il faut que EAX = 2 pour que tout soit OK, sinon c'est pas bon..
Regardez dans EAX, vous verrez EAX = 2 donc c'est bon.
Pressez F5, on retrouve la m&ecirc;me chose, comparaison EAX,2 , c'est toujours bon donc
tout est OK.
On presse une derni&egrave;re fois F5 pour le dernier check, mais cette fois au moment du
CMP EAX,2 on voit EAX = 32. Ce n'est donc pas bon, il faut mettre EAX &agrave; 2.
Pour cela dans Soft-ice , tapez: R EAX 2
Et voil&agrave; EAX passe &agrave; 2, la comparaison EAX &agrave; 2 est donc bonne, tout est OK.

Une fois ceci fait, on va s'occuper du 2&egrave;me check de Soft-ice. Il se sert de
GetProcAddress, donc mettez un breakpoint dessus et pressez F5.
Il suffit de presser une fois F12 pour sortir du call, et vous devez rencontrer 
quelque chose comme &ccedil;a:


025F:XXXXXXXX  XXXXXXXXXXXX        CALL    [KERNEL32!GetProcAddress]
025F:100038ED  3BC3                CMP     EAX,EBX
025F:100038EF  740A                JZ      100038FB   <--- faites un R FL Z
025F:100038F1  FFD0                CALL    EAX
025F:100038F3  85C0                TEST    EAX,EAX
025F:100038F5  7404                JZ      100038FB
025F:100038F7  C645FF01            MOV     BYTE PTR [EBP-01],01
025F:100038FB  56                  PUSH    ESI
025F:100038FC  FF1548A00010        CALL    [KERNEL32!FreeLibrary]


Vous voyez s&ucirc;rement CMP EAX,EBX et le saut conditionnel juste apr&egrave;s. Ici il faut
inverser le Zero Flag et le programme va pourvoir s'ex&eacute;cuter normalement...
Pour inverser le Zero Flag, il suffit de taper: R FL Z sous Soft-ice une fois
que vous &ecirc;tes &agrave; la bonne ligne.
A partir de maintenant, il suffit de tracer avec F10, comme un fou, et nous
allons voir le fameux int3h arriver ;)
Mais avant, &eacute;tant donn&eacute; que la version que j'ai utilis&eacute; de Armadillo n'est pas
enregistr&eacute;e (pas encore ;p ) , nous allons voir une messagebox qui nous le rappelle
Donc cliquez sur le bouton OK, et continuez &agrave; tracer.. 
Ce nag screen est tr&egrave;s simple &agrave; cracker, il suffit de mettre un ret dans le call 
et c'est fini, mais nous allons virer tous cette merde du fichier ex&eacute;cutable, donc
en s'en tape !
Mais, je ne peux m'emp&ecirc;cher de faire un petite remarque:


-------Remarque:-----------------------------------------------------------------------------

Comme vous l'avez s&ucirc;rement remarqu&eacute;, il est possible de prot&eacute;ger l'exe avec un
name / serial au d&eacute;marrage, ce qui peut &ecirc;tre assez chiant &agrave; virer, car nous voulons
ex&eacute;cuter le programme en m&eacute;moire...
Je vous racontes &ccedil;a, car le fichier que nous sommes en train d'&eacute;tudier ne comporte
pas de name / serial , j'ai pack&eacute; le fichier avec les options de bases, mais en voulant
cracker le nag screen, je me suis tromp&eacute; de call, je suis entr&eacute; dans le mauvais 
et j'ai mis un RET, sur un push EDI, il me semble, bref la premi&egrave;re instruction.
Ensuite, je suis sortis automatiquement du call (RET) et j'ai trac&eacute; avec F10.
Tout &agrave; coup, une dialog box est apparue me demandant un name / serial !!
What the fuck ? C'est quoi ce bordel, cet Armadillo me semble bizarre, mais vraiment!!
Il semblerait que quoi que l'on fasse, l'exe contient la v&eacute;rification nom et code.
Il me semble bizarre, mais j'en conclus que ca doit &acirc;tre hyper simple &agrave; virer, juste un call
&agrave; modifier, pour ne pas afficher &ccedil;a, et on se retrouverais avec un exe crypt&eacute; de
base...
Je n'ai pas eu le temps de bien regarder, mais &ccedil;a peut &ecirc;tre int&eacute;ressant.
Tout me pousse &agrave; dire que ces protections dites commerciales sont vraiment stupides...

-------Fin des Remarques:---------------------------------------------------------------------


Bref, revenons &agrave; nos moutons, hehe
On continue donc de tracer avec F10 sans r&eacute;fl&eacute;chir, il faut juste contr&ocirc;ler le code,
on cherche un "int3".
Apr&egrave;s avoir trac&eacute;, on trouve ceci:



025F:00402241  2401                AND     AL,01
025F:00402243  8885B8FEFFFF        MOV     [EBP-0148],AL
025F:00402249  BA6D447546          MOV     EDX,4675446D
025F:0040224E  8995B0FEFFFF        MOV     [EBP-0150],EDX
025F:00402254  C785C4FEFFFF260C3604MOV     DWORD PTR [EBP-013C],04360C26
025F:0040225E  895DFC              MOV     [EBP-04],EBX
025F:00402261  8B85C4FEFFFF        MOV     EAX,[EBP-013C]
025F:00402267  3385B0FEFFFF        XOR     EAX,[EBP-0150]
025F:0040226D  8BE8                MOV     EBP,EAX
025F:0040226F  B804000000          MOV     EAX,00000004
025F:00402274  CC                  INT     3                 <----- le chtit
025F:00402275  3115148D4000        XOR     [00408D14],EDX
025F:0040227B  A180804000          MOV     EAX,[00408080]
025F:00402280  310584804000        XOR     [00408084],EAX
025F:00402286  834DFCFF            OR      DWORD PTR [EBP-04],-01
025F:0040228A  EB18                JMP     004022A4



La protection est vraiment semblable &agrave; la 1.73. Les Gars de chez Armadillo se sont
pas trop foul&eacute;s pour une protection sois-disant Tr&egrave;s fiable.
Bref, vous avez s&ucirc;rement remarqu&eacute; le "MOV EAX, 00000004".
Pour passer ce contr&ocirc;le, il suffit de se mettre &agrave; la ligne du MOV.
Dans Soft-ice, tapez:
A "entr&eacute;e"
JMP 0 "entr&eacute;e"
"&eacute;chap"

Voil&agrave;, nous venons de remplacer le mov eax,4 en un jmp 0.
Ceci va provoquer une exception et le programme va croire que le d&eacute;bugger (Soft-ice)
n'est pas charg&eacute;, donc ce qui va s'occuper de l'exception et le programme se lance!!
Nous avons donc calc.exe charg&eacute;, on peut s'en servir normalement.


2) Virer compl&egrave;tement Armadillo de l'ex&eacute;cutable prot&eacute;g&eacute;:


A) R&eacute;cup&eacute;rer et dumper ce dont nous avons besoin:

   C'est cette partie qui m'a pos&eacute;e le plus de probs, car j'avais une erreur au moment
de reconstruire un ex&eacute;cutable valide ;(
J'ai recommenc&eacute; plusieurs fois, et voil&agrave; comment je me suis pris.

(Ayant demand&eacute; de l'aide sur le forum de l'ATP team, j'ai donc lus leur cours, ma
m&eacute;thode semble &ecirc;tre celle qu'utilise Alsindor, mais Artex utilise une approche
diff&eacute;rente, donc je vous recommande de lire leur superbe cours sur MP3Wizard V1.2 par
Psyché, Artex et Alsindor... J'ai trouv&eacute; mon erreur de toute fa&ccedil;on, je n'utilisais
pas la bonne taille de section ".text". (Leur cours est bas&eacute; sur Armadillo 1.0 je crois)

Donc, vous avez votre programme qui est lanc&eacute;, si vous regardez dans le r&eacute;pertoire
courant (o&ugrave; a &eacute;t&eacute; lanc&eacute; le fichier exe, on trouve un fichier temporaire)
Copiez ce fichier, il va nous servir.
Ensuite, lancez ProcDump et regarder dans la liste des process, vous devez voir
le fichier calc.exe, mais aussi le temporaire.
Faites un click droit dessus (on veut dumper le fichier TEMP !! pas l'exe) et faites
un dump full.
Nous avons donc un fichier ex&eacute;cutable sur le disque, c'est le dump, et nous
avons encore le fichier temp r&eacute;cup&eacute;ré dans le r&eacute;pertoire o&ugrave; a &eacute;t&eacute; lanc&eacute; le programme
crypt&eacute;.


B) Faire un ex&eacute;cutable qui marche, et qui n'ai plus de Armadillo ;)

Si vous renommer le fichier temporaire en ex&eacute;cutable et que vous l'ex&eacute;cutez, il va crasher!
C'est normal car dans la premi&egrave;re Section, on se rend compte qu'elle est pleine de "XX".
Hmm, si on lance le fichier dump&eacute;, il ne marche pas non plus et crash comme un goret ;)

GogogadgetauProcDump lol, vous l'avez compris, lancez ProcDump et servez-vous du PE editor
pour &eacute;diter le fichier dump, vous devez voir les sections du fichier. Il faut regarder
la premi&egrave;re !

Pour ma part, j'avais ceci:


- pour la section ".text" :


   Virtual Offset: 00001000 
         Raw Size: 11A0E
       Raw Offset: 1000


Ok, gardez ces chiffres en t&ecirc;te nous allons y revenir!!
Avec ProcDump, click droit sur la section "text" et faites saves to file pour dumper
le fichier dur le disque ! (exemple: text.bin). Car cette section est compl&egrave;tement d&eacute;crypt&eacute;e 
tandis que le fichier temporaire contient des XX. En effet Armadillo r&eacute;-"&eacute;crit" la section
&agrave; la volée ..
Une fois le fichier dumpé sur le disque, ouvrez votre fichier exe (le fichier Temp renomé)
avec un &eacute;diteur hexad&eacute;cimal, j'utilise HexWorkshop pour cela. Ouvrez &eacute;galement la section
que vous avez dump&eacute;.


Maintenant dans HexWorkshop, pressez alt+f5, entrez le Raw offset de la section 
que vous voulez importer. Ici : 1000 et cliquez sur ok. Allez dans le menu Edit, et cliquez
sur "select block" entrez la longeur (size) de la section , ici : 11A0E...
Regardez le fichier ouvert (text.bin) et pressez 'ctrl+a' pour tout s&eacute;lectionner,
copiez tout &ccedil;a avec 'ctrl+c'.
Retournez dans la fen&ecirc;tre principale de l'ex&eacute;cutable dans HexWorkshop (celui que vous avez 
renomm&eacute; l'ex-fichier temporaire donc), et collez ce que vous venez de copier dans le 
presse papier, faites: 'ctrl+v' ou menu Edit et paste.
Enregistrez votre fichier, et vous avez maintenant une section '.text' valable qui ne
contient donc plus de "XX" hehe...
Lancez votre ex&eacute;cutable et oh !! Miracle cela marche !! 

Mais pour &ecirc;tre s&ucirc;r que le fichier marche bien, on peut reconstruire le PE avec ProcDump,
cela ne co&ucirc;te rien de toutes mani&egrave;re :

- Lancez ProcDump (Merci G-RoM :)
Allez dans les Options et s&eacute;lectionnez:

[X]Recompute Object Size
[X]Optmize PE Structure

[X] Use actual import infos
et cliquer sur OK

Cliquez sur Rebuild PE, et cherchez notre nouveau fichier (calc_finis.exe pour nous)

ProcDump nous fais une valide import table et notre ex&eacute;cutable est d&eacute;sormais plus s&ucirc;r ;o)

Voil&agrave; !! J'ai d'ailleurs programm&eacute; un unpacker avec un pote pour Armadillo
Il sera disponible sur mon site d'ici quelque temps !! (qd j'aurais le go&ucirc;t lol)


Notes suppl&eacute;mentaires sur les PACKERS:

Pour unpacker neolite, c'est vraiment tr&egrave;s ressemblant avec Aspack !!
Donc tracez et cherchez pour un JMP EAX (si mes souvenirs sont bons !!!)
Bref rien de bien dur, ca s'unpack les doigts dans le nez ;-D
hihihihihi! donc pour UPX !!

UPX utilise un JUMP fixe (JUMP 401000) , il suffit de le trouver et de dumper,
je ne vais pas &eacute;crire des cours sur tout les packers lol !!
Il existe d&eacute;j&agrave; pas mal de cours sur l'unpacking sur le net si vraiment cela ne vous
suffisait pas!!


</pre>
<font size="+2"><a name="checksum"><b><u>Checksum</u></B></a></font><br>
<br>
<pre>

Imaginez que vous venez de cracker une messagebox en m&eacute;moire ou autre merdes et 
que apr&egrave;s avoir modifi&eacute; le programme en hexa, le fichier ne se lance plus
du tout, mais quitte directe !! Ou encore qu'il vous dise: "CRC ERROR blablablaa"
Et l&agrave; vous dites!! Merde!!!!! C'est quoi ce bordel! Je peux m&ecirc;me pas patcher ;(
Alors soit vous utilisez un mem patcher (patch qui ne patch qu'en m&eacute;moire donc le programme
est tjs intacte, mais a besoin d'&ecirc;tre lanc&eacute; avec &ccedil;a) soit vous r&eacute;fl&eacute;chissez :)

Ca peut tr&egrave;s bien &ecirc;tre plusieurs choses en fait !!

On va commencer par le checksum !
C'est quoi ? 
En fait, le programme fait une somme des valeurs ascii du programme et les compares
&agrave; une constante par exemple!
Et tant que c'est &eacute;gal &agrave; cette constante, le programme se lance sans broncher!
Mais vous, vous venez de patcher avec des NOP, je, JMP ou autres !!
et ces instructions n'ont pas le m&ecirc;me poids !

exemple &agrave; 2 francs:

Il y avait un:

JE   XXXXXXXXXX

et vous l'avez remplac&eacute; par un JNE (BEURK, mais &ccedil;a sera plus simple pour kicker le
checksum).

On dira que &ccedil;a ressemblait &agrave; &ccedil;a en hexa:

7428   (pour le "je")  == 74h + 28h = 9Ch = 156

donc 156 en d&eacute;cimal !! et vous avez patch&eacute; en JNE:

7528 (pour le "jne") == 75h + 28 h = 9Dh = 157

157 est diff&eacute;rent de 156 donc en additionnant tout les octets un &agrave; un, le programme trouvera
une diff&eacute;rence et ne se lancera PAS :)
Comment contourner &ccedil;a ?

Ben, moi je modifierais &ccedil;a en :

7527  = 75h + 27h = 9Ch = 156

On s'en fou de la valeur apr&egrave;s le jne car il ne sautera pas!!
et le r&eacute;sultat est donc &eacute;gal &agrave; 156 et il croit que tout est OK :P
Bref c'est tout con mais &ccedil;a marche tr&egrave;s bien !
Si par bonheur le programme vous annonce que le fichier avait &eacute;t&eacute; modifi&eacute;, pas la peine
de jouer avec les octets comme &ccedil;a mais d&eacute;sassemblez le fichier plut&ocirc;t et regardez
dans les String Data References le message qu'il nous donnait et crackez moi &ccedil;a 
siou plait ;p

Il peut y avoir aussi un CRC, c'est plus compliqu&eacute; et je ne vais pas expliquer le fonctionnement
de celui-ci ;)
Il utilise une table qui est la suivante pour les programmes en Win32:



CRC-32 Table



  00h   00000000 77073096 EE0E612C 990951BA

  04h   076DC419 706AF48F E963A535 9E6495A3

  08h   0EDB8832 79DCB8A4 E0D5E91E 97D2D988

  0Ch   09B64C2B 7EB17CBD E7B82D07 90BF1D91



  10h   1DB71064 6AB020F2 F3B97148 84BE41DE

  14h   1ADAD47D 6DDDE4EB F4D4B551 83D385C7

  18h   136C9856 646BA8C0 FD62F97A 8A65C9EC

  1Ch   14015C4F 63066CD9 FA0F3D63 8D080DF5



  20h   3B6E20C8 4C69105E D56041E4 A2677172

  24h   3C03E4D1 4B04D447 D20D85FD A50AB56B

  28h   35B5A8FA 42B2986C DBBBC9D6 ACBCF940

  2Ch   32D86CE3 45DF5C75 DCD60DCF ABD13D59



  30h   26D930AC 51DE003A C8D75180 BFD06116

  34h   21B4F4B5 56B3C423 CFBA9599 B8BDA50F

  38h   2802B89E 5F058808 C60CD9B2 B10BE924

  3Ch   2F6F7C87 58684C11 C1611DAB B6662D3D



  40h   76DC4190 01DB7106 98D220BC EFD5102A

  44h   71B18589 06B6B51F 9FBFE4A5 E8B8D433

  48h   7807C9A2 0F00F934 9609A88E E10E9818

  4Ch   7F6A0DBB 086D3D2D 91646C97 E6635C01



  50h   6B6B51F4 1C6C6162 856530D8 F262004E

  54h   6C0695ED 1B01A57B 8208F4C1 F50FC457

  58h   65B0D9C6 12B7E950 8BBEB8EA FCB9887C

  5Ch   62DD1DDF 15DA2D49 8CD37CF3 FBD44C65



  60h   4DB26158 3AB551CE A3BC0074 D4BB30E2

  64h   4ADFA541 3DD895D7 A4D1C46D D3D6F4FB

  68h   4369E96A 346ED9FC AD678846 DA60B8D0

  6Ch   44042D73 33031DE5 AA0A4C5F DD0D7CC9



  70h   5005713C 270241AA BE0B1010 C90C2086

  74h   5768B525 206F85B3 B966D409 CE61E49F

  78h   5EDEF90E 29D9C998 B0D09822 C7D7A8B4

  7Ch   59B33D17 2EB40D81 B7BD5C3B C0BA6CAD



  80h   EDB88320 9ABFB3B6 03B6E20C 74B1D29A

  84h   EAD54739 9DD277AF 04DB2615 73DC1683

  88h   E3630B12 94643B84 0D6D6A3E 7A6A5AA8

  8Ch   E40ECF0B 9309FF9D 0A00AE27 7D079EB1



  90h   F00F9344 8708A3D2 1E01F268 6906C2FE

  94h   F762575D 806567CB 196C3671 6E6B06E7

  98h   FED41B76 89D32BE0 10DA7A5A 67DD4ACC

  9Ch   F9B9DF6F 8EBEEFF9 17B7BE43 60B08ED5



  A0h   D6D6A3E8 A1D1937E 38D8C2C4 4FDFF252

  A4h   D1BB67F1 A6BC5767 3FB506DD 48B2364B

  A8h   D80D2BDA AF0A1B4C 36034AF6 41047A60

  ACh   DF60EFC3 A867DF55 316E8EEF 4669BE79



  B0h   CB61B38C BC66831A 256FD2A0 5268E236

  B4h   CC0C7795 BB0B4703 220216B9 5505262F

  B8h   C5BA3BBE B2BD0B28 2BB45A92 5CB36A04

  BCh   C2D7FFA7 B5D0CF31 2CD99E8B 5BDEAE1D



  C0h   9B64C2B0 EC63F226 756AA39C 026D930A

  C4h   9C0906A9 EB0E363F 72076785 05005713

  C8h   95BF4A82 E2B87A14 7BB12BAE 0CB61B38

  CCh   92D28E9B E5D5BE0D 7CDCEFB7 0BDBDF21



  D0h   86D3D2D4 F1D4E242 68DDB3F8 1FDA836E

  D4h   81BE16CD F6B9265B 6FB077E1 18B74777

  D8h   88085AE6 FF0F6A70 66063BCA 11010B5C

  DCh   8F659EFF F862AE69 616BFFD3 166CCF45



  E0h   A00AE278 D70DD2EE 4E048354 3903B3C2

  E4h   A7672661 D06016F7 4969474D 3E6E77DB

  E8h   AED16A4A D9D65ADC 40DF0B66 37D83BF0

  ECh   A9BCAE53 DEBB9EC5 47B2CF7F 30B5FFE9



  F0h   BDBDF21C CABAC28A 53B39330 24B4A3A6

  F4h   BAD03605 CDD70693 54DE5729 23D967BF

  F8h   B3667A2E C4614AB8 5D681B02 2A6F2B94

  FCh   B40BBE37 C30C8EA1 5A05DF1B 2D02EF8D



Voici un exemple trouv&eacute; sur comment utiliser cette table!
Je ne vais pas expliquer, je donne &ccedil;a juste pour ceux qui en veulent tjs plus !
Car il existe d&eacute;j&agrave; un super tut sur les CRC ! En anglais mais tr&egrave;s cool qd m&ecirc;me:
*CRC and how to Reverse it* by Anarchriz/DREAD (www.dread.cjb.net <-- pas trop s&ucirc;r)
Mais vous trouverez un lien vers ce site sur ma page sans probl&egrave;me si ce n'est pas la bonne.

// les sources
********************************************************************************************


{-------------------------------------------------------------
  This unit is freeware. I found it somewhere on CIS, I think.
  Peter Tiemann
 -------------------------------------------------------------}
Unit Crc32;

interface

uses
  Dialogs,
  SysUtils,
  WinTypes,
  WinProcs;

function UpdateCRC32(InitCRC: LongInt; Buffer: Pointer; BufferLength: WORD): LongInt;
function ComputeFileCRC32(const FileName: string): LongInt;

implementation

type
   CRCTable = Array[0..255] of LongInt;

const
   BufferLength = 16384;
   CRC32Table: CRCTable = (
       $000000000, $077073096, $0ee0e612c, $0990951ba,
       $0076dc419, $0706af48f, $0e963a535, $09e6495a3,
       $00edb8832, $079dcb8a4, $0e0d5e91e, $097d2d988,
       $009b64c2b, $07eb17cbd, $0e7b82d07, $090bf1d91,

       $01db71064, $06ab020f2, $0f3b97148, $084be41de,
       $01adad47d, $06ddde4eb, $0f4d4b551, $083d385c7,
       $0136c9856, $0646ba8c0, $0fd62f97a, $08a65c9ec,
       $014015c4f, $063066cd9, $0fa0f3d63, $08d080df5,

       $03b6e20c8, $04c69105e, $0d56041e4, $0a2677172,
       $03c03e4d1, $04b04d447, $0d20d85fd, $0a50ab56b,
       $035b5a8fa, $042b2986c, $0dbbbc9d6, $0acbcf940,
       $032d86ce3, $045df5c75, $0dcd60dcf, $0abd13d59,

       $026d930ac, $051de003a, $0c8d75180, $0bfd06116,
       $021b4f4b5, $056b3c423, $0cfba9599, $0b8bda50f,
       $02802b89e, $05f058808, $0c60cd9b2, $0b10be924,
       $02f6f7c87, $058684c11, $0c1611dab, $0b6662d3d,

       $076dc4190, $001db7106, $098d220bc, $0efd5102a,
       $071b18589, $006b6b51f, $09fbfe4a5, $0e8b8d433,
       $07807c9a2, $00f00f934, $09609a88e, $0e10e9818,
       $07f6a0dbb, $0086d3d2d, $091646c97, $0e6635c01,

       $06b6b51f4, $01c6c6162, $0856530d8, $0f262004e,
       $06c0695ed, $01b01a57b, $08208f4c1, $0f50fc457,
       $065b0d9c6, $012b7e950, $08bbeb8ea, $0fcb9887c,
       $062dd1ddf, $015da2d49, $08cd37cf3, $0fbd44c65,

       $04db26158, $03ab551ce, $0a3bc0074, $0d4bb30e2,
       $04adfa541, $03dd895d7, $0a4d1c46d, $0d3d6f4fb,
       $04369e96a, $0346ed9fc, $0ad678846, $0da60b8d0,
       $044042d73, $033031de5, $0aa0a4c5f, $0dd0d7cc9,

       $05005713c, $0270241aa, $0be0b1010, $0c90c2086,
       $05768b525, $0206f85b3, $0b966d409, $0ce61e49f,
       $05edef90e, $029d9c998, $0b0d09822, $0c7d7a8b4,
       $059b33d17, $02eb40d81, $0b7bd5c3b, $0c0ba6cad,

       $0edb88320, $09abfb3b6, $003b6e20c, $074b1d29a,
       $0ead54739, $09dd277af, $004db2615, $073dc1683,
       $0e3630b12, $094643b84, $00d6d6a3e, $07a6a5aa8,
       $0e40ecf0b, $09309ff9d, $00a00ae27, $07d079eb1,

       $0f00f9344, $08708a3d2, $01e01f268, $06906c2fe,
       $0f762575d, $0806567cb, $0196c3671, $06e6b06e7,
       $0fed41b76, $089d32be0, $010da7a5a, $067dd4acc,
       $0f9b9df6f, $08ebeeff9, $017b7be43, $060b08ed5,

       $0d6d6a3e8, $0a1d1937e, $038d8c2c4, $04fdff252,
       $0d1bb67f1, $0a6bc5767, $03fb506dd, $048b2364b,
       $0d80d2bda, $0af0a1b4c, $036034af6, $041047a60,
       $0df60efc3, $0a867df55, $0316e8eef, $04669be79,

       $0cb61b38c, $0bc66831a, $0256fd2a0, $05268e236,
       $0cc0c7795, $0bb0b4703, $0220216b9, $05505262f,
       $0c5ba3bbe, $0b2bd0b28, $02bb45a92, $05cb36a04,
       $0c2d7ffa7, $0b5d0cf31, $02cd99e8b, $05bdeae1d,

       $09b64c2b0, $0ec63f226, $0756aa39c, $0026d930a,
       $09c0906a9, $0eb0e363f, $072076785, $005005713,
       $095bf4a82, $0e2b87a14, $07bb12bae, $00cb61b38,
       $092d28e9b, $0e5d5be0d, $07cdcefb7, $00bdbdf21,

       $086d3d2d4, $0f1d4e242, $068ddb3f8, $01fda836e,
       $081be16cd, $0f6b9265b, $06fb077e1, $018b74777,
       $088085ae6, $0ff0f6a70, $066063bca, $011010b5c,
       $08f659eff, $0f862ae69, $0616bffd3, $0166ccf45,

       $0a00ae278, $0d70dd2ee, $04e048354, $03903b3c2,
       $0a7672661, $0d06016f7, $04969474d, $03e6e77db,
       $0aed16a4a, $0d9d65adc, $040df0b66, $037d83bf0,
       $0a9bcae53, $0debb9ec5, $047b2cf7f, $030b5ffe9,

       $0bdbdf21c, $0cabac28a, $053b39330, $024b4a3a6,
       $0bad03605, $0cdd70693, $054de5729, $023d967bf,
       $0b3667a2e, $0c4614ab8, $05d681b02, $02a6f2b94,
       $0b40bbe37, $0c30c8ea1, $05a05df1b, $02d02ef8d);

var
   Buffer: Array[1..BufferLength] of Byte;

{$ifndef WIN32}
type
   DWORD = longint;
{$endif}

function UpdateCRC32(InitCRC: LongInt; Buffer: Pointer; BufferLength: WORD): LongInt;
var
   crc: LongInt;
   index: integer;
   i: integer;
begin
   crc := InitCRC;
   for i := 0 to BufferLength-1 do
   begin
    index := (crc  xor Integer(Pointer(DWORD(Buffer)+i)^)) and  $000000FF;
    crc := ((crc shr 8) and $00FFFFFF) xor CRC32Table[index];
   end;
   Result := crc;
end;

function ComputeFileCRC32(const FileName : string): LongInt;
var
   InputFile: File;
   Crc32: LongInt;
   ResultLength: Integer;
   BufPtr: Pointer;
begin
   BufPtr := @Buffer;
   Assign(InputFile, FileName);
   Reset(InputFile, 1);
   Crc32 := $FFFFFFFF;    { 32 bit crc starts with all bits on }
   Repeat
     BlockRead(InputFile, Buffer, BufferLength, ResultLength);
     Crc32 := UpdateCrc32(Crc32, BufPtr, ResultLength);
   Until Eof(InputFile);
   Close(InputFile);
   Crc32 := Not(Crc32);   { Finish 32 bit crc by inverting all bits }
   Result := CRC32;
end;

end.


// fin des sources
********************************************************************************************

Cette source est freeware, c'est juste pour vous montrer un exemple d'utilisation!
Elle ne vient pas de moi non plus comme vous avez pu le voir...


Ce qui peut nous faire chier aussi est le Test du nombre de NOP!!
En effet il est possible qu'un programme se scan &agrave; la recherche de NOPs trop r&eacute;p&eacute;titif
donc une fa&ccedil;on "d'effacer" est de mettre des INC et des DEC !!
exemple:

7428   --> 9090 (le nop de base)
7428   --> 4041 (INC , DEC)

Cela ne fait rien de mal et &ccedil;a a effac&eacute; le saut !! et on a pas utilis&eacute; de nops :)
Mais il faut tjs incr&eacute;menter autant de fois que vous d&eacute;cr&eacute;mentez !!
Si on avait eu 5 bits &agrave; patcher : 4041404190
Un seul nop passera si le programme cherche au minimum 2 ou 3 nops cons&eacute;cutifs!

Voil&agrave;, je ne sais plus trop quoi ajouter sur la partie des checksums!!


</pre>
<font size="+2"><a name="antisice"><b><u>Anti Soft-ice</u></B></a></font><br>
<br>
<pre>

Bon, je ne vais pas m'attarder sur ce chapitre non plus !! car il existe
d&eacute;j&agrave; un SUPERBE tool pour cacher Soft-ice! 
FrogsICE par +Frog's Print !
On trouve dedans de la Doc sur les m&eacute;thodes de d&eacute;tection donc, je ne saurais
que vous incitez &agrave; t&eacute;l&eacute;charger ce magnifique programme !!
D&eacute;sol&eacute; si je ne d&eacute;taille pas des masses cette partie, mais &ccedil;a fait d&eacute;j&agrave; 4 jours que
je suis malade et &ccedil;a va pas super :'(



Je vais juste vous pr&eacute;senter les d&eacute;tections les plus courantes :


* Melt ice:


La m&eacute;thode utilis&eacute;e pour d&eacute;tecter Soft-ice est la suivante:
il utilise l'API createfilea "afin de d&eacute;tecter le VXD" !
D&eacute;sol&eacute;, je ne sais pas trop comment expliquer:
il peut d&eacute;tecter Soft-ice avec: SICE, SIWVID pour win9x et NTICE pour winNT


BOOL IsSoftIce95Loaded()
{
   HANDLE hFile;  
   hFile = CreateFile( "\\\\.\\SICE", GENERIC_READ | GENERIC_WRITE,
                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                      NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
   if( hFile != INVALID_HANDLE_VALUE )
   {
      CloseHandle(hFile);
      return TRUE;
   }
   return FALSE;
}


// Pris de la doc de Frogsice


Voici 1 exemple en Delphi de comment programmer ca:


**********************************************************************************************
procedure DetectICE;
var ACiD:Thandle;
    s,s2:string;

begin

     s:='\' + '\' + '.' + '\' + 'S' + 'I' + 'C' + 'E';
     s2:='\\.\SICE';
     if s <> s2 then begin ShowMessage('NO PATCH'); ExitProcess(0); end ;
     ACiD:=CreateFileA(PChar(s2),GENERIC_READ or GENERIC_WRITE,FILE_SHARE_READ
         or FILE_SHARE_WRITE,nil,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
     if ACiD <> INVALID_HANDLE_VALUE then begin ShowMessage('Kick Soft-ice and come back ! =)'); ExitProcess(0); end ;

     s:='\' + '\' + '.' + '\' + 'N' + 'T' + 'I' + 'C' + 'E';
     s2:='\\.\NTICE';
     if s <> s2 then begin ShowMessage('NO PATCH'); ExitProcess(0); end ;
     ACiD:=CreateFileA(PChar(s2),GENERIC_READ or GENERIC_WRITE,FILE_SHARE_READ
         or FILE_SHARE_WRITE,nil,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,0);
     if( ACiD <> INVALID_HANDLE_VALUE ) then begin ShowMessage('Kick Soft-ice and come back ! =)'); ExitProcess(0); end;

end;

**********************************************************************************************


Voil&agrave;, vous voyez &ccedil;a ressemble bcp &agrave; ce qu'on a plus haut !!
Donc comment cracker &ccedil;a maintenant ?


Tr&egrave;s simple, vous mettez un bpx createfilea.
Vous lancez le programme prot&eacute;g&eacute; et vous devez arriver sous Soft-ice!!
F12 une fois et vous devez trouver qq chose qui ressemble &agrave; &ccedil;a:

XXXXXXXX  FF1520A00010      CALL    [KERNEL32!CreateFileA]
XXXXXXXX  83F8FF            CMP     EAX,-01    <- si EAX= -1 Soft-ice n'est pas charg&eacute;
XXXXXXXX  7409              JZ      100038A9   <-- &ccedil;a saute vers le programme :)


Donc si on veut le lancer quoi qu'il arrive, on remplace le "JZ" en "JMP" et on n'en parle
plus :)

Encore une fois, allez voir la doc de frogsICE qui vous donne des info compl&eacute;mentaires.
Je ne suis pas l&agrave; pour "pomper" les autres donc, je ne le mettrai pas ici :P



* d&eacute;tection par INT 68h:


    mov     ah,43h
    int     68h
    cmp     ax,0F386h
    jz      Soft_ice_est_la_:P


Voil&agrave; &agrave; quoi ressemble le monstre ;P


Un petit exemple de programmation en Delphi :

*****************************************************************************************

procedure INT68;
label Ure_Good_Guy;
label I_Got_You;

Begin

asm
mov  ah,43h
int  68h
cmp  ax,0f386h
jz   I_Got_You
jmp  Ure_Good_Guy

end;

I_Got_You:
showmessage('Soft-ice est chargé!!');

Ure_Good_Guy:
// Gentil lol pas de Soft-ice (ou je me suis fait cracker *g*)

end;

end.

******************************************************************************************


Il existe diff&eacute;rentes fa&ccedil;ons de cracker &ccedil;a:


On ne peut pas mettre de Bpint sur 68, voici une fa&ccedil;on de contourner:

BPX exec_int if ax==68

Il existe d'autres fa&ccedil;ons, mais je ne m'en rappelle plus actuellement :'(
Je dois retrouver mes notes, donc cette partie sera remise &agrave; jour plus tard (lol on dirait
Krosoft ;)


Donc apr&egrave;s avoir breaker sous Soft-ice gr&acirc;ce &agrave; ce BPX, on va trouver un code qui ressemble
&agrave; &ccedil;a:


XXXXXXXX 	mov  ah,43h
XXXXXXXX	int  68h
XXXXXXXX	cmp  ax,0f386h
XXXXXxXX	je   XXXXXXXX     <--- saute au mauvais endroit (BAD CRACKER SICE LOADED)
XXXXXXXX	jmp  XXXXXXXX     <-- Gentil cracker !! on se sert pas de Soft-ice lol 


Ben vous pouvez noper le je par exemple et il sautera tjs au bon endroit !!
sans jamais se douter que Soft-ice est charg&eacute; :]


* d&eacute;tection par Int 3 (cherche la signature de boundcheck dans Soft-ice)


    mov     ebp, 04243484Bh        ; 'BCHK'
    mov     ax, 04h
    int     3       
    cmp     al,4
    jnz     Soft_ice_est_la_:P


On retrouve une d&eacute;tection par int3 dans Armadillo aussi :


025F:00402243  8885B8FEFFFF        MOV     [EBP-0148],AL
025F:00402249  BA6D447546          MOV     EDX,4675446D
025F:0040224E  8995B0FEFFFF        MOV     [EBP-0150],EDX
025F:00402254  C785C4FEFFFF260C3604MOV     DWORD PTR [EBP-013C],04360C26
025F:0040225E  895DFC              MOV     [EBP-04],EBX
025F:00402261  8B85C4FEFFFF        MOV     EAX,[EBP-013C]
025F:00402267  3385B0FEFFFF        XOR     EAX,[EBP-0150]
025F:0040226D  8BE8                MOV     EBP,EAX
025F:0040226F  B804000000          MOV     EAX,00000004
025F:00402274  CC                  INT     3                 <----- le chti INT :p
025F:00402275  3115148D4000        XOR     [00408D14],EDX
025F:0040227B  A180804000          MOV     EAX,[00408080]
025F:00402280  310584804000        XOR     [00408084],EAX
025F:00402286  834DFCFF            OR      DWORD PTR [EBP-04],-01
025F:0040228A  EB18                JMP     004022A4


On se met sur le "MOV EAX, 00000004"
Pour passer ce contr&ocirc;le, il suffit de se mettre &agrave; la ligne du MOV.
Dans Soft-ice, tapez:
A "entr&eacute;e"
JMP 0 "entr&eacute;e"
"&eacute;chap"

C'&eacute;tait juste un exemple....

Pour en revenir &agrave; notre code de base pour la d&eacute;tection par int 3, il suffit aussi
de jouer avec le saut conditionnel pour r&eacute;soudre tout nos probs :]
Pas besoin de vous faire un dessin je pense!


Voil&agrave;, je vous ai d&eacute;crit (tr&egrave;s vite) les 3 d&eacute;tections de Soft-ice que je rencontre
dans les programmes!
Elles sont tr&egrave;s courantes!
Je vous conseille donc encore une fois d'aller lire la documentation fournie avec FrogsICE
afin d'en apprendre plus!! 
Je suis pas l&agrave; pour faire du copier / coller lol
</pre>
<a href="http://www.woodmann.com/theanalyst/www.thepentagon.com/frog_s_print">Frog's Print</a>
<pre>

Ici se termine la partie anti Soft-ice...


</pre>
<font size="+2"><a name="divers"><b><u>Divers :</u></B></a></font><br>
<br>
<pre>


******************************************************************
***	Changer l'image d'un programme en Delphi par exemple       ***
******************************************************************


Cette partie est juste &agrave; but &eacute;ducatif!!
J'ai pris mon dernier crackme en Delphi qui contient une image de fond!
Et je me suis dit, comment faire pour modifier cette image si on a pas les sources
et sans utiliser de compilateur, d&eacute;compilateur ou autres &eacute;diteurs de ressources !

Voici la m&eacute;thode!

tool n&eacute;cessaire: Editeur hexad&eacute;cimal: HexWorkshop


Ouvrez le fichier dont vous vous voulez changer l'image de fond avec votre &eacute;diteur
hexa.
L'image est soit au format BMP ou JPEG!
Le genre le plus couramment utilis&eacute; est le jpeg car il prends moins de place
et dans mon crackme, j'ai mis un JPEG aussi ...
Bref ouvrez un fichier jpg avec votre &eacute;diteur hexad&eacute;cimal pour regardez par quoi il commence
et par quoi il finit!

Exemple d'un fichier JPEG &eacute;dit&eacute; en mode hexad&eacute;cimal:


FFD8 FFE0 0010 4A46 4946 0001 0100 0001   ......JFIF......
0001 0000 FFDB 0043 0005 0304 0404 0305   .......C........
0404 0405 0505 0607 0C08 0707 0707 0F0B   ................
0B09 0C11 0F12 1211 0F11 1113 161C 1713   ................
141A 1511 1118 2118 1A1D 1D1F 1F1F 1317   ......!.........

......


Si on ouvre plusieurs fichiers jpeg on se rends compte que le d&eacute;but est tjs le m&ecirc;me!
Ils commencent tjs par : FFD8 FFE0 0010 4A46 4946


Si on regarde la fin d'un fichier JPEG on voit ceci:


777F A758 0937 097F A99F 81E5 3FFF D900   w..X.7......?..

On voit que &ccedil;a finis par FFD9 (le 00 n'est pas tr&egrave;s important)


Donc on se dit, si on cherchait ces infos dans le fichier o&ugrave; est l'image
&agrave; changer!!
Alors on fait une recherche des octets suivant: FFD8 FFE0 0010 4A46 4946
et on trouve ca a l'offset: 64C2A
on le note sur un papier au cas ou !! et on cherche: FFD9 et on trouve &ccedil;a
&agrave; l'offset: 70A65

70A66 - 64C2A = BE3Ch = 48700 en d&eacute;cimal

C'est la longueur de l'image!! Donc celle qu'on veut ins&eacute;rer doit &ecirc;tre inf&eacute;rieure
&agrave; cette taille !!
Je cherche sur mon disque dur un de mes logos et je l'ouvre avec mon &eacute;diteur hexa !
(en JPEG aussi l'image &agrave; ins&eacute;rer)
Ensuite je s&eacute;lectionne tout les octets de l'image avec HexWorkshop  (Ctrl+A) et je fais un
copier: ctrl + C ... ( apr&egrave;s avoir fait s&eacute;lectionner tout, je vois en bas le nombre d'octets
de l'image &agrave; ins&eacute;rer -> sel: 4f2fh )
Je me remet &agrave; la fen&ecirc;tre HexWorkshop qui s'occupe de mon crackme et je vais &agrave;
l'offset o&ugrave; l'image commence: 64C2A
Et l&agrave; dans le menu edit, select block, j'entre la longueur de l'image entr&eacute;e en hexa !
Il s&eacute;lectionne dans l'ancienne image la place que va prendre la nouvelle image!
Ensuite on fait coller (Ctrl+V) et si il vous pose un question r&eacute;pondez oui!! ou OK
l'image est plus petite donc il reste un morceau de l'ancienne mais on s'en fous pas mal 
car ce qu'on vient de coller contient le code qui dit que l'image est finie: FFD9
On sauvegarde notre fichier, et on relance! 
Youpi!! on a maintenant une nouvelle image dans mon crackme !! hehe c'est marrant et tr&egrave;s
simple &agrave; faire !!

Vous pouvez faire &ccedil;a avec des images GIF, BMP ou autres !!

Just for knowledge purpose ;]


</pre>
<font size="+2"><a name="greetings"><b><u>Greetings :</u></B></a></font><br>
<br>
<pre>

Group greetings: ID - ECLiPSE - CiA - ODT - EXEC - PWA - PC - UCF- CORE - CC -
                 Nova2000 - PDM

Also greetingz to: (no specific order)

Victoria , R!SC , ^INFeRNo^ , AB4DS , Cyber Blade , Klefz , Volatility ,
TORN@DO , T4D , Jeff , [Virus] , JaNe , Appbusta , Duelist , tKC , BuLLeT ,
Lucifer48 , MiZ , DnNuke , Bjanes , Skymarshall , afkayas , elmopio ,
SiFLyiNG , Fire Worx , CrackZ , neural_en , WarezPup , _y , SiONIDE ,
SKORPIEN , Lazarus , Eternal_Bliss , Magic Raphoun , DEZM , Bisoux ,
Carpathia , K17 , theMc , noos , Xmen , TeeJi , JB007 , Arobas , T0AD , ytc ,
Kwai_lo , Killer_3K , TaMaMBoLo , gizmo , Gota , ExtaBrain , Alpine ,
WarezPup , zoltan , [yAtes] , TarGon , Icecream , Punkguy2 , Sortof ,
TRDdonjuan , Lord Soth , Judged , G-Rom , Quantico , Christal , psike , Leo0n ,
Albator , +Spath , +Frog's Print , toutim , Pulsar , Night , psike , Uno , F|SH ,
Lixus , LosT , RD-116 , Ben0 , Whizkid , [MandKind] , alpine , Alsindor ,
Stone , Elraizer , Fravia+ , Iczelion , nody , Asphalt , Rhythm ,
rudeboy , X-Calibre , Cirus , shaoni...
...
"Mettez votre nom l&agrave;! :P" ...

J'ai s&ucirc;rement oubli&eacute; des tonnes de noms, d&eacute;sol&eacute; ;)

</pre>
<font size="+2"><a name="end"><b><u>Conclusion :</u></B></a></font><br>
<br>
<pre>

Et voil&agrave; ainsi se termine ce *petit* cours de cracking ;)
J'esp&egrave;re avoir &eacute;t&eacute; assez pr&eacute;cis dans mes explications ainsi que mes exemples
et que ce cours vous a apport&eacute; quelque chose ...
Ce tut n'a aucune pr&eacute;tention si ce n'est d'exister, les commentaires et appr&eacute;ciations
sont donc les bienvenues...
Certaines parties n'ont pas &eacute;t&eacute; d&eacute;velopp&eacute;es car, je ne veux pas &eacute;crire un cours
de 1000 pages quand m&ecirc;me.
J'ai &eacute;t&eacute; assez malade ces derniers temps, alors si il y a des petites erreurs,
ou oublis, merci de m'avertir !
Pour toutes remarques, critiques, encouragements: Cracking@acidburn2000.com

Bonne année et bon bugs :P


TUTORIAL DEDICATED TO: Victoria (You rule baby and you own me :P )


                                 "Mess with the best, die like the rest..."


					MAIL ME CRACKS REQUESTS

					        AND I

					          ^
					         | |
					       @#####@
					     (###   ###)-.
					   .(###     ###) \
					  /  (###   ###)   )
					 (=-  .@#####@|_--"
					 /\    \_|l|_/ (\
					(=-\     |l|    /
					 \  \.___|l|___/
					 /\      |_|   /
					(=-\._________/\
					 \             /
					  \._________/
					     #  ----  #
					     #   __   #
					     \########/


					     SHOOT YOU



                          Tutorial par ACiD BuRN [Immortal Descendants ]

    			     "Je crois que je vais aller dormir now :)"


</pre>
<br>
<hr>
<hr>
<br>
<div align="center"><font face="Times New Roman, Times, serif" size="3">Copyright 
  1999 <a href="mailto:acid2600@hotmail.com">ACiD BuRN</a> and the <a href="http://www.ImmortalDescendants.org">Immortal 
  Descendants</a> (c) All rights reversed :)</font></div>
<center>
  <a href="http://www.AcidBurn2k.cjb.net">ACiD BuRN's home page</a> 
</center>
  

</BODY></html>